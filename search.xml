<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线性结构（下）</title>
      <link href="/2023/12/13/xian-xing-jie-gou-xia/"/>
      <url>/2023/12/13/xian-xing-jie-gou-xia/</url>
      
        <content type="html"><![CDATA[<h3 id="1-队列"><a href="#1-队列" class="headerlink" title="1.队列"></a>1.队列</h3><h4 id="1-1数组实现"><a href="#1-1数组实现" class="headerlink" title="1.1数组实现"></a>1.1数组实现</h4><p><strong>①结构代码</strong></p><blockquote><p><code>rear</code>：指向<strong>队尾的“指针”</strong>，<strong>插入</strong>一个元素时，<code>rear</code><strong>加一</strong></p></blockquote><blockquote><p><code>front</code>：指向<strong>队头的“指针”</strong>，<strong>删除</strong>一个元素时，<code>front</code><strong>加一</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当“指针”可以在超过MaxSize且列表未满时，对MaxSize取余再次从0开始，需要一个状态标签判断队列是否已满</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 山不转水转！</div><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 基于环形数组实现的队列 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">;</span>       <span class="token comment">// 用于存储队列元素的数组</span>    <span class="token keyword">int</span> front<span class="token punctuation">;</span>       <span class="token comment">// 队首指针，指向队首元素</span>    <span class="token keyword">int</span> queSize<span class="token punctuation">;</span>     <span class="token comment">// 尾指针，指向队尾 + 1</span>    <span class="token keyword">int</span> queCapacity<span class="token punctuation">;</span> <span class="token comment">// 队列容量</span><span class="token punctuation">}</span> ArrayQueue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②构造与析构</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 构造函数 */</span>ArrayQueue <span class="token operator">*</span><span class="token function">newArrayQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ArrayQueue <span class="token operator">*</span>queue <span class="token operator">=</span> <span class="token punctuation">(</span>ArrayQueue <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ArrayQueue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 初始化数组</span>    queue<span class="token operator">-&gt;</span>queCapacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    queue<span class="token operator">-&gt;</span>nums <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> queue<span class="token operator">-&gt;</span>queCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token operator">-&gt;</span>front <span class="token operator">=</span> queue<span class="token operator">-&gt;</span>queSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> queue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 析构函数 */</span><span class="token keyword">void</span> <span class="token function">delArrayQueue</span><span class="token punctuation">(</span>ArrayQueue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">free</span><span class="token punctuation">(</span>queue<span class="token operator">-&gt;</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③操作集</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 获取队列的容量 */</span><span class="token keyword">int</span> <span class="token function">capacity</span><span class="token punctuation">(</span>ArrayQueue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> queue<span class="token operator">-&gt;</span>queCapacity<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 获取队列的长度 */</span><span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span>ArrayQueue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> queue<span class="token operator">-&gt;</span>queSize<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 判断队列是否为空 */</span>bool <span class="token function">empty</span><span class="token punctuation">(</span>ArrayQueue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> queue<span class="token operator">-&gt;</span>queSize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 访问队首元素 */</span><span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span>ArrayQueue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> queue<span class="token operator">-&gt;</span>nums<span class="token punctuation">[</span>queue<span class="token operator">-&gt;</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 入队 */</span><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>ArrayQueue <span class="token operator">*</span>queue<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">capacity</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"队列已满\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 计算队尾指针，指向队尾索引 + 1</span>    <span class="token comment">// 通过取余操作，实现 rear 越过数组尾部后回到头部</span>    <span class="token keyword">int</span> rear <span class="token operator">=</span> <span class="token punctuation">(</span>queue<span class="token operator">-&gt;</span>front <span class="token operator">+</span> queue<span class="token operator">-&gt;</span>queSize<span class="token punctuation">)</span> <span class="token operator">%</span> queue<span class="token operator">-&gt;</span>queCapacity<span class="token punctuation">;</span>    <span class="token comment">// 将 num 添加至队尾</span>    queue<span class="token operator">-&gt;</span>nums<span class="token punctuation">[</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>    queue<span class="token operator">-&gt;</span>queSize<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 出队 */</span><span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span>ArrayQueue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 队首指针向后移动一位，若越过尾部则返回到数组头部</span>    queue<span class="token operator">-&gt;</span>front <span class="token operator">=</span> <span class="token punctuation">(</span>queue<span class="token operator">-&gt;</span>front <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> queue<span class="token operator">-&gt;</span>queCapacity<span class="token punctuation">;</span>    queue<span class="token operator">-&gt;</span>queSize<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2链表实现"><a href="#1-2链表实现" class="headerlink" title="1.2链表实现"></a>1.2链表实现</h4><p><strong>①结构代码</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 基于链表实现的队列 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    ListNode <span class="token operator">*</span>front<span class="token punctuation">,</span> <span class="token operator">*</span>rear<span class="token punctuation">;</span>    <span class="token keyword">int</span> queSize<span class="token punctuation">;</span><span class="token punctuation">}</span> LinkedListQueue<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②构造与析构</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 构造函数 */</span>LinkedListQueue <span class="token operator">*</span><span class="token function">newLinkedListQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LinkedListQueue <span class="token operator">*</span>queue <span class="token operator">=</span> <span class="token punctuation">(</span>LinkedListQueue <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkedListQueue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token operator">-&gt;</span>front <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    queue<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    queue<span class="token operator">-&gt;</span>queSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> queue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 析构函数 */</span><span class="token keyword">void</span> <span class="token function">delLinkedListQueue</span><span class="token punctuation">(</span>LinkedListQueue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 释放所有节点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> queue<span class="token operator">-&gt;</span>queSize <span class="token operator">&amp;&amp;</span> queue<span class="token operator">-&gt;</span>front <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>tmp <span class="token operator">=</span> queue<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span>        queue<span class="token operator">-&gt;</span>front <span class="token operator">=</span> queue<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 释放 queue 结构体</span>    <span class="token function">free</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②操作集实现</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 访问队首元素 */</span><span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span>LinkedListQueue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> queue<span class="token operator">-&gt;</span>front<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> queue<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 获取队列的长度 */</span><span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span>LinkedListQueue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> queue<span class="token operator">-&gt;</span>queSize<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 判断队列是否为空 */</span>bool <span class="token function">empty</span><span class="token punctuation">(</span>LinkedListQueue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 访问队首元素 */</span><span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span>LinkedListQueue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> queue<span class="token operator">-&gt;</span>front<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> queue<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 入队 */</span><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>LinkedListQueue <span class="token operator">*</span>queue<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 尾节点处添加 node</span>    ListNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token function">newListNode</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 如果队列为空，则令头、尾节点都指向该节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>queue<span class="token operator">-&gt;</span>front <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        queue<span class="token operator">-&gt;</span>front <span class="token operator">=</span> node<span class="token punctuation">;</span>        queue<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 如果队列不为空，则将该节点添加到尾节点后</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        queue<span class="token operator">-&gt;</span>rear<span class="token operator">-&gt;</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>        queue<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    queue<span class="token operator">-&gt;</span>queSize<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 出队 */</span><span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span>LinkedListQueue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode <span class="token operator">*</span>tmp <span class="token operator">=</span> queue<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span>    queue<span class="token operator">-&gt;</span>front <span class="token operator">=</span> queue<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    queue<span class="token operator">-&gt;</span>queSize<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 打印队列 */</span><span class="token keyword">void</span> <span class="token function">printLinkedListQueue</span><span class="token punctuation">(</span>LinkedListQueue <span class="token operator">*</span>queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>arr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> queue<span class="token operator">-&gt;</span>queSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 拷贝链表中的数据到数组</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    ListNode <span class="token operator">*</span>node<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> node <span class="token operator">=</span> queue<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> queue<span class="token operator">-&gt;</span>queSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>        node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> queue<span class="token operator">-&gt;</span>queSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-双向队列"><a href="#2-双向队列" class="headerlink" title="2.双向队列"></a>2.双向队列</h3><h4 id="2-1数组实现"><a href="#2-1数组实现" class="headerlink" title="2.1数组实现"></a>2.1数组实现</h4><p><strong>①结构代码</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 基于环形数组实现的双向队列 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">;</span>       <span class="token comment">// 用于存储队列元素的数组</span>    <span class="token keyword">int</span> front<span class="token punctuation">;</span>       <span class="token comment">// 队首指针，指向队首元素</span>    <span class="token keyword">int</span> queSize<span class="token punctuation">;</span>     <span class="token comment">// 尾指针，指向队尾 + 1</span>    <span class="token keyword">int</span> queCapacity<span class="token punctuation">;</span> <span class="token comment">// 队列容量</span><span class="token punctuation">}</span> ArrayDeque<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②构造与析构</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 构造函数 */</span>ArrayDeque <span class="token operator">*</span><span class="token function">newArrayDeque</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ArrayDeque <span class="token operator">*</span>deque <span class="token operator">=</span> <span class="token punctuation">(</span>ArrayDeque <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ArrayDeque<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 初始化数组</span>    deque<span class="token operator">-&gt;</span>queCapacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    deque<span class="token operator">-&gt;</span>nums <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> deque<span class="token operator">-&gt;</span>queCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    deque<span class="token operator">-&gt;</span>front <span class="token operator">=</span> deque<span class="token operator">-&gt;</span>queSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> deque<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 析构函数 */</span><span class="token keyword">void</span> <span class="token function">delArrayDeque</span><span class="token punctuation">(</span>ArrayDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">free</span><span class="token punctuation">(</span>deque<span class="token operator">-&gt;</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③操作集</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 获取双向队列的容量 */</span><span class="token keyword">int</span> <span class="token function">capacity</span><span class="token punctuation">(</span>ArrayDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> deque<span class="token operator">-&gt;</span>queCapacity<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 获取双向队列的长度 */</span><span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span>ArrayDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> deque<span class="token operator">-&gt;</span>queSize<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 判断双向队列是否为空 */</span>bool <span class="token function">empty</span><span class="token punctuation">(</span>ArrayDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> deque<span class="token operator">-&gt;</span>queSize <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 计算环形数组索引 */</span><span class="token keyword">int</span> <span class="token function">dequeIndex</span><span class="token punctuation">(</span>ArrayDeque <span class="token operator">*</span>deque<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 通过取余操作实现数组首尾相连</span>    <span class="token comment">// 当 i 越过数组尾部时，回到头部</span>    <span class="token comment">// 当 i 越过数组头部后，回到尾部</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token function">capacity</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token function">capacity</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 队首入队 */</span><span class="token keyword">void</span> <span class="token function">pushFirst</span><span class="token punctuation">(</span>ArrayDeque <span class="token operator">*</span>deque<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>deque<span class="token operator">-&gt;</span>queSize <span class="token operator">==</span> <span class="token function">capacity</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"双向队列已满\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 队首指针向左移动一位</span>    <span class="token comment">// 通过取余操作，实现 front 越过数组头部回到尾部</span>    deque<span class="token operator">-&gt;</span>front <span class="token operator">=</span> <span class="token function">dequeIndex</span><span class="token punctuation">(</span>deque<span class="token punctuation">,</span> deque<span class="token operator">-&gt;</span>front <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 num 添加到队首</span>    deque<span class="token operator">-&gt;</span>nums<span class="token punctuation">[</span>deque<span class="token operator">-&gt;</span>front<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>    deque<span class="token operator">-&gt;</span>queSize<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 队尾入队 */</span><span class="token keyword">void</span> <span class="token function">pushLast</span><span class="token punctuation">(</span>ArrayDeque <span class="token operator">*</span>deque<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>deque<span class="token operator">-&gt;</span>queSize <span class="token operator">==</span> <span class="token function">capacity</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"双向队列已满\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 计算尾指针，指向队尾索引 + 1</span>    <span class="token keyword">int</span> rear <span class="token operator">=</span> <span class="token function">dequeIndex</span><span class="token punctuation">(</span>deque<span class="token punctuation">,</span> deque<span class="token operator">-&gt;</span>front <span class="token operator">+</span> deque<span class="token operator">-&gt;</span>queSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 将 num 添加至队尾</span>    deque<span class="token operator">-&gt;</span>nums<span class="token punctuation">[</span>rear<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>    deque<span class="token operator">-&gt;</span>queSize<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 访问队首元素 */</span><span class="token keyword">int</span> <span class="token function">peekFirst</span><span class="token punctuation">(</span>ArrayDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 访问异常：双向队列为空</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> deque<span class="token operator">-&gt;</span>nums<span class="token punctuation">[</span>deque<span class="token operator">-&gt;</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 访问队尾元素 */</span><span class="token keyword">int</span> <span class="token function">peekLast</span><span class="token punctuation">(</span>ArrayDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 访问异常：双向队列为空</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> last <span class="token operator">=</span> <span class="token function">dequeIndex</span><span class="token punctuation">(</span>deque<span class="token punctuation">,</span> deque<span class="token operator">-&gt;</span>front <span class="token operator">+</span> deque<span class="token operator">-&gt;</span>queSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> deque<span class="token operator">-&gt;</span>nums<span class="token punctuation">[</span>last<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 队首出队 */</span><span class="token keyword">int</span> <span class="token function">popFirst</span><span class="token punctuation">(</span>ArrayDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">peekFirst</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 队首指针向后移动一位</span>    deque<span class="token operator">-&gt;</span>front <span class="token operator">=</span> <span class="token function">dequeIndex</span><span class="token punctuation">(</span>deque<span class="token punctuation">,</span> deque<span class="token operator">-&gt;</span>front <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    deque<span class="token operator">-&gt;</span>queSize<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 队尾出队 */</span><span class="token keyword">int</span> <span class="token function">popLast</span><span class="token punctuation">(</span>ArrayDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">peekLast</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">;</span>    deque<span class="token operator">-&gt;</span>queSize<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2链表实现"><a href="#2-2链表实现" class="headerlink" title="2.2链表实现"></a>2.2链表实现</h4><p><strong>①结构代码</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 双向链表节点 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">DoublyListNode</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>                     <span class="token comment">// 节点值</span>    <span class="token keyword">struct</span> <span class="token class-name">DoublyListNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 后继节点</span>    <span class="token keyword">struct</span> <span class="token class-name">DoublyListNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span> <span class="token comment">// 前驱节点</span><span class="token punctuation">}</span> DoublyListNode<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②构造与析构</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 构造函数 */</span>DoublyListNode <span class="token operator">*</span><span class="token function">newDoublyListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    DoublyListNode <span class="token operator">*</span>new <span class="token operator">=</span> <span class="token punctuation">(</span>DoublyListNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>DoublyListNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    new<span class="token operator">-&gt;</span>val <span class="token operator">=</span> num<span class="token punctuation">;</span>    new<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    new<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> new<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 析构函数 */</span><span class="token keyword">void</span> <span class="token function">delDoublyListNode</span><span class="token punctuation">(</span>DoublyListNode <span class="token operator">*</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">free</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③操作集</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 基于双向链表实现的双向队列 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    DoublyListNode <span class="token operator">*</span>front<span class="token punctuation">,</span> <span class="token operator">*</span>rear<span class="token punctuation">;</span> <span class="token comment">// 头节点 front ，尾节点 rear</span>    <span class="token keyword">int</span> queSize<span class="token punctuation">;</span>                  <span class="token comment">// 双向队列的长度</span><span class="token punctuation">}</span> LinkedListDeque<span class="token punctuation">;</span><span class="token comment">/* 构造函数 */</span>LinkedListDeque <span class="token operator">*</span><span class="token function">newLinkedListDeque</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LinkedListDeque <span class="token operator">*</span>deque <span class="token operator">=</span> <span class="token punctuation">(</span>LinkedListDeque <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkedListDeque<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    deque<span class="token operator">-&gt;</span>front <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    deque<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    deque<span class="token operator">-&gt;</span>queSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> deque<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 析构函数 */</span><span class="token keyword">void</span> <span class="token function">delLinkedListdeque</span><span class="token punctuation">(</span>LinkedListDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 释放所有节点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> deque<span class="token operator">-&gt;</span>queSize <span class="token operator">&amp;&amp;</span> deque<span class="token operator">-&gt;</span>front <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        DoublyListNode <span class="token operator">*</span>tmp <span class="token operator">=</span> deque<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span>        deque<span class="token operator">-&gt;</span>front <span class="token operator">=</span> deque<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 释放 deque 结构体</span>    <span class="token function">free</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 获取队列的长度 */</span><span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span>LinkedListDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> deque<span class="token operator">-&gt;</span>queSize<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 判断队列是否为空 */</span>bool <span class="token function">empty</span><span class="token punctuation">(</span>LinkedListDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 入队 */</span><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>LinkedListDeque <span class="token operator">*</span>deque<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">,</span> bool isFront<span class="token punctuation">)</span> <span class="token punctuation">{</span>    DoublyListNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token function">newDoublyListNode</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 若链表为空，则令 front 和 rear 都指向node</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        deque<span class="token operator">-&gt;</span>front <span class="token operator">=</span> deque<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 队首入队操作</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isFront<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 将 node 添加至链表头部</span>        deque<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>        node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> deque<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span>        deque<span class="token operator">-&gt;</span>front <span class="token operator">=</span> node<span class="token punctuation">;</span> <span class="token comment">// 更新头节点</span>    <span class="token punctuation">}</span>    <span class="token comment">// 队尾入队操作</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// 将 node 添加至链表尾部</span>        deque<span class="token operator">-&gt;</span>rear<span class="token operator">-&gt;</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>        node<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> deque<span class="token operator">-&gt;</span>rear<span class="token punctuation">;</span>        deque<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    deque<span class="token operator">-&gt;</span>queSize<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 更新队列长度</span><span class="token punctuation">}</span><span class="token comment">/* 队首入队 */</span><span class="token keyword">void</span> <span class="token function">pushFirst</span><span class="token punctuation">(</span>LinkedListDeque <span class="token operator">*</span>deque<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">push</span><span class="token punctuation">(</span>deque<span class="token punctuation">,</span> num<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 队尾入队 */</span><span class="token keyword">void</span> <span class="token function">pushLast</span><span class="token punctuation">(</span>LinkedListDeque <span class="token operator">*</span>deque<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">push</span><span class="token punctuation">(</span>deque<span class="token punctuation">,</span> num<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 访问队首元素 */</span><span class="token keyword">int</span> <span class="token function">peekFirst</span><span class="token punctuation">(</span>LinkedListDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> deque<span class="token operator">-&gt;</span>front<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> deque<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 访问队尾元素 */</span><span class="token keyword">int</span> <span class="token function">peekLast</span><span class="token punctuation">(</span>LinkedListDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> deque<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> deque<span class="token operator">-&gt;</span>rear<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 出队 */</span><span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span>LinkedListDeque <span class="token operator">*</span>deque<span class="token punctuation">,</span> bool isFront<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">empty</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token comment">// 队首出队操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isFront<span class="token punctuation">)</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> <span class="token function">peekFirst</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 暂存头节点值</span>        DoublyListNode <span class="token operator">*</span>fNext <span class="token operator">=</span> deque<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fNext<span class="token punctuation">)</span> <span class="token punctuation">{</span>            fNext<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            deque<span class="token operator">-&gt;</span>front<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token function">delDoublyListNode</span><span class="token punctuation">(</span>deque<span class="token operator">-&gt;</span>front<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        deque<span class="token operator">-&gt;</span>front <span class="token operator">=</span> fNext<span class="token punctuation">;</span> <span class="token comment">// 更新头节点</span>    <span class="token punctuation">}</span>    <span class="token comment">// 队尾出队操作</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        val <span class="token operator">=</span> <span class="token function">peekLast</span><span class="token punctuation">(</span>deque<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 暂存尾节点值</span>        DoublyListNode <span class="token operator">*</span>rPrev <span class="token operator">=</span> deque<span class="token operator">-&gt;</span>rear<span class="token operator">-&gt;</span>prev<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rPrev<span class="token punctuation">)</span> <span class="token punctuation">{</span>            rPrev<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            deque<span class="token operator">-&gt;</span>rear<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token function">delDoublyListNode</span><span class="token punctuation">(</span>deque<span class="token operator">-&gt;</span>rear<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        deque<span class="token operator">-&gt;</span>rear <span class="token operator">=</span> rPrev<span class="token punctuation">;</span> <span class="token comment">// 更新尾节点</span>    <span class="token punctuation">}</span>    deque<span class="token operator">-&gt;</span>queSize<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// 更新队列长度</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 队首出队 */</span><span class="token keyword">int</span> <span class="token function">popFirst</span><span class="token punctuation">(</span>LinkedListDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">pop</span><span class="token punctuation">(</span>deque<span class="token punctuation">,</span> true<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 队尾出队 */</span><span class="token keyword">int</span> <span class="token function">popLast</span><span class="token punctuation">(</span>LinkedListDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">pop</span><span class="token punctuation">(</span>deque<span class="token punctuation">,</span> false<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 打印队列 */</span><span class="token keyword">void</span> <span class="token function">printLinkedListDeque</span><span class="token punctuation">(</span>LinkedListDeque <span class="token operator">*</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>arr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> deque<span class="token operator">-&gt;</span>queSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 拷贝链表中的数据到数组</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    DoublyListNode <span class="token operator">*</span>node<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> node <span class="token operator">=</span> deque<span class="token operator">-&gt;</span>front<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> deque<span class="token operator">-&gt;</span>queSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> node<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span>        node <span class="token operator">=</span> node<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> deque<span class="token operator">-&gt;</span>queSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp学习笔记（二）</title>
      <link href="/2023/12/12/cpp-xue-xi-bi-ji-er/"/>
      <url>/2023/12/12/cpp-xue-xi-bi-ji-er/</url>
      
        <content type="html"><![CDATA[<h3 id="2-类的基本实现"><a href="#2-类的基本实现" class="headerlink" title="2.类的基本实现"></a>2.类的基本实现</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①定义</strong></p><blockquote><p><strong>概述</strong>：<strong>类名</strong>相当于自定义的<strong>数据类型</strong>，可以创建对应的<strong>对象实例</strong>，每个类都有其<strong>成员函数</strong>用于操作其<strong>实例</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 操作符本质上也是一个函数，类可能会对操作符函数进行重写</div><p><strong>②基本框架</strong></p><blockquote><p><strong>概述</strong>：类的实现分为<strong>两部分</strong>，<strong>头文件</strong>给出类的<strong>定义</strong>并<strong>声明</strong>各种函数接口，<strong>程序代码文件</strong>包含这些<strong>函数的具体实现</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 类的头文件和程序代码文件名都和类名一致，只是后缀不同，以下为类的头文件框架</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其中的条件编译指令防止该头文件被多次包含</div><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">__COMPLEX__</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__COMPLEX__</span></span><span class="token comment">//类的前置声明</span><span class="token keyword">class</span> <span class="token punctuation">[</span>类名<span class="token punctuation">]</span><span class="token comment">//类的主体</span><span class="token keyword">class</span> <span class="token punctuation">[</span>类的名称<span class="token punctuation">]</span><span class="token punctuation">{</span>  <span class="token keyword">friend</span> <span class="token punctuation">[</span>函数声明<span class="token punctuation">]</span><span class="token operator">/</span><span class="token punctuation">[</span>类前置声明<span class="token punctuation">]</span>  <span class="token keyword">public</span><span class="token operator">:</span>      <span class="token comment">//公共接口，即成员函数的声明或者定义</span>  <span class="token keyword">private</span><span class="token operator">:</span>      <span class="token comment">//私有实现，通常是实现该类需要的数据，data member</span>  <span class="token keyword">protected</span><span class="token operator">:</span>      <span class="token comment">//通常存放需要继承给子类的数据和函数</span><span class="token punctuation">}</span><span class="token comment">//inline成员函数定义</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③访问权限</strong></p><blockquote><p><code>public</code>：通常存放<strong>成员函数</strong>的<strong>声明</strong>或<strong>定义</strong>，可以在<strong>程序的任何位置</strong>访问</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 类的实例对象可以通过.操作符访问类的成员，其指针通过-&gt;访问</div><blockquote><p><code>private</code>：通常存放<strong>实现该类</strong>需要的<strong>数据（data member）</strong>，只能被<strong>成员函数</strong>和<strong>friend类</strong>访问</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意对象实例在外界不能直接访问其private对象，需要通过特定成员函数获取或者在成员函数内访问</div><blockquote><p><code>protected</code>：处于该区域的成员能<strong>该类以及被其子类</strong>访问，<strong>外界与父类</strong>不能访问</p></blockquote><blockquote><p><code>friend</code>：类可以将<strong>某个类/函数</strong>指定为<code>friend</code>，在<strong>类主体</strong>中添加<code>friend</code>修饰的<strong>函数声明/类前置声明</strong>即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 指定为friend的函数/类的成员函数与该类成员函数具有相同的访问权限</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 将函数/类添加为某个类的friend时，在此之前需要有它们的前置声明</div><h4 id="2-2类的成员"><a href="#2-2类的成员" class="headerlink" title="2.2类的成员"></a>2.2类的成员</h4><p><strong>①成员函数</strong></p><blockquote><p><strong>声明</strong>：<strong>所有</strong>的<strong>成员函数</strong>都必须在<strong>类的主体内</strong>声明</p></blockquote><blockquote><p><strong>定义</strong>：若定义在<strong>类主体内</strong>，则默认为<strong>inline函数</strong>，若定义在<strong>类主体外</strong>，需要在<strong>函数名前</strong>添加<code>类名::</code>指明所属</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 定义在类主体外的函数，若需要声明为inline函数，则写在头文件中，反之写在程序文件中</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在成员函数中，this为一个指向调用者的指针，编译器会自动将其添加到参数列表的最左侧</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在成员函数中的data member，如果不指明其所属，则默认属于调用者</div><p><strong>②构造/析构函数</strong></p><blockquote><p><strong>构造函数</strong>：函数名<strong>和类的名称相同</strong>，且<strong>没有返回类型和返回值</strong>，可以<strong>被重载</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当类的实例被创建，编译器自动调用对应的构造函数，通常用于初始化类的实例</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 调用没有参数的构造函数，格式为[类名] [实例名];，若写为[类名] [实例名]();会被解读为一个返回对应类的函数</div><blockquote><p><strong>析构函数</strong>：函数名为<strong>类的名称前添加<code>~</code><strong>，没有</strong>返回类型和参数</strong>，故<strong>不能重载</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当类的实例结束生命时，编译器自动调用该函数进行一些清理工作，通常为释放类申请的动态内存</div><p><strong>③拷贝构造和赋值拷贝</strong></p><blockquote><p><strong>概述</strong>：<strong>缺省</strong>时，<strong>编译器</strong>提供以<strong>某个实例</strong>初始化实例的方法，如<code>Matrix my_mat1(my_mat2)</code>和<code>my_mat1 = my_mat2</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 编译器将类的data member一一复制，即将my_mat2的_row、_cal和_pmat赋值给将my_mat1的_row、_cal和_pmat</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 这种初始化方法并不适用于Matrix类，会导致两个实例的_pmat指向同一个二维数组</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以自定义赋值操作符和接收类实例的构造函数，以覆盖编译器的缺省行为</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 实现过程中，要检测自我赋值，如下执行m_data = new char[strlen(str.m_data)+1];时m_data已经被释放</div><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span><span class="token class-name">String</span><span class="token double-colon punctuation">::</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">const</span> String<span class="token operator">&amp;</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>    m_data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>m_data<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>m_data<span class="token punctuation">,</span>str<span class="token punctuation">.</span>m_data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> String<span class="token operator">&amp;</span> String<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> String<span class="token operator">&amp;</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token comment">//检测自我赋值</span>        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> m_data<span class="token punctuation">;</span>    m_data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>m_data<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>m_data<span class="token punctuation">,</span>str<span class="token punctuation">.</span>m_data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④成员初始化列表</strong></p><blockquote><p><strong>概述</strong>：<strong>构造函数</strong>的一种<strong>特殊语法</strong>，紧跟在<strong>参数列表后面</strong>，用于<strong>初始化data member</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个列表项由一data member组成，后跟由一对小括号包围的欲赋值给data member的数值，使用逗号隔开</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若data member为某类的实例，采用成员初始化列表对其进行初始化而不是再构造函数内进行赋值</div><blockquote><p><strong>成员初始化列表</strong>会调用该类的<strong>copy构造函数</strong>对其进行<strong>初始化</strong></p></blockquote><blockquote><p><strong>构造函数内</strong>的初始化，会<strong>先调用</strong>该类的<strong>缺省构造函数</strong>，再调用<strong>该类的赋值运算符函数</strong></p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">Matrix</span><span class="token double-colon punctuation">::</span><span class="token function">Matrix</span><span class="token punctuation">(</span><span class="token keyword">int</span> row<span class="token punctuation">,</span><span class="token keyword">int</span> col<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_row</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">_col</span><span class="token punctuation">(</span>col<span class="token punctuation">)</span><span class="token punctuation">{</span>  _pmat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">(</span>row<span class="token operator">*</span>col<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>⑤可变与不变</strong></p><blockquote><p><strong>概述</strong>：如果一个<strong>成员函数</strong>接收一个<code>const</code><strong>参数</strong>，则其<strong>声明和定义</strong>处都需要添加<code>const</code><strong>关键词</strong>声明</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> const关键词紧跟在函数的参数列表后，编译器会检查声明为const的函数是否会改变类对象的data member</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> const成员函数如果返回的是data member的引用，则返回类型也需要被const修饰</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以提供一个函数的const版本和非const版本，若传入的是const对象，则调用const版本，反之调用非const版本</div><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">row</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> _row<span class="token punctuation">}</span><span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">row</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> _row<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><code>mutable</code>：用以修饰<strong>data member</strong>，表示修改该<strong>data member</strong>不会影响<strong>对象实例</strong>的<strong>常量性</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一个被声明为const的成员函数可以修改以mutable修饰的data member</div><p><strong>⑥静态成员</strong></p><blockquote><p><strong>静态data member</strong>：当<strong>data member</strong>被<code>static</code>修饰，其成为<strong>唯一的共享数据</strong>，<strong>所有该类实例对象</strong>都可以访问</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要在程序文件中提供该data member的定义，并且名称前面需要添加[类名]::指明其所属</div><blockquote><p><strong>静态成员函数</strong>：当一个成员函数<strong>不访问</strong>任何<strong>非静态data member</strong>，可以在<strong>函数声明前</strong>添加<code>static</code>关键词</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 静态成员函数不需要依赖类的对象实例调用，只需要在其前面添加[类名]::即可调用</div><h4 id="2-3操作符重载"><a href="#2-3操作符重载" class="headerlink" title="2.3操作符重载"></a>2.3操作符重载</h4><p><strong>①定义</strong></p><blockquote><p><strong>概述</strong>：重新定义<strong>操作符函数</strong>，<strong>函数名称</strong>为<code>operator[操作符]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不能修改操作符函数的操作数和优先级，除了.、.*、::、?:，其余操作符均可被重载</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若为二元操作符，操作符的左操作数作为第一个参数传递给操作符函数，右操作数作为第二参数传递给操作符函数</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 参数列表必须至少有一个class类型参数</div><p><strong>②成员/非成员函数</strong></p><blockquote><p><strong>概述</strong>：<strong>操作符重载函数</strong>可以为一<strong>成员函数</strong>，也可为一<strong>非成员函数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若为成员函数，其第一个参数为*this指针，表示其左操作数一定是所属类，而非成员函数可以随意设置顺序</div><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//成员函数版本定义</span><span class="token keyword">inline</span> <span class="token keyword">int</span> iterator_to_special_vector<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> special_vector<span class="token double-colon punctuation">::</span>_elem<span class="token punctuation">[</span>_index<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment">//非成员函数版本定义 需要将其声明为对应类的friend，该函数才能访问_elem和_index</span><span class="token keyword">inline</span> <span class="token keyword">int</span><span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span>  special_vector<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> special_vector<span class="token double-colon punctuation">::</span>_elem<span class="token punctuation">[</span>_index<span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③前/后置版本</strong></p><blockquote><p><strong>概述</strong>：有些运算符还分为<strong>前置版本</strong>和<strong>后置版本</strong>，如<strong>递增/减</strong>运算符，规定<strong>后置版本</strong>的参数列表多出一个<code>int</code><strong>参数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 编译器会自动传递0给后置版本操作符函数的int参数</div><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//前置版本</span><span class="token keyword">inline</span> my_iterator<span class="token operator">&amp;</span> myiterator<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//具体实现</span><span class="token punctuation">}</span><span class="token comment">//后置版本</span><span class="token keyword">inline</span> my_iterator<span class="token operator">&amp;</span> myiterator<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//具体实现</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④iostream运算符重载</strong></p><blockquote><p><strong>概述</strong>：<code>&gt;&gt;</code><strong>运算符</strong>的实现较为复杂，还需要判断<strong>读取数据</strong>是否有问题，这里不考虑这些问题</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ostream对象不能声明为const，因为每次输出都会改变该对象状态</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> &lt;&lt;运算符重载函数不能为一个成员函数，否则类必须要放在&lt;&lt;左边</div><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ostream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span><span class="token keyword">const</span> special_vec<span class="token operator">&amp;</span> vec<span class="token punctuation">)</span><span class="token punctuation">{</span>  os<span class="token operator">&lt;&lt;</span><span class="token string">"("</span><span class="token operator">&lt;&lt;</span>vec<span class="token punctuation">.</span>_begin_pos<span class="token operator">&lt;&lt;</span><span class="token string">","</span><span class="token operator">&lt;&lt;</span>vec<span class="token punctuation">.</span>_len<span class="token operator">&lt;&lt;</span><span class="token string">")"</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>vec<span class="token punctuation">.</span>_len<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    os<span class="token operator">&lt;&lt;</span>vec<span class="token punctuation">.</span>_elems<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token generic-function"><span class="token function">os</span><span class="token generic class-name"><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token keyword">return</span> os<span class="token punctuation">;</span><span class="token punctuation">}</span>istream<span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span>istream <span class="token operator">&amp;</span>is<span class="token punctuation">,</span>special_vector <span class="token operator">&amp;</span>vec<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">char</span> ch1<span class="token punctuation">,</span>ch2<span class="token punctuation">;</span>  <span class="token keyword">int</span> bp<span class="token punctuation">,</span>len<span class="token punctuation">;</span>  is<span class="token operator">&gt;&gt;</span>ch1<span class="token operator">&gt;&gt;</span>bp<span class="token operator">&gt;&gt;</span>ch2<span class="token operator">&gt;&gt;</span>len<span class="token punctuation">;</span>  vec<span class="token punctuation">.</span>_begin_pos <span class="token operator">=</span> bp<span class="token punctuation">;</span>  vec<span class="token punctuation">.</span>_len <span class="token operator">=</span> len<span class="token punctuation">;</span>  <span class="token keyword">return</span> is<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-面向对象的编程风格"><a href="#3-面向对象的编程风格" class="headerlink" title="3.面向对象的编程风格"></a>3.面向对象的编程风格</h3><h4 id="3-1引言"><a href="#3-1引言" class="headerlink" title="3.1引言"></a>3.1引言</h4><p><strong>①三大特性</strong></p><blockquote><p><strong>封装</strong>：将<strong>实现细节</strong>部分<strong>包装</strong>、<strong>隐藏</strong>起来，也就是<strong>上述的类</strong></p></blockquote><blockquote><p><strong>继承</strong>：将一系列<strong>相关的类</strong>通过<strong>父子关系</strong>联系到一起，<strong>父类</strong>定义了<strong>子类</strong>的<strong>通用接口和数据</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如图书馆作为一个类，其子类有书，书又有其子类纸质书和电子书</div><blockquote><p><strong>多态</strong>：每个子类都可以<strong>增加自己的接口和数据</strong>，或者<strong>覆盖继承而来的接口和数据</strong>，以实现<strong>自己的行为</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若子类和父类中成员若一致，则子类成员会覆盖掉从父类继承的成员</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若要覆盖继承的成员函数，则子类中对应函数的参数列表、返回类型和常量性必须与之一致</div><blockquote><p>若需要在<strong>子类成员函数</strong>调用<strong>被覆盖的父类函数</strong>，则需要使用<code>[父类名]::</code>对其加以限定</p></blockquote><p><strong>②抽象基类</strong></p><blockquote><p><strong>概述</strong>：继承关系呈现<strong>树型</strong>，处于<strong>根节点</strong>的类称为<strong>抽象基类</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 基类的指针或者引用可以指向任何一个子类的对象</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用抽象基类的指针或引用间接操作子类的对象实例，从而在不改变旧有程序的前提下，新增/删除子类</div><blockquote><p>如下，函数的<strong>形参</strong>为<strong>抽象基类</strong>，但是<strong>实际调用</strong>时可以传递<strong>任何子类</strong></p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">loan_check_in</span> <span class="token punctuation">(</span>Lib<span class="token operator">&amp;</span> my_Lib<span class="token punctuation">)</span><span class="token punctuation">{</span>  my_Lib<span class="token punctuation">.</span><span class="token function">check_in</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//程序具体实现</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③动态绑定</strong></p><blockquote><p><strong>概述</strong>：如上，<code>my_Lib.check_in()</code>到<strong>执行时</strong>才根据<strong>实际传入的对象类型</strong>调用对应的函数<code>check_in()</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只有虚函数才具有动态绑定的特性，普通函数在编译时就根据my_Lib类型确定执行哪个check_in()</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若调用的函数不为虚函数，即使传入的是其他子类实例，还是调用对应父类的成员函数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以明确指出该函数属于那一类，调用时添加[类名]::前缀即可，以遮掩虚函数机制</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 在父类的构造函数和析构函数中，不会调用子类的虚函数，因为此时派生类可能还没有初始化好</div><h4 id="3-2实现"><a href="#3-2实现" class="headerlink" title="3.2实现"></a>3.2实现</h4><p><strong>①框架</strong></p><blockquote><p><strong>概述</strong>：定义了<strong>父类</strong><code>Lib</code>和<strong>子类</strong><code>Book</code>，其中<strong>子类的前置声明后</strong>接<code>:[继承类型][父类名]</code>，表示其<strong>继承自某类</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 子类的头文件需要包含父类的头文件，继承方式有多种，这里只介绍public继承</div><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Lib</span><span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">Lib</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"Create a Lib class!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Lib</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"Release a Lib class!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">//Lib类的print函数</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"I am a Lib class!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span><span class="token operator">:</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Lib.h"</span></span><span class="token keyword">class</span> <span class="token class-name">Book</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Lib</span></span><span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">Book</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> author<span class="token punctuation">,</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> title<span class="token punctuation">)</span>  <span class="token operator">:</span><span class="token function">_title</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">_author</span><span class="token punctuation">(</span>author<span class="token punctuation">)</span>  <span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"Create a Book class!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Book</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"Release a Book class!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">//Book类的print函数，覆盖了从父类继承来的print()</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"I am a Book class!"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"My title is"</span><span class="token operator">&lt;&lt;</span>_title<span class="token operator">&lt;&lt;</span><span class="token string">"!"</span>endl<span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"My author is"</span><span class="token operator">&lt;&lt;</span>_author<span class="token operator">&lt;&lt;</span><span class="token string">"!"</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">protected</span><span class="token operator">:</span>  string _title<span class="token punctuation">,</span>_author<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②虚函数</strong></p><blockquote><p><code>virtual</code>：修饰一个<strong>成员函数</strong>使其成为<strong>虚函数</strong>，从而实现<strong>动态绑定</strong>，若其被<strong>赋值</strong>为<code>0</code>，则为<strong>纯虚函数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若不同子类对某函数有不同的实现，则将其声明虚函数，静态成员函数无法被声明为虚函数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 子类若覆盖从父类继承的虚函数，不必添加virtual关键字修饰，其自动成为虚函数</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若父类中有虚函数，则其析构函数也需要被声明为虚函数</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 成员函数中有纯虚函数的类无法创建对象实例，因为其接口不完整</div><p><strong>③构造与析构</strong></p><blockquote><p><strong>构造</strong>：当一个<strong>子类</strong>被定义，<strong>首先</strong>会<strong>自顶向下</strong>调用其<strong>父类</strong>的构造函数，随后再调用<strong>本身</strong>构造函数</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 即定义子类实例时，不仅仅创建了子类对象，还递归的创建了其所有父类对象</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若基类中有data member，则最好在其构造函数中将其初始化，即子类的构造函数还需要调用基类的构造函数</div><blockquote><p>若没有<strong>显式调用</strong>，则编译器会<strong>自动</strong>调用父类的<strong>缺省构造函数</strong></p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token class-name">Book</span><span class="token double-colon punctuation">::</span><span class="token function">Book</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> title<span class="token punctuation">,</span>string<span class="token operator">&amp;</span> author<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">Lib</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">_title</span><span class="token punctuation">(</span>title<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">_author</span><span class="token punctuation">(</span>author<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>析构</strong>：当一个<strong>子类</strong>生命周期中介，<strong>首先</strong>调用<strong>本身析构函数</strong>，随后再<strong>自底向上</strong>调用其<strong>父类的析构函数</strong></p></blockquote><p><strong>④运行时类型鉴定</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要包含typeinfo头文件</div><blockquote><p><code>typeid()</code>：接收一个<strong>类实例/类名</strong>，如<code>typeid(*this)</code>，返回一个<code>type_info</code><strong>对象</strong>，包含了该实例的<strong>类相关信息</strong></p></blockquote><blockquote><p><code>name()</code>：返回<code>type_info</code><strong>对象</strong>中的<strong>名字信息</strong>，如<code>typeid(*this).name()</code></p></blockquote><blockquote><p><code>static_cast&lt;class_type&gt;()</code>：接收<strong>一个指针</strong>，强制将其转化为<strong>指向<code>class_type</code>的指针</strong></p></blockquote><blockquote><p><code>dynamic_cast&lt;class_type&gt;()</code>：接收<strong>一个指针</strong>，若其指向<code>class_type</code>，则将其转化为<strong>指向<code>class_type</code>的指针</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若使用指针调用成员函数，则其为指向什么类的指针，就只能调用对应类的成员函数，即使有虚函数机制</div><blockquote><p>如下，<code>p_to_lib</code>为<code>Lib*</code>类的指针，虽然指向<code>Book</code><strong>实例</strong>，但是还是<strong>只能调用</strong><code>Lib</code>类的<strong>成员函数</strong></p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Book a_book<span class="token punctuation">;</span>Lib<span class="token operator">*</span> p_to_lib <span class="token operator">=</span> <span class="token operator">&amp;</span>a_book<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-3模板类"><a href="#3-3模板类" class="headerlink" title="3.3模板类"></a>3.3模板类</h4><p><strong>①模板template</strong></p><blockquote><p><strong>格式</strong>：在<strong>类前</strong>添加<code>template</code><strong>参数列表</strong>，其中<code>typename</code>为<strong>关键字</strong>，后接一<strong>占位符</strong>，可以有<strong>多对</strong>，用<strong>逗号</strong>隔开</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该占位符相当于参数类型，可以出现在任何参数类型可以出现的地方，编译器将占位符替换为创建类时传递的参数</div><blockquote><p><strong>调用</strong>：在<strong>类名后</strong>接<code>&lt;[类型参数]&gt;</code>传递<strong>类型参数</strong>，如<code>Node_to_tree&lt;int&gt; root;</code>，会将<code>val_type</code><strong>全部替换</strong>为<code>int</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 除了在类主体以及其成员函数定义中，其他地方调用该类都需要使用template参数列表加以限制</div><p><strong>②例子</strong></p><blockquote><p><strong>概述</strong>：利用<strong>模板</strong>实现<strong>节点类</strong>和一个<strong>二叉树类</strong>，两者互为<code>firend</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中二叉树类是节点类的friend，因为其要访问节点类的数据</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意两者的friend声明，都必须以template参数列表加以限制，且列表中采用的是本身的占位符</div><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//二叉树类的前置声明</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Node_type</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Binary_tree</span><span class="token punctuation">;</span><span class="token comment">//节点类的定义</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">val_type</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Node_to_tree</span><span class="token punctuation">{</span>  <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">Binary_tree</span><span class="token operator">&lt;</span>val_type<span class="token operator">&gt;</span>  <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">private</span><span class="token operator">:</span>  val_type _val<span class="token punctuation">;</span>  <span class="token keyword">int</span> _cnt<span class="token punctuation">;</span>  Node_to_tree<span class="token operator">*</span> _lchild<span class="token punctuation">;</span>  Node_to_tree<span class="token operator">*</span> _rchild<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//二叉树类的定义</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Node_type</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Binary_tree</span><span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">Binary_tree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">Binary_tree</span><span class="token punctuation">(</span><span class="token keyword">const</span> Binary_tree<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">~</span><span class="token function">Binary_tree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Binary_tree<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Binary_tree<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span><span class="token operator">:</span>  Node_to_tree<span class="token operator">&lt;</span>Node_type<span class="token operator">&gt;</span><span class="token operator">*</span> _root<span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>Node_to_tree<span class="token operator">&lt;</span>Node_type<span class="token operator">&gt;</span><span class="token operator">*</span> tar<span class="token punctuation">,</span>Node_to_tree<span class="token operator">&lt;</span>Node_type<span class="token operator">&gt;</span><span class="token operator">*</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③成员函数定义</strong></p><blockquote><p><strong>概述</strong>：与<strong>普通类</strong>不同，<strong>开头</strong>需要添加<code>template</code><strong>参数列表</strong>，且<strong>类限定符</strong>也需要<code>template</code><strong>列表</strong>加以限定</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在类限定符，即Binary_tree<node_type>::后的语句，都视为定义在Binary_tree类中</node_type></div><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Node_type</span><span class="token operator">&gt;</span><span class="token keyword">inline</span> <span class="token class-name">Binary_tree</span><span class="token operator">&lt;</span>Node_type<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Binary_tree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_root</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 《C++ primer》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix环境编程（上）</title>
      <link href="/2023/12/11/unix-huan-jing-bian-cheng-shang/"/>
      <url>/2023/12/11/unix-huan-jing-bian-cheng-shang/</url>
      
        <content type="html"><![CDATA[<h1 id="Unix环境编程"><a href="#Unix环境编程" class="headerlink" title="Unix环境编程"></a>Unix环境编程</h1><h2 id="Unix环境编程（上）"><a href="#Unix环境编程（上）" class="headerlink" title="Unix环境编程（上）"></a>Unix环境编程（上）</h2><h3 id="1-Unix系统简介"><a href="#1-Unix系统简介" class="headerlink" title="1.Unix系统简介"></a>1.Unix系统简介</h3><h4 id="1-1引言"><a href="#1-1引言" class="headerlink" title="1.1引言"></a>1.1引言</h4><p><strong>①定义</strong></p><blockquote><p><strong>概述</strong>：一种<strong>多用户、多进程</strong>的计算机操作系统，由<strong>贝尔实验室</strong>开发，目前已经渐渐成为<strong>一种标准</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 常见的类Unxi系统有Linux、MacOS和BSD等</div><p><strong>②相关标准</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> L</div><blockquote><p><strong>ISO C</strong>：由<strong>ISO/IEC</strong>维护和开发，规定了<strong>C语言</strong>的<strong>语义</strong>和<strong>语法</strong>，并定义了其<strong>标准库</strong>，以提供C语言的<strong>可移植性</strong></p></blockquote><blockquote><p><strong>POSIX</strong>：由<strong>IEEE</strong>制定，<strong>符合该规定的操作系统</strong>必须包含的一系列<strong>操作系统接口</strong>，以及一些<strong>可选接口</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> XSI描述了哪些可选接口是Unix系统必须支持的</div><blockquote><p><strong>SUS</strong>：在<strong>POSIX标准</strong>基础上，定义了一些<strong>附加接口</strong></p></blockquote><h4 id="1-2限制"><a href="#1-2限制" class="headerlink" title="1.2限制"></a>1.2限制</h4><p><strong>①定义</strong></p><blockquote><p><strong>概述</strong>：<strong>Unix系统实现</strong>定义了很多<strong>幻数</strong>和<strong>常量</strong>用于限制其行为，可分为<strong>编译时限制</strong>和<strong>运行时限制</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不同的标准定义了不同的限制，其中可能会有冲突，通常取较为合理的一种</div><blockquote><p>如<strong>ISO C标准</strong>定义了<code>FILENAME_MAX</code>，但是推荐使用<strong>POSIX标准</strong>定义的<code>NAME_MAX</code>和<code>PATH_MAX</code></p></blockquote><p><strong>②获取</strong></p><blockquote><p><strong>编译时限制</strong>：通常是<strong>固定</strong>的，定义在<strong>头文件</strong>中，如<strong>短整型的最大值</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以上三种标准的编译时限制大部分定义在limits.h头文件中，其余头文件也包含少许相关限制</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 有些编译时限定只限制了其最小值，而实际可能根据系统等采用不同的值</div><blockquote><p>如<strong>POSIX标准</strong>的<strong>信号量最大值</strong>，在<code>limits.h</code>中有_<code>POSIX_SEM_VALUE_MAX</code>和<code>SEM_VALUE_MAX</code>，后者为<strong>实际值</strong></p></blockquote><blockquote><p><strong>运行时限制</strong>：通常是<strong>动态</strong>的，需要进程<strong>运行时</strong>调用一个<strong>函数</strong>获得，如<strong>文件名最大字符数</strong>，由<strong>文件系统</strong>决定</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 运行时限制分为与文件和目录相关/无关两种，前者通过函数pathconf和pathconf获取，后者通过函数sysconf获取</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 有些限制值是不确定的，在这种情况下，需要自定义某个值顶替</div>                                                                                                                            <link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 工具链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《Unix环境高级编程》 </tag>
            
            <tag> Unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性结构（上）</title>
      <link href="/2023/12/10/xian-xing-jie-gou-shang/"/>
      <url>/2023/12/10/xian-xing-jie-gou-shang/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1数组和链表"><a href="#1-1数组和链表" class="headerlink" title="1.1数组和链表"></a>1.1数组和链表</h4><p><strong>①数组</strong></p><blockquote><p><strong>概述</strong>：一段<strong>连续的内存空间</strong>，其<strong>数组名</strong>记录了其<strong>起始位置</strong>，可以通过<strong>索引</strong>访问<strong>对应位置</strong>的内存单元</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 数组的大小通常是一开始就确定的，但也可以通过一些手段构成动态数组，如C语言的malloc()以及C++的vector</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 数组的元素访问非常块，元素地址=起始地址+元素长度x元素索引，且由于其是连续存放，所以对缓存的利用率较高</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 由于数组是一段连续的内存空间，所以是有限的，可能会出现扩容问题，且修改一个元素会影响其后所有元素</div><p><strong>②链表</strong></p><blockquote><p><strong>概述</strong>：多个<strong>零星的内存空间</strong>通过<strong>指针</strong>链接在一起，每个链表有一个<strong>头节点</strong>，记录链表<strong>起始位置</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 根据各个节点的链接关系，链表可分为单链表、双向链表和环形链表</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 链表分散于内存各处，更加灵活，内存允许的情况下可以无限增长，且移动一个节点只会影响与其相连的节点</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 链表需要存储指针信息，需要占用更多的内存，且查询节点需要使用指针，速度较慢</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_1.png" alt="数组与链表"></p><h4 id="1-2抽象"><a href="#1-2抽象" class="headerlink" title="1.2抽象"></a>1.2抽象</h4><p><strong>①定义</strong></p><blockquote><p><strong>概述</strong>：只关心<strong>是什么</strong>，而不关心<strong>如何做到</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 数据结构的抽象就是描述其定义及其操作集</div><p><strong>②常用线性结构</strong></p><blockquote><p><strong>线性表</strong>：<strong>零个或多个</strong>数据元素的<strong>有限序列</strong>，<strong>每个元素</strong>只有<strong>一个直接前驱元素</strong>，<strong>一个直接后继元素</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 线性表的元素可以是任何结构，如线性表，但是线性表存储的元素必须统一</div><blockquote><p><strong>栈</strong>：受到<strong>一定约束</strong>的<strong>线性表</strong>，只能在<strong>一端插入和弹出</strong>数据，<strong>后入先出</strong></p></blockquote><blockquote><p><strong>队列</strong>：受到<strong>一定约束</strong>的<strong>线性表</strong>，只能在<strong>一端插入</strong>，在<strong>另一端删除</strong>，<strong>先进先出</strong></p></blockquote><p><strong>③操作集</strong></p><blockquote><p><strong>概述</strong>：每个<strong>数据结构</strong>的<strong>操作集</strong>都只需要包含一些<strong>基本且独立</strong>的操作</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 任何复杂操作，都可以转化为操作集的组合</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 每个操作的实现都要考虑不合理情况并抛出异常，以及操作带来的副作用</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_2.png" alt="线性结构"></p><h4 id="1-3动态数组"><a href="#1-3动态数组" class="headerlink" title="1.3动态数组"></a>1.3动态数组</h4><p><strong>①结构代码</strong></p><blockquote><p><strong>概述</strong>：当数组<strong>大小超过其容量</strong>时，<strong>释放</strong>原来的空间，并<strong>申请</strong>一块<strong>新的更大的空间</strong></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 列表类 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>arr<span class="token punctuation">;</span>        <span class="token comment">// 数组（存储列表元素）</span>    <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token comment">// 列表容量</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>        <span class="token comment">// 列表大小</span>    <span class="token keyword">int</span> extendRatio<span class="token punctuation">;</span> <span class="token comment">// 列表每次扩容的倍数</span><span class="token punctuation">}</span> MyList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②构造与析构</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 由于动态数组的特性，其数组需为动态申请而来</div><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 构造函数 */</span>MyList <span class="token operator">*</span><span class="token function">newMyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    MyList <span class="token operator">*</span>nums <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>MyList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    nums<span class="token operator">-&gt;</span>capacity <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    nums<span class="token operator">-&gt;</span>arr <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> nums<span class="token operator">-&gt;</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    nums<span class="token operator">-&gt;</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    nums<span class="token operator">-&gt;</span>extendRatio <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> nums<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 析构函数 */</span><span class="token keyword">void</span> <span class="token function">delMyList</span><span class="token punctuation">(</span>MyList <span class="token operator">*</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">free</span><span class="token punctuation">(</span>nums<span class="token operator">-&gt;</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③扩容操作</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 列表扩容 */</span><span class="token keyword">void</span> <span class="token function">extendCapacity</span><span class="token punctuation">(</span>MyList <span class="token operator">*</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 先分配空间</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> <span class="token function">capacity</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">*</span> nums<span class="token operator">-&gt;</span>extendRatio<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>extend <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>temp <span class="token operator">=</span> nums<span class="token operator">-&gt;</span>arr<span class="token punctuation">;</span>    <span class="token comment">// 拷贝旧数据到新数据</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        extend<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token operator">-&gt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 释放旧数据</span>    <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 更新新数据</span>    nums<span class="token operator">-&gt;</span>arr <span class="token operator">=</span> extend<span class="token punctuation">;</span>    nums<span class="token operator">-&gt;</span>capacity <span class="token operator">=</span> newCapacity<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③操作集</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 增加元素可分为在尾部添加和在中间插入</div><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 访问元素 */</span><span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span>MyList <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;</span> nums<span class="token operator">-&gt;</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> nums<span class="token operator">-&gt;</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 在尾部添加元素 */</span><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>MyList <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">capacity</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">extendCapacity</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 扩容</span>    <span class="token punctuation">}</span>    nums<span class="token operator">-&gt;</span>arr<span class="token punctuation">[</span><span class="token function">size</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>    nums<span class="token operator">-&gt;</span>size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 在中间插入元素 */</span><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>MyList <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 元素数量超出容量时，触发扩容机制</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">capacity</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">extendCapacity</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 扩容</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">size</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> index<span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums<span class="token operator">-&gt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token operator">-&gt;</span>arr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    nums<span class="token operator">-&gt;</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>    nums<span class="token operator">-&gt;</span>size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 删除元素 */</span><span class="token comment">// 注意：stdio.h 占用了 remove 关键词</span><span class="token keyword">int</span> <span class="token function">removeItem</span><span class="token punctuation">(</span>MyList <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> index <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num <span class="token operator">=</span> nums<span class="token operator">-&gt;</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums<span class="token operator">-&gt;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token operator">-&gt;</span>arr<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    nums<span class="token operator">-&gt;</span>size<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2.线性表"></a>2.线性表</h3><h4 id="2-1数组实现"><a href="#2-1数组实现" class="headerlink" title="2.1数组实现"></a>2.1数组实现</h4><p><strong>①结构代码</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通过typedef达到类似于Cpp模板的效果</div><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXSIZE</span> <span class="token expression"><span class="token number">30</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> ElemType<span class="token punctuation">;</span> <span class="token comment">//如果要修改线性表的数据类型，直接修改这里即可</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>  ElemType data<span class="token punctuation">[</span>MAXSIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> length<span class="token punctuation">;</span> <span class="token comment">//线性表目前的长度</span><span class="token punctuation">}</span>SqList<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②操作集实现</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 删除元素需要后移数组元素，从尾端开始</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 需要判断操作位置是否合理，以及该操作带来的副作用</div><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">OK</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ERROR</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> Status<span class="token punctuation">;</span><span class="token comment">/*查找元素*/</span>Status <span class="token function">GetElem</span><span class="token punctuation">(</span>SqList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">||</span>i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token operator">||</span>i <span class="token operator">&gt;</span> L<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">//首先进行异常判断</span>    <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>  <span class="token operator">*</span>e <span class="token operator">=</span> L<span class="token punctuation">.</span>data<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*插入元素*/</span>Status <span class="token function">ListInsert</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType e<span class="token punctuation">)</span> <span class="token comment">//注意这里传入的是结构的指针，因为要改变结构</span><span class="token punctuation">{</span>  <span class="token comment">//首先进行异常检查</span>  <span class="token keyword">int</span> k<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-&gt;</span>lenth<span class="token operator">==</span>MAXSIZE<span class="token punctuation">)</span>    <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token operator">||</span>i <span class="token operator">&gt;</span> L<span class="token operator">-&gt;</span>lenth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//注意i的含义对代码的影响</span>    <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>  <span class="token comment">//考虑插入位置对操作的影响</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>L<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span>L<span class="token operator">-&gt;</span>length<span class="token punctuation">;</span>k<span class="token operator">&gt;=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token comment">//后移元素</span>      L<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>L<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  L<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span>  L<span class="token operator">-&gt;</span>length<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//注意操作带来的额外影响</span>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*删除元素*/</span>Status <span class="token function">ListDelete</span><span class="token punctuation">(</span>SqList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> k<span class="token punctuation">;</span>  <span class="token comment">//异常检查</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>L<span class="token operator">-&gt;</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token operator">||</span>i <span class="token operator">&gt;</span> L<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span>    <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>  <span class="token comment">//当删除位置不在线性表末尾时</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> L<span class="token operator">-&gt;</span>length<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>k <span class="token operator">=</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>k <span class="token operator">&lt;</span> L<span class="token operator">-</span>length<span class="token punctuation">,</span>k<span class="token operator">++</span><span class="token punctuation">)</span>      L<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> L<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  L<span class="token operator">-&gt;</span>length<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//函数操作带来的额外影响</span>  <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2链表实现"><a href="#2-2链表实现" class="headerlink" title="2.2链表实现"></a>2.2链表实现</h4><p><strong>①结构代码</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 链表由节点组成，且链接关系也存储在节点中，所以指明了节点的结构就是指明了链表的结构</div><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//单链表节点结构</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>  ElemType data<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span>Node<span class="token punctuation">;</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token operator">*</span>LinkList<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②构造与析构</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 链表是一种动态结构，创建其头节点即可，同样也可以创建新的节点</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 创建一个节点指针指向当前节点的下一节点，作为哨兵，提示是否到达末尾</div><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 构造函数 */</span>Node <span class="token operator">*</span><span class="token function">newListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node <span class="token operator">*</span>node<span class="token punctuation">;</span>    node <span class="token operator">=</span> <span class="token punctuation">(</span>Node <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token operator">-&gt;</span>data <span class="token operator">=</span> val<span class="token punctuation">;</span>    node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*析构函数*/</span>Status <span class="token function">LinkClear</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token punctuation">{</span>  LinkList p<span class="token punctuation">,</span>q<span class="token punctuation">;</span>  p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    q <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>    p<span class="token operator">=</span>q  <span class="token punctuation">}</span>  <span class="token punctuation">(</span><span class="token operator">*</span>L<span class="token punctuation">)</span><span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③操作集</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 注意节点插入时，先将新节点插入，再将旧的链接断开</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 对于没有回收机制的语言，需要注意释放动态分配获得的内存</div><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*查找*/</span>Status <span class="token function">GetElem</span><span class="token punctuation">(</span>LinkList L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType <span class="token operator">*</span>e<span class="token punctuation">)</span> <span class="token comment">//传入L为链表的头节点的指针</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> j<span class="token punctuation">;</span>  LinkList p<span class="token punctuation">;</span>  p <span class="token operator">=</span> L<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span> <span class="token comment">//使p指向链表的第一个节点</span>  j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//其中p作为判别条件是防止其超过链表范围，因为当p为空指针时，说明已经到达最后一个节点了</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">)</span>   <span class="token punctuation">{</span>    p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token operator">++</span>j<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>p <span class="token operator">||</span> j <span class="token operator">&gt;</span> i<span class="token punctuation">)</span> <span class="token comment">//当p为空指针或者i小于1时，第i个元素不存在</span>    <span class="token keyword">return</span> ERROR<span class="token punctuation">;</span>  <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/*在已存在链表的第i个位置插入元素e*/</span>Status <span class="token function">ListInsert</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> j<span class="token punctuation">;</span>  LinkList p<span class="token punctuation">,</span>s<span class="token punctuation">;</span>  p <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span>  j <span class="token operator">=</span> <span class="token number">1</span>；  <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>i <span class="token punctuation">)</span> <span class="token comment">/*寻找第i个结点,循环结束时j = i-1；*/</span>  <span class="token punctuation">{</span>    p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token operator">++</span>j<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p <span class="token operator">||</span> j<span class="token operator">&gt;</span>i<span class="token punctuation">)</span> <span class="token comment">/*当i为0或者第i个结点不存在时*/</span>    <span class="token keyword">return</span> ERROR；  s <span class="token operator">=</span> <span class="token punctuation">(</span>LinkList<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  s<span class="token operator">-&gt;</span>data <span class="token operator">=</span> e<span class="token punctuation">;</span>  <span class="token comment">/*注意结点断开和相连的顺序*/</span>  s<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span><span class="token comment">/*先将新节点添加进链表*/</span>  p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> s<span class="token punctuation">;</span><span class="token comment">/*再将旧链接断开并添加新链接*/</span><span class="token punctuation">}</span><span class="token comment">/*删除节点*/</span>Status <span class="token function">LinkDelete</span><span class="token punctuation">(</span>LinkList <span class="token operator">*</span>L<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>ElemType <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> j<span class="token punctuation">;</span>  LinkList p<span class="token punctuation">,</span>q<span class="token punctuation">;</span>  p <span class="token operator">=</span> <span class="token operator">*</span>L<span class="token punctuation">;</span>  j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token operator">++</span>j<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p <span class="token operator">||</span> j<span class="token operator">&gt;</span>i<span class="token punctuation">)</span> <span class="token comment">//当i为0或者第i个结点不存在时</span>    <span class="token keyword">return</span> ERROR；  q <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>  p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> q<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>  <span class="token operator">*</span>e <span class="token operator">=</span> q<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>  <span class="token function">free</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//记得要释放对应的空间</span>  <span class="token keyword">return</span> OK<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3.栈"></a>3.栈</h3><h4 id="3-1数组实现"><a href="#3-1数组实现" class="headerlink" title="3.1数组实现"></a>3.1数组实现</h4><p><strong>①结构代码</strong></p><blockquote><p>由一个<strong>记录元素的一维数组</strong>和一个<strong>记录栈顶元素位置</strong>的<strong>变量</strong>组成</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以数组的尾部作为栈顶，便于操作</div><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MaxSize</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">SNode</span><span class="token operator">*</span> Stack<span class="token keyword">struct</span> <span class="token class-name">SNode</span><span class="token punctuation">{</span>  ElementType Data<span class="token punctuation">[</span>MaxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> Top <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②操作集实现</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 访问栈顶元素 */</span><span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span>Stack PtrS<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>PtrS<span class="token operator">-&gt;</span>Top<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"栈空"</span><span class="token punctuation">)</span>；    <span class="token keyword">return</span> ；  <span class="token punctuation">}</span>  <span class="token keyword">else</span>  <span class="token keyword">return</span><span class="token punctuation">(</span>PtrS<span class="token operator">-&gt;</span>Data<span class="token punctuation">[</span><span class="token punctuation">(</span>PtrS<span class="token operator">-&gt;</span>Top<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注意--符号是后缀</span><span class="token punctuation">}</span><span class="token comment">/* 压入元素 */</span><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Stack PtrS<span class="token punctuation">,</span>ElementType item<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>PtrS<span class="token operator">-&gt;</span>Top<span class="token operator">==</span>Maxsize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"栈已满"</span><span class="token punctuation">)</span>；    <span class="token keyword">return</span>；  <span class="token punctuation">}</span>  <span class="token keyword">else</span>  <span class="token punctuation">{</span>    PtrS<span class="token operator">-&gt;</span>Data<span class="token punctuation">[</span><span class="token operator">++</span><span class="token punctuation">(</span>PtrS<span class="token operator">-&gt;</span>Top<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">==</span>item<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/* 弹出栈顶元素 */</span>ElementType <span class="token function">pop</span><span class="token punctuation">(</span>Stack PtrS<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>PtrS<span class="token operator">-&gt;</span>Top<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"栈空"</span><span class="token punctuation">)</span>；    <span class="token keyword">return</span> ；  <span class="token punctuation">}</span>  <span class="token keyword">else</span>  <span class="token keyword">return</span><span class="token punctuation">(</span>PtrS<span class="token operator">-&gt;</span>Data<span class="token punctuation">[</span><span class="token punctuation">(</span>PtrS<span class="token operator">-&gt;</span>Top<span class="token punctuation">)</span><span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注意--符号是后缀</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2链表实现"><a href="#3-2链表实现" class="headerlink" title="3.2链表实现"></a>3.2链表实现</h4><p><strong>①结构代码</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以链表的头节点作为栈顶，便于操作</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 栈只需要能找到链表的头节点即可，还可保存一些全局信息</div><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 基于链表实现的栈 */</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    ListNode <span class="token operator">*</span>top<span class="token punctuation">;</span> <span class="token comment">// 将头节点作为栈顶</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>      <span class="token comment">// 栈的长度</span><span class="token punctuation">}</span> LinkedListStack<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②构造与析构</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 构造函数 */</span>LinkedListStack <span class="token operator">*</span><span class="token function">newLinkedListStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LinkedListStack <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>LinkedListStack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token operator">-&gt;</span>top <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    s<span class="token operator">-&gt;</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 析构函数 */</span><span class="token keyword">void</span> <span class="token function">delLinkedListStack</span><span class="token punctuation">(</span>LinkedListStack <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>top<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode <span class="token operator">*</span>n <span class="token operator">=</span> s<span class="token operator">-&gt;</span>top<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>        <span class="token function">free</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>top<span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token operator">-&gt;</span>top <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">free</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③操作集实现</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 记住原来的栈顶节点，因为后续还需要释放</div><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 访问栈顶元素 */</span><span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span>LinkedListStack <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//保证栈一定存在</span>    <span class="token function">assert</span><span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>size <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> s<span class="token operator">-&gt;</span>top<span class="token operator">-&gt;</span>val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 压入元素 */</span><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>LinkedListStack <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode <span class="token operator">*</span>node <span class="token operator">=</span> <span class="token punctuation">(</span>ListNode <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> s<span class="token operator">-&gt;</span>top<span class="token punctuation">;</span> <span class="token comment">// 更新新加节点指针域</span>    node<span class="token operator">-&gt;</span>val <span class="token operator">=</span> num<span class="token punctuation">;</span>     <span class="token comment">// 更新新加节点数据域</span>    s<span class="token operator">-&gt;</span>top <span class="token operator">=</span> node<span class="token punctuation">;</span>       <span class="token comment">// 更新栈顶</span>    s<span class="token operator">-&gt;</span>size<span class="token operator">++</span><span class="token punctuation">;</span>           <span class="token comment">// 更新栈大小</span><span class="token punctuation">}</span><span class="token comment">/* 弹出栈顶元素 */</span><span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span>LinkedListStack <span class="token operator">*</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token operator">-&gt;</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"stack is empty.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> INT_MAX<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">assert</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    ListNode <span class="token operator">*</span>tmp <span class="token operator">=</span> s<span class="token operator">-&gt;</span>top<span class="token punctuation">;</span><span class="token comment">//记住原来的栈顶节点，因为后续还需要释放</span>    s<span class="token operator">-&gt;</span>top <span class="token operator">=</span> s<span class="token operator">-&gt;</span>top<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token comment">// 释放内存</span>    <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    s<span class="token operator">-&gt;</span>size<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统基础（上）</title>
      <link href="/2023/12/10/ji-suan-ji-xi-tong-ji-chu-shang/"/>
      <url>/2023/12/10/ji-suan-ji-xi-tong-ji-chu-shang/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机系统基础"><a href="#计算机系统基础" class="headerlink" title="计算机系统基础"></a>计算机系统基础</h1><h2 id="计算机系统基础（上）"><a href="#计算机系统基础（上）" class="headerlink" title="计算机系统基础（上）"></a>计算机系统基础（上）</h2><h3 id="1-程序的运行"><a href="#1-程序的运行" class="headerlink" title="1.程序的运行"></a>1.程序的运行</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h4><p>编译 将高级语言源程序转化为机器级目标程序，执行时启动目标程序即可<br>编译工具链 预处理 编译 汇编 连接<br>解释器<br>解释 将高级语言语句逐条翻译为机器指令并立即执行，不产生目标文件</p><p>ISA指令系统是最重要的一层，一种如何使用硬件的约定，没有ISA无法使用硬件<br>指令格式 操作种类以及各个规定 操作数的类型、存储器的规格和用途等<br>存储空间大小 编址方式<br>寻址方式<br>控制方式<br>打断存放还是小端存放<br>ARM X86<br>计算机必须实现ISA规定的功能，但是实现方式可以不同</p><p>字长指数据通路的宽度，常常和总线宽度、通用寄存器宽度相等<br>字 表示被处理信息的单位，用于度量数据类型<br>如对于x86结构，字始终是16位，但是字长逐渐增长到64位</p><p>K 2^10 k 10^3 B字节 b比特</p><p>字 16位<br>字长 通用寄存器的宽度</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 计算机系统基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（上）</title>
      <link href="/2023/12/10/ji-suan-ji-zu-cheng-yuan-li-shang/"/>
      <url>/2023/12/10/ji-suan-ji-zu-cheng-yuan-li-shang/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理（上）"><a href="#计算机组成原理（上）" class="headerlink" title="计算机组成原理（上）"></a>计算机组成原理（上）</h1><h2 id="计算机组成原理启蒙"><a href="#计算机组成原理启蒙" class="headerlink" title="计算机组成原理启蒙"></a>计算机组成原理启蒙</h2><h3 id="1-计算机基本组成"><a href="#1-计算机基本组成" class="headerlink" title="1.计算机基本组成"></a>1.计算机基本组成</h3><h4 id="1-1冯诺依曼结构"><a href="#1-1冯诺依曼结构" class="headerlink" title="1.1冯诺依曼结构"></a>1.1冯诺依曼结构</h4><p><strong>①特点</strong></p><blockquote><p>计算机由<strong>运算器</strong>、<strong>控制器</strong>、<strong>存储器</strong>、<strong>输入设备</strong>、<strong>输出设备</strong>五大部分组成</p></blockquote><blockquote><p><strong>指令</strong>和<strong>数据</strong>以<strong>同等地位</strong>存储，用<strong>二进制</strong>表示，其中<strong>指令</strong>由<strong>操作码</strong>和<strong>地址码</strong>组成</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 指令的操作数可能是立即数、寄存器编号或者存储地址，操作完后大概率会将结果回写到寄存器中</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 程序是指令的集合，也存储在存储器中</div><blockquote><p>以<strong>运算器</strong>为中心</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以运算器为中心导致运算器成为瓶颈，故再次基础上对其进行改进，以存储器为核心</div><p><strong>②以存储器为核心</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_1.png" alt="以存储器为核心的冯诺依曼结构"></p><h4 id="1-2主要部件"><a href="#1-2主要部件" class="headerlink" title="1.2主要部件"></a>1.2主要部件</h4><p><strong>①存储器</strong></p><blockquote><p><strong>存储体</strong>：由多个<strong>存储单元</strong>构成，存放<strong>二进制代码</strong></p></blockquote><blockquote><p><strong>MAR</strong>：存储器<strong>地址寄存器</strong>，反映存储<strong>单元个数</strong></p></blockquote><blockquote><p><strong>MDR</strong>：存储器<strong>数据寄存器</strong>，反映存储器<strong>字长</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> MAR相当于存储器的地址线，MDR相当于存储器的数据线</div><p><strong>②运算器</strong></p><blockquote><p><strong>ALU</strong>：<strong>算数逻辑单元</strong>，进行<strong>主要运算</strong>的单元</p></blockquote><blockquote><p><strong>相关寄存器</strong>：<code>ACC</code>、<code>MQ</code>、<code>X</code>寄存器，不同的<strong>指令</strong>，这些寄存器的<strong>用途不同</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用运算器前，需要将各个数据放入对应的寄存器中，运算完成后，结果也存放在对应寄存器中</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不同的CPU运算器都是不同的，尤其是寄存器的个数及其用途</div><p><strong>③控制器</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 解释指令、保证指令的按序执行并自动取下一条指令</div><blockquote><p><strong>PC</strong>：存放当前<strong>欲执行指令的地址</strong>，即<strong>取指</strong></p></blockquote><blockquote><p><strong>IR</strong>：存放当前<strong>欲执行的指令</strong>，即<strong>分析指令</strong></p></blockquote><blockquote><p><strong>CU</strong>：取得指令的<strong>操作码</strong>和<strong>地址码</strong>，并根据<strong>操作码</strong>发出<strong>控制信号</strong>以<strong>执行指令</strong></p></blockquote><p><strong>④一条指令的执行</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以取数指令为例</div><blockquote><p><strong>PC</strong>将<strong>指令地址</strong>送入<strong>MAR</strong></p></blockquote><blockquote><p><strong>MAR</strong>从存储体中<strong>取出取数指令</strong>放入<strong>MDR</strong></p></blockquote><blockquote><p><strong>MDR</strong>将<strong>指令</strong>送入<strong>IR</strong></p></blockquote><blockquote><p><strong>IR</strong>将指令的<strong>操作码</strong>送入<strong>CU</strong>，<strong>地址码</strong>送入<strong>MAR</strong></p></blockquote><blockquote><p>在<strong>CU</strong>的控制下，从<strong>存储体</strong>中取出<strong>对应数据</strong>放入<strong>MDR</strong>，随后送入<strong>ACC</strong></p></blockquote><blockquote><p><strong>PC+1</strong>等待<strong>下一条指令</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_2.png" alt="结构"></p><h4 id="1-3机器主要指标"><a href="#1-3机器主要指标" class="headerlink" title="1.3机器主要指标"></a>1.3机器主要指标</h4><blockquote><p><strong>机器字长</strong>：CPU<strong>一次</strong>能处理<strong>数据的位数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通常情况，机器字长和寄存器长度是相同的</div><blockquote><p><strong>运算速度</strong>：<strong>主频</strong>、<strong>核数</strong>、<strong>CPI</strong>和<strong>MIPS</strong>等</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CPI为执行一条指令所需的时钟周期数，MIPS为每秒能执行多少条指令</div><blockquote><p><strong>存储容量</strong>：可以表示为<strong>字节数</strong>或者<strong>存储单元个数x存储字长</strong></p></blockquote><hr><h3 id="2-系统总线"><a href="#2-系统总线" class="headerlink" title="2.系统总线"></a>2.系统总线</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①定义</strong></p><blockquote><p>连接<strong>各个部件</strong>的<strong>信息传输线</strong>，是各个部件<strong>共享的传输介质</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 一根总线在同一时间只能被一组设备使用</div><p><strong>②总线的分类</strong></p><blockquote><p><strong>片内总线</strong>：<strong>芯片内部</strong>的总线</p></blockquote><blockquote><p><strong>系统总线</strong>：<strong>计算机各部件之间</strong>的总线</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 还可细分位数据总线、地址总线和控制总线</div><blockquote><p><strong>通信总线</strong>：<strong>计算机系统之间</strong>或者计算机系统<strong>与其他系统</strong>的通信</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通信总线还可细分位串行通信总线和并行通信总线</div><p><strong>③设备分类</strong></p><blockquote><p><strong>主设备</strong>：可以主<strong>动申请总线资源</strong>并对总线进行<strong>控制权</strong></p></blockquote><blockquote><p><strong>从设备</strong>：只能<strong>响应主设备</strong>发来的<strong>总线命令</strong>，不能<strong>主动</strong>申请<strong>总线资源</strong></p></blockquote><p><strong>④总线性能指标</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只列出一些重要的指标</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 总线标准：一种对总线各种性能指标的规定，如USB和PCI等</div><blockquote><p><strong>总线宽度</strong>：数据线的<strong>根数</strong></p></blockquote><blockquote><p><strong>标准传输率</strong>：<strong>每秒</strong>传输的<strong>最大字节数</strong></p></blockquote><blockquote><p><strong>时钟同步/异步</strong>：是否有<strong>同步时钟</strong></p></blockquote><h4 id="2-2总线结构"><a href="#2-2总线结构" class="headerlink" title="2.2总线结构"></a>2.2总线结构</h4><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 单总线、双总线结构存在总线争用严重、无法进行设备分级等问题，故不作主要介绍</div><p><strong>①三总线结构</strong></p><blockquote><p><strong>概述</strong>：<strong>DMA总线</strong>连接<strong>高速设备</strong>，<strong>系统总线</strong>连接<strong>低速设备</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 无法平衡主存和CPU的处理速度差异</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_3.png" alt="四总线结构"><br><strong>②四总线结构</strong></p><blockquote><p><strong>概述</strong>：<strong>高速总线</strong>连接<strong>高速设备</strong>，<strong>扩展总线</strong>连接<strong>低速设备</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> cache用于平衡主存和CPU的处理速度差异</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_5.png" alt="四总线结构"></p><p><strong>③PCI总线结构</strong></p><blockquote><p><strong>概述</strong>：其中<strong>设备能接的地方</strong>也能接<code>PCI桥</code>，从而实现<strong>设备分级</strong>，经过<strong>越多的桥</strong>，<strong>速度越慢</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_6.png" alt="PCI总线结构"></p><h4 id="2-3总线占用控制"><a href="#2-3总线占用控制" class="headerlink" title="2.3总线占用控制"></a>2.3总线占用控制</h4><p><strong>①链式查询方式</strong></p><blockquote><p><strong>BR线</strong>：设备通过这条线发出<strong>总线占用请求</strong></p></blockquote><blockquote><p><strong>BS线</strong>：如果<strong>总线被占用</strong>，则会<strong>收到对应信号</strong></p></blockquote><blockquote><p><strong>BG线</strong>：总线<strong>授权</strong>线，按照<strong>设备的优先级</strong>依次连接</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 总线空闲时，多个设备提出总线占用请求，通过BG线依次查询部件，先给优先级高的部件提供总线，并设置总线忙</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 对电路故障敏感，且靠后的设备很难申请到总线，速度较慢，通常用于简单的系统中</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_7.png" alt="链式查询方式"></p><p><strong>②计数器定时查询</strong></p><blockquote><p><strong>总线控制部件</strong>中有一个<strong>计数器</strong>，值为<code>n</code>，当接收到<strong>总线请求</strong>后，通过<strong>设备地址线</strong>从<strong>第n个部件开始</strong>查找<strong>找到发出总线请求</strong>的部件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 和链式类似，但是链式的值只能是0，定时器可以人为或者通过程序设置优先级</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_8.png" alt="计数器定时查询"></p><p><strong>③独立请求方式</strong></p><blockquote><p><strong>每个部件</strong>都有对应的<strong>BR线</strong>和<strong>BS线</strong>，<strong>总线控制部件</strong>中有一个<strong>排队器</strong>设置<strong>设备的优先级</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_9.png" alt="独立请求方式"></p><h4 id="2-4总线通信控制"><a href="#2-4总线通信控制" class="headerlink" title="2.4总线通信控制"></a>2.4总线通信控制</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要是控制主设备和从设备的通信</div><p><strong>①同步通信</strong></p><blockquote><p><strong>统一时标</strong>控制<strong>通信过程</strong>，需要在<strong>对应的传输周期节点</strong>必须完成<strong>对应的操作</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 总线传输周期可分为申请分配阶段、寻址阶段、传数阶段和结束阶段</div><blockquote><p><strong>各个阶段</strong>分别完成<strong>总线申请</strong>、<strong>主设备找到从设备</strong>、<strong>交换数据</strong>和<strong>撤销请求</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 对于速度不一样的模块，选择速度最慢的模块对时标进行设计，即速度快的模块需要等速度慢的模块</div><p><strong>②异步通信</strong></p><blockquote><p><strong>不互锁</strong>：主设备<strong>发出请求</strong>，<strong>一定时间后</strong>撤销，从设备<strong>接收到请求后应答</strong>，<strong>一段时间后</strong>撤销</p></blockquote><blockquote><p><strong>半互锁</strong>：主设备<strong>发出请求</strong>后，只有<strong>接收到应答信号</strong>才撤销请求信号，从设备<strong>接收到请求后应答</strong>，<strong>一段时间后</strong>撤销</p></blockquote><blockquote><p><strong>全互锁</strong>：在<strong>半互锁</strong>基础上，从设备<strong>接收到请求后应答</strong>，只有<strong>知道主设备撤销请求后</strong>再撤销应答信号</p></blockquote><p><strong>③半同步通信</strong></p><blockquote><p>类似于<strong>同步通信</strong>，但是如果<strong>某个时间点</strong>主/从设备<strong>没有准备好</strong>，则会插入<strong>一个个等待周期</strong>，直到其<strong>准备好继续</strong></p></blockquote><p><strong>④分离式通信</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一个总线传输周期会有不使用总线的小周期，比如从设备准备数据</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了提高总线使用效率，将总线周期分为两个子周期，在不使用总线时先释放总线，随后需要使用再申请</div><blockquote><p><strong>第一个子周期</strong>：<strong>主模块申请占用总线</strong>，使用完后<strong>放弃总线的使用权</strong></p></blockquote><blockquote><p><strong>第二个子周期</strong>：当主/从模块<strong>准备好数据</strong>，<strong>从模块在申请占用总线</strong>，将<strong>各种信息</strong>送至<strong>总线</strong>上</p></blockquote><hr><h3 id="3-存储器"><a href="#3-存储器" class="headerlink" title="3.存储器"></a>3.存储器</h3><h4 id="3-1引言"><a href="#3-1引言" class="headerlink" title="3.1引言"></a>3.1引言</h4><p><strong>①分类</strong></p><blockquote><p><strong>存储介质</strong>：<strong>半导体存储器</strong>、<strong>磁表面存储器</strong>、<strong>磁芯存储器</strong>、<strong>光盘存储器</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 其中半导体存储器是易失的，即如果不加电，信息会丢失</div><blockquote><p><strong>存取方式</strong>：<strong>随机存储器</strong>、<strong>顺序存取存储器</strong>、<strong>直接存取存储器</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中随机存储器存取时间与物理地址无关，顺序存取存储器和直接存取存储器则有关</div><blockquote><p><strong>作用</strong>：<strong>主存储器</strong>、<strong>高速缓存</strong>、<strong>辅助存储器</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主存储器还可分为RAM和ROM其中RAM可读可写，ROM只读</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 辅助存储器通常用于存放数据和文档，并不直接和CPU交换数据</div><p><strong>②层次结构</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将不同层次的存储器结合到一起，使其整体形成一个容量大、速度快、价格合适的存储器</div><blockquote><p><strong>主存辅存结构</strong>：解决<strong>容量问题</strong>，若<strong>程序过大</strong>，则会将<strong>执行部分</strong>放入<strong>主存</strong>，<strong>其余部分</strong>放入<strong>辅存</strong></p></blockquote><blockquote><p><strong>主存缓存结构</strong>：解决<strong>CPU和主存速度差异问题</strong>，<strong>缓存</strong>中存放<strong>CPU经常使用</strong>的的<strong>主存信息</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_10.png" alt="层次"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_11.png" alt="结构"></p><h4 id="3-2主存"><a href="#3-2主存" class="headerlink" title="3.2主存"></a>3.2主存</h4><p><strong>①基本构成</strong></p><blockquote><p><strong>CPU和主存</strong>通过<strong>地址总线</strong>、<strong>数据总线</strong>、<strong>控制总线</strong>和<strong>片选线</strong>连接</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 片选先表示该存储器芯片是否被选择</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 各种介质的存储器抽象结构都是类似的，只是其实现细节不一样</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_4.png" alt="主存基本构成"><br><strong>②存储方式</strong></p><blockquote><p><strong>大端大尾</strong>：<strong>高位字节</strong>存储<strong>数据的低位</strong></p></blockquote><blockquote><p><strong>小端小尾</strong>：<strong>低位字节</strong>存储<strong>数据的低位</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 均以数据低位字节所在地址作为该数据的地址</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 边界对齐：数据存放的起始地址是数据长度（以字节为单位）的整数倍</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不同存储方式的文件和机器在交换数据时需要统一</div><p><strong>③译码驱动方式</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 译码驱动就是根据地址线找到对应的地址单元</div><blockquote><p><strong>线选法</strong>：只有一个<strong>地址译码器</strong>，将<strong>存储矩阵</strong>看作为<strong>一个个线性的数组</strong>，每次通过<strong>译码结果</strong>选择<strong>其中一行</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当地址线很多时，如20根，译码器需要1M根线，导致无法高度集成</div><blockquote><p><strong>重合法</strong>：有<strong>行地址译码器</strong>和<strong>列地址译码器</strong>，根据<strong>两者译码结果</strong>打开对应<strong>行列的开关</strong>，选取<strong>对应坐标的存储单元</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 20地址线，平均分为两份，每份需要1K根线，总共只要2k条，所以主要使用重合法进行译码驱动</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一个列选信号可能对应多列，从而一次性取出多位数据</div><blockquote><p>假设有<strong>16列</strong>，将其分为<strong>4组</strong>，<strong>列选信号</strong><code>0</code>表示选择<strong>每一组的第0列</strong>，从而<strong>一次选取4列</strong></p></blockquote><p><strong>④主要技术指标</strong></p><blockquote><p><strong>存储容量</strong>：存放<strong>二进制代码</strong>的<strong>总位数</strong></p></blockquote><blockquote><p><strong>存取时间</strong>：存储器的<strong>访问时间</strong></p></blockquote><blockquote><p><strong>存储周期</strong>：<strong>连续两次独立</strong>的存储器操作所需的<strong>最小间隔时间</strong></p></blockquote><blockquote><p><strong>存储器带宽</strong>：<strong>单位时间存储读取的长度（位/秒）</strong></p></blockquote><p><strong>④随机存取存储器RAM</strong></p><blockquote><p><strong>静态RAM</strong>：使用<strong>双稳态触发器</strong>存放<code>0/1</code></p></blockquote><blockquote><p><strong>动态RAM</strong>：使用<strong>电容</strong>存放<code>0/1</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 电容很容易漏电，需要定时对电容进行充电，也就是刷新</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 刷新方式可分为集中刷新、分散刷新和异步刷新</div><blockquote><p><strong>集中刷新</strong>：<strong>每隔一段时间</strong>对<strong>所有单元</strong>进行刷新</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 刷新期间无法对芯片进行读写，也被称为死区，一次性刷新所有单元导致死区时间较长</div><blockquote><p><strong>分散刷新</strong>：<strong>每个读写周期</strong>后，对<strong>一个存储单元</strong>进行刷新，使<strong>读写周期变长</strong></p></blockquote><blockquote><p><strong>异步刷新</strong>：<strong>每隔一段时间</strong>刷新<strong>一行</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 合理安排刷新时间，如安排在指令译码阶段，则不会出现死区</div><p><strong>⑤只读存储器ROM</strong></p><blockquote><p><strong>ROM</strong>的主要供<strong>读取</strong>，通常<strong>不可修改</strong>或者<strong>修改起来很麻烦</strong>，通常用来保存<strong>系统程序</strong>以及<strong>系统配置信息</strong></p></blockquote><blockquote><p>可分为<strong>MROM</strong>、<strong>PROM</strong>、<strong>ERPOM</strong>、<strong>EEPROM</strong>和<strong>闪存</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> MROM不能修改，PROM可以被修改一次，EPROM可紫外线擦写多次，EEPROM电可擦写多次</div><h4 id="3-3主存和CPU的连接"><a href="#3-3主存和CPU的连接" class="headerlink" title="3.3主存和CPU的连接"></a>3.3主存和CPU的连接</h4><p><strong>①扩展</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 扩展的本质就是合理安排各个芯片的数据线、地址线和片选线</div><blockquote><p><strong>位扩展</strong>：增加<strong>存储字长</strong>，如使用<strong>2片1Kx4位</strong>的存储芯片组成<strong>一个1Kx8位</strong>的存储器</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 1KX4位芯片有10根地址线和4根数据线，1KX8位芯片有10根地址线和8根数据线</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将两个1Kx4位芯片的数据线分别连接到八根数据线上，地址线同连在10根地址线上，并将两者的片选线并联即可</div><blockquote><p><strong>字扩展</strong>：增加<strong>存储容量</strong>，如使用<strong>2片1Kx4位</strong>的存储芯片组成<strong>一个2Kx4位</strong>的存储器</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 1KX4位芯片有10根地址线和4根数据线，2KX4位芯片有11根地址线和4根数据线</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将两个1Kx4位芯片的数据线同连到4根数据线上，地址线同连在10根地址线上，并将多余地址线作为两芯片的片选线</div><blockquote><p><strong>字位同时扩展</strong>：使用<strong>4片1Kx4位</strong>的存储芯片组成<strong>一个2Kx8位</strong>的存储器</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 先进行位扩展，再进行字扩展即可</div><p><strong>②校验</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 存储器可能被周围环境干扰，导致其存储单元的数值发生变化，从而产生误码</div><blockquote><p><strong>合法代码集</strong>：不在该<strong>集合中</strong>的<strong>码元</strong>是<strong>误码</strong></p></blockquote><blockquote><p>如<code>{000,111}</code>使用<code>000</code>表示<code>0</code>，<code>111</code>表示<code>1</code>，当出现<code>100</code>，会被自动纠正位<code>000</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 由于1位错误发生概率最大，所以出现误码时，认为其出现1位错误</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 该合法代码集合无法检测出两位错误并纠正，这也是合法代码集的局限性</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 合法代码集的纠错能力与其冗余度有关，冗余度越高，纠错能力越强，如{00000,11111}可以检测出两位错误并纠正</div><blockquote><p><strong>汉明码</strong>：采用<strong>偶校验</strong>、<strong>分组校验</strong>，能<strong>检测并纠错1位</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 偶校验即本来代码的1个数为偶数个，若发生一位误码，则校验位变为1，使其变为偶数个，奇校验类似</div><blockquote><p>假设代码有<strong>x位</strong>，其<strong>二进制表示</strong>有<strong>y位</strong>，则将其<strong>分为y组</strong>，如<code>0000000</code>有<strong>7位</strong>，则将其分为<strong>3组</strong></p></blockquote><blockquote><p><strong>索引二进制形式第i位为1</strong>的为<strong>第i组</strong>，并将<strong>索引第i位为1，其他位为0</strong>的那一位作为<strong>所在组</strong>的<strong>校验位</strong>，第<code>1、3、5、7</code>位分为<strong>一组</strong>，第<code>2、3、6、7</code>位分为<strong>一组</strong>，第<code>4、5、6、7</code>位分为<strong>一组</strong>，其中第<code>1、2、4</code>位作为<strong>校验位</strong></p></blockquote><blockquote><p>如果<strong>没有差错</strong>，<strong>校验位</strong>应该<strong>均为0</strong>，若<strong>出现差错</strong>，则将<strong>校验位从小到大进行排序</strong>，组成的<strong>二进制数对应索引位</strong>出现<strong>错误</strong>，若<strong>校验位</strong>分别为<code>001</code>，则<strong>第一位出错</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 001表示第一组出错，但是其余两组没错，则就是第一位错，因为只有1在第一组而不再其余两组中</div><p><strong>③主存结构</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CPU需要从内存中读取/写入指令和数据才能进行工作，所以需要提升CPU和内存的交互速度</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以一次性从内存中读取多个存储单元以提升两者交互速度</div><blockquote><p><strong>单体多字</strong>：一次性<strong>线性选择</strong>多个存储单元</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不够灵活，如果如果只需要读取/存储一个或者零星分布的存储单元，将比较麻烦</div><blockquote><p><strong>高位交叉</strong>：将<strong>存储地址</strong>分为<code>存储体号:体内地址</code>，每次先根据<strong>存储体号</strong>选择<strong>存储体</strong>，再根据<strong>体内地址</strong>选择<strong>存储单元</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 由于程序是连续存储的，执行程序时会一直访问局部单元（即低位变化），导致一个存储体特别繁忙</div><blockquote><p><strong>低位交叉</strong>：将<strong>存储地址</strong>分为<code>体内地址:存储体号</code>，其余<strong>和高位交叉一致</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 这样就可以将程序分布在多个存储体中，执行程序时，多个存储体可以并行工作</div><h4 id="3-4高速缓存Cache"><a href="#3-4高速缓存Cache" class="headerlink" title="3.4高速缓存Cache"></a>3.4高速缓存Cache</h4><p><strong>①引言</strong></p><blockquote><p>由于<strong>局部性原理</strong>，将程序<strong>近期使用的指令和数据</strong>放入<strong>Cache</strong>中以<strong>提升访问速度</strong>，<strong>Cache</strong>的<strong>访问速度块</strong>，但是<strong>容量小</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 局部性原理：当前正在使用的指令和数据不久后很有可能在此使用，其相邻的指令和数据也很有可能被调用</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过对Cache进行分级或者将其分为指令Cache和数据Cache进一步提升效率</div><p><strong>②工作原理</strong></p><blockquote><p><strong>Cache地址</strong>可分为<code>缓存块号:块内地址</code>，<strong>主存地址</strong>可分为<code>主存块号:块内地址</code></p></blockquote><blockquote><p><strong>Cache</strong>每个块有一个<strong>标记</strong>，保存了<code>缓存块号</code>和<code>主存块号</code>的<strong>映射关系</strong></p></blockquote><blockquote><p><strong>读数据</strong>时，先查看<strong>访问地址的</strong><code>主存块号</code>是否<strong>在Cache中</strong>，如果在则<strong>直接读取</strong>，如果<strong>不在</strong>，则将其<strong>存入Cache</strong>中</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如果Cache没有空闲空间，则采用替换算法取出不用的块再将其存入，常见的替换算法有FIFO和LUR</div><blockquote><p><strong>写数据</strong>时，可以将数据<strong>同时</strong>写入<strong>缓存块</strong>和<strong>对应主存块</strong>，也可以<strong>先更新缓存块</strong>，当缓存块被<strong>替换</strong>时，再<strong>更新主存块</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 第一种方法可能导致对同一个主存块的频繁访问</div><p><strong>③地址映射</strong></p><blockquote><p><strong>直接映射</strong>：将主存<strong>分区</strong>，该区的<strong>主存块</strong>只能映射到Cache的<strong>某个固定缓存块</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 访问速度较快，但是容易产生冲突</div><blockquote><p><strong>全相联映射</strong>：主存块可以放在<strong>任意缓存块位置</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不会发生冲突，但是每次访问需要遍历缓存块，访问速度较慢</div><blockquote><p><strong>组相联映射</strong>：主存<strong>分区</strong>，Cache<strong>分组</strong>，主存储器<strong>某个区的存储单元</strong>只能存储到Cache的<strong>固定组的任意位置</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 直接映射和全相联映射的结合，中和了两者的优点和缺点</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 《计算机组成原理》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理（下）</title>
      <link href="/2023/12/10/ji-suan-ji-zu-cheng-yuan-li-xia/"/>
      <url>/2023/12/10/ji-suan-ji-zu-cheng-yuan-li-xia/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="计算机组成原理（下）"><a href="#计算机组成原理（下）" class="headerlink" title="计算机组成原理（下）"></a>计算机组成原理（下）</h2><h3 id="1-I-x2F-O系统"><a href="#1-I-x2F-O系统" class="headerlink" title="1.I/O系统"></a>1.I/O系统</h3><h4 id="1-1组成"><a href="#1-1组成" class="headerlink" title="1.1组成"></a>1.1组成</h4><p><strong>①软件部分</strong></p><blockquote><p><strong>I/O指令</strong>：<strong>CPU指令集</strong>的一部分，格式为<code>操作码:命令码:设备码</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 操作码指明该指令是I/O指令，命令码指明操作，设备码指定I/O设备或者其端口的地址</div><blockquote><p><strong>通道指令</strong>：<strong>通道自身</strong>的指令，用于控制<strong>通道的工作</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通道是一种小型的DMA处理机，实现I/O设备和主机直接进行信息传输</div><p><strong>②硬件部分</strong></p><blockquote><p><strong>I/O设备</strong>：由<strong>设备控制器</strong>和<strong>其他部分</strong>组成</p></blockquote><blockquote><p><strong>接口</strong>：<strong>I/O设备</strong>通过<strong>设备控制器</strong>和<strong>接口</strong>相连，从而和<strong>主机总线</strong>连接</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如果设备使用通道，设备通过设备控制器和子通道连接</div><p><strong>③接口组成</strong></p><blockquote><p><strong>设备选择电路</strong>：<strong>一个接口</strong>可能连接<strong>多个设备</strong>，<strong>一个设备</strong>也有<strong>多个端口</strong>，需要通过<strong>设备地址/端口号</strong>进行选择</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> I/O设备可能被看作内存的一部分进行统一编址，也可能单独设置一个地址空间，后者需要专门的I/O指令</div><blockquote><p><strong>数据缓冲寄存器</strong>：用于作为<strong>数据缓冲区</strong>，平衡<strong>处理器</strong>和<strong>外设</strong>之间的<strong>速度差异</strong></p></blockquote><blockquote><p><strong>命令寄存器和译码器</strong>：用于<strong>存储</strong>以及<strong>解释I/O指令</strong></p></blockquote><blockquote><p><strong>状态标记</strong>：用于告知<strong>控制逻辑电路</strong>外设和处理器状态，如是否<strong>准备完成</strong>，是否<strong>空闲</strong>、是否<strong>允许中断</strong>等</p></blockquote><blockquote><p><strong>控制逻辑电路</strong>：接口中的<strong>控制单元</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 除此之外，接口还需要协调外设和处理器，如进行数据串—并格式转换，并记录数据传输信息，如</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_12.png" alt="接口组成"></p><p><strong>④程序查询方式</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一种CPU和外设通信的方式，其余还有程序中断方式和DMA方式</div><blockquote><p><strong>CPU</strong>发出<strong>I/O指令</strong>后，根据<strong>设备优先级</strong>依次检查设备，若该设备<strong>准备好</strong>，则进行<strong>对应操作</strong>，否则一直<strong>轮询</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> I/O处理过程中，CPU一直被占用，效率很低</div><h4 id="1-2程序中断方式"><a href="#1-2程序中断方式" class="headerlink" title="1.2程序中断方式"></a>1.2程序中断方式</h4><p><strong>①工作原理</strong></p><blockquote><p>CPU发出<strong>I/O指令</strong>后，<strong>启动外设</strong>后继续<strong>执行主程序</strong>，外设<strong>开始准备</strong></p></blockquote><blockquote><p><strong>I/O设备准备好后</strong>，向CPU发送<strong>中断信号</strong>，CPU执行完<strong>当前指令</strong>后，如果<strong>可以处理该中断</strong>，转去执行<strong>中断处理程序</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> CPU可以只有其中断允许触发器EINT为01时才能响应中断，且中断是有优先级的，会优先响应优先级高的设备</div><p><strong>②中断流程</strong></p><blockquote><p><strong>提出中断</strong>：<strong>每个中断源</strong>都有一个<strong>INTR触发器</strong>用于提出<strong>中断请求</strong></p></blockquote><blockquote><p><strong>触发中断</strong>：CPU使用<strong>中断请求标记寄存器</strong>记录<strong>各个</strong>中断源<strong>是否发出请求</strong>，每次<strong>执行完指令</strong>后<strong>查询该寄存器</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 中断请求标记寄存器的每一位按照优先级对应一个中断源，1表示发出中断请求，0表示没有发出中断请求或者被屏蔽</div><blockquote><p><strong>响应中断</strong>：选择<strong>优先级最高的中断</strong>，随后执行<strong>中断隐指令</strong>，并跳转到<strong>对应中断服务程序</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 中断隐指令会保存程序断点PC，随后将中断程序入口地址置给C，并将中断允许触发器EINT置为0，全部由硬件完成</div><blockquote><p><strong>中断服务程序</strong>：保存<strong>CPU各个寄存器内容</strong>，并根据<strong>I/O指令</strong>做出<strong>对应操作</strong>，跳转到<strong>返回地址</strong>，并恢复<strong>寄存器内容</strong></p></blockquote><p><strong>③中断屏蔽字</strong></p><blockquote><p><strong>概述</strong>：<strong>每个中断源</strong>都有一个<strong>中断屏蔽字</strong>，<strong>各个位</strong>对应<strong>各个中断源的中断屏蔽触发器</strong>，为<code>1</code>使其<strong>无法发出中断请求</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 中断屏蔽字通常在该中断被响应且执行中断隐指令后，开中断前设置</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 中断屏蔽字可以人为设置，使该中断执行过程中，不会被某些中断打断</div><p><strong>④单重/多重中断</strong></p><blockquote><p><strong>单重中断</strong>：<strong>不允许</strong>中断<strong>现行的中断服务程序</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 执行中断服务程序之前关中断，直到恢复现场后才开中断</div><blockquote><p><strong>多重中断</strong>：<strong>允许级别更高的中断源</strong>中断<strong>现行的中断服务程序</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 保护现场之后就开中断</div><h4 id="1-3DMA方式"><a href="#1-3DMA方式" class="headerlink" title="1.3DMA方式"></a>1.3DMA方式</h4><p><strong>①工作原理</strong></p><blockquote><p>CPU发出<strong>I/O指令</strong>后，<strong>启动外设</strong>后继续<strong>执行主程序</strong>，外设<strong>开始准备</strong></p></blockquote><blockquote><p><strong>I/O设备准备好后</strong>，<strong>DMA控制器</strong>发出<strong>DMA请求</strong>，占用<strong>总线</strong>和<strong>内存</strong>，进行<strong>I/O设备</strong>和<strong>内存</strong>的<strong>数据交换</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> MA方式中，主存和I/O设备之间有一条直接的数据通道，不需要通过CPU寄存器进行数据交互</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> DMA工作期间，CPU虽然不能使用总线以及访问内存，但是可以进行其他工作，如执行缓存中的指令</div><p><strong>②占用方式</strong></p><blockquote><p><strong>直接占用</strong>：当<strong>发出DMA请求</strong>时，使得CPU<strong>放弃总线和主存控制权</strong>，直到<strong>DMA</strong>工作<strong>全部完成</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若DMA工作时间过长，会影响CPU工作，因为CPU还要去主存取出指令和数据</div><blockquote><p><strong>交替访问</strong>：CPU<strong>工作周期</strong>中，有<strong>一段时间</strong>专门提供给<strong>DMA</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不够灵活</div><blockquote><p><strong>周期挪用</strong>：当<strong>发出DMA请求</strong>时，若CPU<strong>正在访问</strong>主存，则<strong>DMA等待</strong>，若<strong>CPU没有访问主存</strong>，DMA挪<strong>用一个或者固定几个存取周期</strong>，两者<strong>同时请求</strong>，<strong>DMA优先</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> DMA分批次传送数据，若数据没有被传输完，则再发送DMA请求，直到数据传输完成</div><p><strong>③传送过程</strong></p><blockquote><p><strong>预处理</strong>：将一定的<strong>控制信息</strong>存入<strong>DMA接口的寄存器</strong>中，随后<strong>启动设备</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 控制信息主要有传输方向、设备地址、主存地址和传送字数</div><blockquote><p><strong>数据传送</strong>：<strong>CPU</strong>继续<strong>执行主程序</strong>，由<strong>DMA</strong>完成<strong>数据输送</strong>，<strong>传输完成</strong>后，向CPU发出<strong>中断请求</strong>告知</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每次传输完数据后，还需要修改控制信息，以便于下一次的传输</div><blockquote><p><strong>后处理</strong>：执行<strong>中断服务程序</strong>，以<strong>检查</strong>这次传输过程<strong>是否出现错误</strong></p></blockquote><p><strong>④DMA接口分类</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 同样，一个DMA接口可能连接多个设备，有请求线和响应线，连接方式类似于总线的链式请求和独立请求</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 设备的传输速度越快，优先级较高</div><blockquote><p><strong>选择型</strong>：各个寄存器<strong>只有一套</strong>，只能给<strong>一个设备</strong>使用，直到<strong>数据全部传输结束</strong>，才<strong>释放接口</strong></p></blockquote><blockquote><p><strong>多路型</strong>：各个寄存器有<strong>多套</strong>，每一套也称为<strong>子通道</strong>，每次有一个<strong>新的设备的I/O请求</strong>，就给其<strong>分配一个空闲子通道</strong>，供其进行<strong>为数据传输进行准备</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 两者都只能是一个设备传输数据，但是多路型可以在多个设备间交替传输，即使一个设备的任务还没有完成</div><hr><h3 id="2-计算机数字"><a href="#2-计算机数字" class="headerlink" title="2.计算机数字"></a>2.计算机数字</h3><h4 id="2-1表示形式"><a href="#2-1表示形式" class="headerlink" title="2.1表示形式"></a>2.1表示形式</h4><p><strong>①真值与机器数</strong></p><blockquote><p><strong>概述</strong>：称<strong>真实世界</strong>的数字为<strong>真值</strong>，如<code>+0.1101111B</code>，<strong>存储在机器中</strong>的<strong>01序列</strong>为<strong>机器数</strong>，如<code>01101111B</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 数字中的小数点规定在特定位置，并不显示出现在机器数中</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上就是用有限个数值表示对应范围，机器数的位数越多，范围/精度越大</div><blockquote><p><strong>进制</strong>：<strong>计算机</strong>采用<strong>二进制</strong>保存数据，同时辅以<strong>其他进制</strong>，如<strong>八进制</strong>、<strong>十进制</strong>、<strong>十六进制</strong>等</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 两个稳定态的物理实现简单，且二进制便于计算以及逻辑运算</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 同样的信息，二进制表示较长，可以将其转化为八进制以及十六进制减少其长度</div><p><strong>②有符号/无符号数</strong></p><blockquote><p><strong>有符号数</strong>：<strong>最高位</strong>为<strong>符号位</strong>，<strong>其余位</strong>用于<strong>表示数值大小</strong>，即<code>符号位:数值位</code>，<strong>范围</strong>为<code>-2^n-1</code>至<code>2^(n-1)-1</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 符号位为0表示正，符号位为1表示负</div><blockquote><p><strong>无符号数</strong>：<strong>所有位</strong>都用于<strong>表示数值</strong>，<strong>范围</strong>为<code>0</code>至<code>2^n-1</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 同一二进制序列，被解释为有符号数和无符号数差别是很大的</div><blockquote><p>若<strong>有符号负数</strong>被解释为<strong>无符号数</strong>，相当于<strong>真值加</strong><code>2^n</code>，若若<strong>无符号数</strong>被解释为<strong>有符号数</strong>，相当于<strong>真值减</strong><code>2^n</code></p></blockquote><p><strong>③定点/浮点数</strong></p><blockquote><p><strong>定点数</strong>：<strong>小数点</strong>规定在<strong>特定位置</strong>，常见的有在<strong>符号位后</strong>或者在<strong>数值位后</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 小数点在符号位后，则只能表示整数，小数点在数值位后，则只能表示绝对值小于等于1的小数</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 机器数位相同的情况下，定点数能表示的范围太小</div><blockquote><p><strong>浮点数</strong>：根据<code>IEEE 754</code>标准，<strong>机器位</strong>分为<code>数符位S:阶码位E:尾数位N</code>，<strong>数值</strong>为<code>(-1)^Sx(1+N)x2^(E-127)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 阶码位为定点整数，尾数位为定点小数，浮点数的表示范围为最小负数—最大负数和最小正数—最大正数</div><blockquote><p>当<strong>阶码</strong>为<code>0</code>，<strong>尾数</strong>为<code>0</code>时，浮点数表示<code>+/-0</code></p></blockquote><blockquote><p>当<strong>阶码</strong>为<strong>全一</strong>，<strong>尾数</strong>为<code>0</code>时，表示<code>+/-∞</code>，<strong>尾数</strong>不为<code>0</code>，表示<code>NaN</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了充分利用数值位，规定尾数形式为1.xxx，其中小数点前的1省略不写，在计算时自动加上即可</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当输入数据是一个不可表示数时，转化为最邻近的可表示数</div><h4 id="2-2编码方案"><a href="#2-2编码方案" class="headerlink" title="2.2编码方案"></a>2.2编码方案</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要讨论8位有符号定点数，假设小数点在数值位后，浮点数将其中各个部分按照定点数规则变换即可</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 常用字符编码方案为UTF-8,为一种可变长度的编码，根据字符的复杂性使用1到4字节来表示一个字符，不多介绍</div><p><strong>①原码</strong></p><blockquote><p><strong>概述</strong>：<strong>符号位</strong>表示其<strong>正负</strong>，<strong>数值位</strong>表示<strong>其绝对值</strong>，如<code>01101111B</code>为<code>+1101111B</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 使用原码进行加减运算，无法统一，不利于硬件实现，如一个正数加上一个负数，还需要考虑符号位转化为减法</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常使用使用原码表示浮点数尾数</div><p><strong>②反码</strong></p><blockquote><p><strong>概述</strong>：对于<strong>正数</strong>，反码为<strong>原码</strong>，对于<strong>负数</strong>保持原码<strong>符号位不变</strong>，<strong>数值位依次取反</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常使用补码表示有符号整数</div><p><strong>③补码</strong></p><blockquote><p><strong>概述</strong>：本质上是其<strong>补数的原码</strong>，对于<strong>正数</strong>，补码为其<strong>原码</strong>，对于<strong>负数</strong>，在其<strong>反码的基础</strong>上加<code>1</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 补码10000000的原码为00000000，与00000000相矛盾，故规定10000000为-128</div><blockquote><p><strong>补数</strong>：一个数<strong>加上模数</strong>即为补数，<strong>加一个数的补数减去模数</strong>，相当于<strong>减去该数</strong>，此处<strong>模数</strong>为<code>2^n</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如将时钟6点调整到3点，可以顺时针拨动9格，也可以逆时针拨动3格</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 计算机会自动帮机器数减去模数，所以使用补码可以很简单的统一正负数的加减法，有利于硬件实现</div><blockquote><p>由于<strong>补码</strong>可以<strong>将减法转化为加法</strong>，故计算机内部的<strong>硬件电路</strong>主要是<strong>基于加法运算</strong>设计的</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 使用补码无法通过机器直接判断两个数的大小</div><blockquote><p>如<code>+21</code>的<strong>补码</strong>为<code>00010101</code> <code>-21</code>的<strong>补码</strong>为<code>10010101</code>，判断大小会判断<strong>后者大于前者</strong></p></blockquote><p><strong>④移码</strong></p><blockquote><p><strong>概述</strong>：无论是<strong>正数还是负数</strong>，移码为<strong>补码</strong>的<strong>符号位取反</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 移码的就是给其加上2^n-1，只有整数形式的定义</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 移码便于比较大小，常用于表示浮点数阶码</div><p><strong>⑤机器零</strong></p><blockquote><p><strong>机器零</strong>：可分为<code>+0</code>和<code>-0</code>，两者<strong>补码</strong>和<strong>移码</strong>相同，<strong>源码</strong>和<strong>反码</strong>不同</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 所以8位机器数的补码和移码表示范围为-128-127，源码和反码只能表示-127-127</div><blockquote><p>对于<strong>浮点数</strong>，当其<strong>尾数</strong>为<code>0</code>、<strong>阶码为最小负值</strong>或者处于<strong>最大负数</strong>和<strong>最小正数</strong>之间，都可<strong>判断</strong>其为<code>0</code></p></blockquote><h4 id="2-3定点运算"><a href="#2-3定点运算" class="headerlink" title="2.3定点运算"></a>2.3定点运算</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 浮点数的运算最后还是会转化为定点运算，其中加减运算，需要同时调整阶码和尾数使其阶码一致且大小不变</div><p><strong>①移位运算</strong></p><blockquote><p><strong>概述</strong>：<strong>数据位</strong>相对于<strong>小数点</strong>进行<strong>左/右移</strong>，<strong>绝对值</strong>进行<strong>扩大/缩小</strong>，对于<strong>二进制</strong>，移动<strong>一位</strong>，数值变化<strong>2倍</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 移位运算可分为算数移位和逻辑移位，前者面对有符号数，后者面对无符号数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 移位操作还可以将移出部分记录到寄存器中</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意移位操作移动的是数值位，不会影响符号位</div><blockquote><p><strong>算数移位</strong>：对于<strong>正数</strong>，<strong>任何情况</strong>都填<code>0</code>，对于<strong>负数</strong>，<strong>原码</strong>填<code>0</code>，<strong>反码</strong>填<code>1</code>，<strong>补码左移</strong>填<code>0</code>，<strong>右移</strong>填<code>1</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 移动时，右移丢1会导致精度丢失，可能向上或者向下进位，左移丢1可能会导致结果错误，实际上就是溢出</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 能选择时，最好进行右移，因为右移顶多精度丢失，如调整浮点数阶码一致，小阶阶码右移向大阶看齐</div><blockquote><p><strong>逻辑移位</strong>：<strong>所有的位</strong>都会参加移位，<strong>左移右移</strong>均填<code>0</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常采用对无符号数进行逻辑移位，移植性更强</div><p><strong>②加减法运算</strong></p><blockquote><p><strong>概述</strong>：通过<strong>补码</strong>进行<strong>运算</strong>，<code>A+B</code>的<strong>补码</strong>等于<code>A</code>的<strong>补码</strong>加上<code>B</code>的<strong>补码</strong>，<code>A-B</code>的<strong>补码</strong>等于<code>A</code>的<strong>补码</strong>加上<code>-B</code>的<strong>补码</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 符号位一起相加，符号位产生的进位自然丢掉</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将正负数的加减法都统一为补码的加法</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 进行加减操作时，需要考虑结果是否超出存储单元长度，即发生了溢出</div><blockquote><p><strong>溢出</strong>：当参加操作的两个数<strong>符号相同</strong>，其<strong>结果符号</strong>与<strong>原操作数符号不同</strong>，则发生<strong>溢出</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因为只有两个正数/负数相加才可能发生溢出</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若数值位最高位发生的进位与符号位产生的进位结果不相同（异或结果为1），则发生了溢出</div><p><strong>③乘法运算</strong></p><blockquote><p><strong>概述</strong>：将<strong>乘数数值位拆分</strong>为多个<strong>乘法因子</strong>相加，<strong>与乘法因子相乘</strong>相当于进行<strong>移位操作</strong>，最后将<strong>各个结果相加</strong>即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 结果的符号位有乘数和被乘数的符号位异或得到</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 第i个乘法因子即第i位为原值，其余位为0，如11拆为10+01</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 被乘数和乘数的位应该相同，结果保存到长度为其两倍的寄存器中</div><p><strong>④除法运算</strong></p><blockquote><p><strong>概述</strong>：比较<strong>被除数</strong>和<strong>除数</strong>的<strong>绝对值</strong>，根据两者大小做出<strong>不同的操作</strong>，随后<strong>除数右移</strong>，循环操作</p></blockquote><blockquote><p>若<strong>被除数大于除数</strong>，被除数<strong>减少除数</strong>，<strong>末位</strong>添<code>0</code>，<strong>商</strong>上<code>1</code></p></blockquote><blockquote><p>若<strong>被除数大于除数</strong>，被除数<strong>不变</strong>，<strong>末位</strong>添<code>0</code>，<strong>商</strong>上<code>1</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 除法进行过程中，除数和被除数的长度不断增加，对于N位除法，需要使用2N位的加法器</div><blockquote><p>当<strong>商的位数</strong>等于其<strong>存储器长度</strong>时，<strong>被除数减去除数</strong>的值为<strong>余数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 结果的符号位有除数和被除数的符号位异或得到</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 对于小数除法，除数应该大于被除数，对于整数除法，除数应该小于被除数，否则会发生溢出</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 除数不能为0</div><hr><h3 id="3-CPU"><a href="#3-CPU" class="headerlink" title="3.CPU"></a>3.CPU</h3><h4 id="3-1机器指令"><a href="#3-1机器指令" class="headerlink" title="3.1机器指令"></a>3.1机器指令</h4><p><strong>①格式</strong></p><blockquote><p>将指令分为<strong>多个字段</strong><code>字段1:字段2...字段N</code>，分别<strong>按需分配</strong>给<strong>操作码</strong>和<strong>地址码</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 操作码指出操作类型及操作数类型，地址码指出操作数地址，操作码位数影响指令种类，地址码位数影响寻址范围</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 采用硬件资源替代指令字中的地址码字段，以节省字段分配给其他部分，以提升指令种类/寻址范围上限</div><blockquote><p>如8086的<strong>乘法指令</strong>，将<strong>操作数</strong>以及<strong>结果</strong>存入<strong>指定寄存器</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 短操作码不能是长操作码前缀，通常将短操作码中的全1序列作为特殊序列，表示其后一个字段也是操作码部分</div><blockquote><p>如<code>1110:1010:1010:1010</code>的<strong>第一个字段</strong>为<strong>操作码</strong>，<code>1111:1010:1010:1010</code>的<strong>前两个字段</strong>为<strong>操作码</strong>，以此类推</p></blockquote><p><strong>②寻址方式</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 指令中的地址码为形式地址，需要根据指令中的寻址方式找到真实地址</div><blockquote><p><strong>立即寻址</strong>：形式地址就是<strong>操作数</strong></p></blockquote><blockquote><p><strong>直接寻址</strong>：形式地址就是<strong>存储单元的真实地址</strong></p></blockquote><blockquote><p><strong>隐含寻址</strong>：操作数地址<strong>隐含在操作码中</strong>，如8086的<strong>乘法指令</strong></p></blockquote><blockquote><p><strong>间接寻址</strong>：形式地址为一<strong>内存单元地址</strong>，其中<strong>保存数据真实地址</strong></p></blockquote><blockquote><p><strong>寄存器寻址</strong>：形式地址为一<strong>寄存器编号</strong>，其中<strong>保存数据</strong></p></blockquote><blockquote><p><strong>寄存器间接寻址</strong>：形式地址为一<strong>寄存器编号</strong>，其中<strong>保存数据真实地址</strong></p></blockquote><blockquote><p><strong>基址寻址</strong>：<strong>基址寄存器数值</strong>经过<strong>一定变换</strong>加上<strong>形式地址</strong>得到<strong>真实地址</strong></p></blockquote><blockquote><p><strong>变址寻址</strong>：<strong>变址寄存器数值</strong>直接加上<strong>形式地址</strong>得到<strong>真实地址</strong></p></blockquote><blockquote><p><strong>堆栈寻址</strong> ：<strong>真实地址</strong>为<strong>栈顶地址</strong></p></blockquote><p><strong>③指令集</strong></p><blockquote><p><strong>精简指令集计算机RISC</strong>：指令<strong>数量少</strong>，每条指令的<strong>功能简单</strong>，<strong>复杂指令</strong>由<strong>简单指令组合</strong>实现</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> RISC便于设计，成本低，运算速度快，但是不易兼容</div><blockquote><p><strong>复杂指令集计算机CISC</strong>：指令<strong>数量多</strong>，每条指令<strong>功能强大</strong>，使用的<strong>频度相差较大</strong></p></blockquote><h4 id="3-2CPU功能"><a href="#3-2CPU功能" class="headerlink" title="3.2CPU功能"></a>3.2CPU功能</h4><p><strong>①结构概述</strong></p><blockquote><p><strong>控制器</strong>：<strong>取指令</strong>，<strong>分析指令</strong>并给出对应<strong>控制信号</strong>，还需要处理<strong>异常</strong>和<strong>特殊请求</strong></p></blockquote><blockquote><p><strong>运算器</strong>：实现<strong>算数运算</strong>和<strong>逻辑运算</strong></p></blockquote><blockquote><p><strong>中断系统</strong>：</p></blockquote><blockquote><p><strong>寄存器</strong>：可分为<strong>通用寄存器</strong>、<strong>数据寄存器</strong>、<strong>地址寄存器</strong>、<strong>条件码寄存器</strong>、<strong>控制寄存器</strong>和<strong>状态寄存器</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 寄存器存放CPU工作需要的信息，如操作数、地址、段地址、条件码、程序状态等</div><blockquote><p>还有一些<strong>用户不可见</strong>的寄存器，如<code>IR</code>、<code>MAR</code>和<code>MDR</code></p></blockquote><p><strong>②周期</strong></p><blockquote><p><strong>指令周期</strong>：<strong>取出并执行</strong>指令所需的<strong>全部时间</strong>，按<strong>时间顺序</strong>可分为<strong>取址周期</strong>、<strong>间址周期</strong>、<strong>执行周期</strong>和<strong>中断周期</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每条指令一定有取址周期和执行周期，不一定有间址周期和中断周期，当然也有其他的分割方法</div><blockquote><p><strong>机器周期</strong>：指令执行的一个<strong>基准时间</strong>，<strong>每个指令周期</strong>可以分为<strong>多个机器周期</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 机器周期的长度可以相等也可以不相等，即包含的节拍数可以不同</div><blockquote><p><strong>时钟周期</strong>：控制计算机操作的<strong>最小时间单位</strong>，<strong>每个机器周期</strong>可以分为<strong>多个相等的时钟周期</strong></p></blockquote><p><strong>③指令流水</strong></p><blockquote><p><strong>概述</strong>：<strong>一条指令的执行</strong>可以分为<strong>不同阶段</strong>，在<strong>进行一条指令的某个阶段</strong>的同时进行<strong>其他指令的其他阶段</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 指令流水本质就是指令级的并行，由硬件实现，可以显著提升指令执行效率</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 并行可分为并发和同时，前者表示多个时间在同一段时间内发生，后者表示多个事件在同一时刻发生</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 实际执行会遇到很多非理想情况，如各个阶段时间不同、跳转指令的影响、资源的冲突、指令必要的先后顺序等</div><blockquote><p>可以利用<strong>缓冲部件</strong>、<strong>分支预测</strong>、<strong>指令停顿</strong>、<strong>后推法</strong>等分别解决上述问题</p></blockquote><blockquote><p><strong>指标</strong>：吞吐率、加速比等</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 吞吐率指单位时间内流水线完成指令的数量，加速比指采用流水线的速度和不采用流水线速度之比</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在流水线基础上，还可以采用流水线的多发、超流水和超长指令字等技术提升效率</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JZ_13.png" alt="指令流水"></p><h4 id="3-3控制器设计"><a href="#3-3控制器设计" class="headerlink" title="3.3控制器设计"></a>3.3控制器设计</h4><p><strong>①引言</strong></p><blockquote><p><strong>微操作</strong>：在<strong>指令解释过程</strong>中由<strong>控制单元</strong>发出的<strong>控制信号</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 微操作可采用同步控制、异步控制，类似于总线的同步通信和异步通信</div><blockquote><p>还可采用<strong>联合控制</strong>，对于<strong>大部分微操作</strong>采用<strong>同步控制</strong>，对于<strong>很难确定完成时间</strong>的微操作采用<strong>异步操作</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将可以并行的微操作安排在同一个时钟周期中，在一个时钟周期先后执行两个较短的微操作以提升效率</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 微操作之间有先后顺序，不能随意更改</div><blockquote><p><strong>时钟信号</strong>：由<strong>时序电路</strong>产生，每个<strong>时钟脉冲</strong>对应一个<strong>时钟周期</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一个时钟周期可以产生一个或一组可以并行的微操作命令</div><blockquote><p><strong>标志信息</strong>：表明<strong>CPU的状态</strong></p></blockquote><p><strong>②组合逻辑设计</strong></p><blockquote><p><strong>设计思路</strong>：根据<strong>每个控制信号</strong>的<strong>产生条件</strong>，写出其<strong>逻辑表达式</strong>，载转化为对应<strong>逻辑电路</strong>即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 控制信号的产生条件指收到的指令操作码、时钟信号和标志信息等，在对应时间收到对应信息便发出对应控制信号</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 组合逻辑设计全部由硬件实现，速度非常快</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 较为复杂，且兼容性较差，新增加一个指令，需要修改与之相关的所有微操作的逻辑电路</div><p><strong>③微程序设计</strong></p><blockquote><p><strong>设计思路</strong>：使用<strong>一串0/1序列</strong>记录<strong>一个时钟周期中执行的微操作</strong>，即<strong>微指令</strong>，按<strong>时间周期顺序</strong>排列构成<strong>微程序</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一条机器指令对应一个微程序，调用微程序，即可在每个是时钟周期发出对应控制信号</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 根据IR中的操作码形成微程序的首地址，每条微指令还会记录下一条微指令定址</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
            <tag> 《计算机组成原理》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（下）</title>
      <link href="/2023/12/10/ji-suan-ji-wang-luo-xia/"/>
      <url>/2023/12/10/ji-suan-ji-wang-luo-xia/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（二）"><a href="#计算机网络（二）" class="headerlink" title="计算机网络（二）"></a>计算机网络（二）</h1><h2 id="计算机网络进阶"><a href="#计算机网络进阶" class="headerlink" title="计算机网络进阶"></a>计算机网络进阶</h2><h3 id="1-网络层"><a href="#1-网络层" class="headerlink" title="1.网络层"></a>1.网络层</h3><h4 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h4><p><strong>①任务</strong></p><blockquote><p>实现<strong>数据包</strong>在<strong>各个网络之间</strong>的传输</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通过IP数据报传递源IP地址和目的IP地址等信息</div><p><strong>②IP地址</strong></p><blockquote><p><strong>因特网</strong>给<strong>每台主机/路由器的每个接口</strong>分配的<strong>全世界</strong>范围内<strong>唯一的标识符</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要分为网络号和主机号两部分，前者用于标识不同网络，后者用于标识网络下的不同接口</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 与MAC地址不同，传输过程中，源IP地址和目的ip地址始终保持不变</div><blockquote><p>如一个<strong>主机A</strong>经过<strong>路由B</strong>发送给<strong>主机C</strong>，<code>IP源地址:目的IP地址</code>在<strong>两段链路</strong>中均为<code>IPA:IPC</code></p></blockquote><p><strong>③地址解析协议APR</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 基于APR协议根据IP地址找到对应的MAC地址</div><blockquote><p><strong>每台主机</strong>都有一个<strong>APR高速缓存表</strong>，记录了<strong>其他主机</strong>的<strong>IP地址</strong>和<strong>MAC地址</strong>的<strong>对应关系</strong></p></blockquote><blockquote><p>若<strong>发送方</strong>无法在<strong>APR高速缓存表</strong>中<strong>根据IP地址</strong>到<strong>接受方</strong>的<strong>MAC地址</strong>，则发送<strong>请求报文</strong>给<strong>其他所有主机</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 请求报文包含了发送方的IP地址和MAC地址，以及接收方的IP地址</div><blockquote><p><strong>接收方</strong>接收到<strong>请求报文</strong>后，将<strong>发送方的IP地址和MAC地址</strong>记录到自己的<strong>APR高速缓存表</strong>中，并给其发送<strong>响应报文</strong>，<strong>发送方</strong>接受到<strong>响应报文</strong>后其<strong>记录</strong>下来并<strong>使用</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 响应报文包含接收方的IP地址和MAC地址</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> APR协议不能跨网络使用</div><hr><h4 id="1-2IP地址应用"><a href="#1-2IP地址应用" class="headerlink" title="1.2IP地址应用"></a>1.2IP地址应用</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以IPv4地址为例</div><p><strong>①表示</strong></p><blockquote><p><strong>IPv4地址</strong>本质上是<strong>一串32位的比特</strong>，将<strong>每8位作为一组</strong>，转化为<strong>十进制</strong>并<strong>使用<code>.</code>隔开</strong></p></blockquote><p><strong>②编址方式</strong></p><blockquote><p><strong>分类编址</strong>：将<strong>IP地址</strong>分为<strong>几类</strong>，<strong>格式不同</strong>，分配给<strong>不同的接口</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要是网络号和主机号的占比不同，从而导致可指派的网络数量和每个网络可分配的IP地址不同</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 分类编址并不灵活，导致一些分类使用较少，使得地址无法被充分利用</div><blockquote><p><strong>划分子网</strong>：在<strong>分类编址的基础</strong>上，将<strong>主机号的一部分</strong>作为<strong>子网号</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 子网掩码的格式决定借用几位作为子网号</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_6.png" alt="子网掩码"></p><blockquote><p><strong>无分类编址</strong>：在<strong>IPv4地址后</strong>加上<code>/[数字]</code>，标识<strong>网络号前缀所占比特数量</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 依旧通过子网掩码计算对应的网络号</div><p><strong>③应用规划</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将IPv4地址块划分为几个小的地址块分配给不同网络</div><blockquote><p><strong>定长的子网掩码</strong>：使用<strong>同一个子网掩码</strong>划分子网</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 每个子网所分配的IP地址数量相同，容易造成IP地址的浪费</div><blockquote><p><strong>变长的子网掩码</strong>：使用<strong>不同子网掩码</strong>划分子网</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 根据每个网络所需的IP地址数量决定主机号位数，从而决定子网掩码的格式</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 子网掩码只是一种划分方法</div><hr><h4 id="1-3IP数据报的传递"><a href="#1-3IP数据报的传递" class="headerlink" title="1.3IP数据报的传递"></a>1.3IP数据报的传递</h4><p><strong>①路由器</strong></p><blockquote><p><strong>路由器</strong>的<strong>不同接口</strong>连接<strong>不同网络</strong>，接口的<strong>IP地址</strong>也被称为<strong>默认网关</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个路由器都会在路由表中记录其接口的IP地址，即与其相连的网络信息，并将这些信息传递给与之相连的路由器</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 路由器详细记录自身的接口的IP地址信息，粗略记录与之相连的路由器接口的IP地址信息</div><blockquote><p><strong>路由聚合</strong>：记录<strong>其他路由器</strong>的<strong>信息</strong>时，寻找其路由表<strong>所有表项的共同前缀</strong>，并记录在<strong>一个表项中</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_7.png" alt="路由聚合"><br><strong>②过程概述</strong></p><blockquote><p>若<strong>发送方</strong>和<strong>接收方</strong>处于<strong>同一网络</strong>，<strong>直接转发</strong>即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将发送方和接收方IP地址与一方地址掩码相与，若结果相同，则两者在同一网络</div><blockquote><p>若两者<strong>不在同一网络</strong>，则在<strong>路由表</strong>中查找<strong>目的网络</strong>，将其<strong>转发</strong>到对应<strong>接口/路由器</strong>，从而传递到<strong>对应网络</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将目的地址，和表项的地址掩码相与，若结果和表项网络地址一致，则找到目的网络</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_8.png" alt="IP数据报的传递"></p><hr><h4 id="1-4路由选择协议"><a href="#1-4路由选择协议" class="headerlink" title="1.4路由选择协议"></a>1.4路由选择协议</h4><p><strong>①引言</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了实现信息在路由器之间传递，需要向路由表中填充信息，包含目的网络地址、对应接口和辅助信息</div><blockquote><p><strong>静态路由配置</strong>：<strong>人工配置</strong>网络路由</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 开销小，但是不能及时适应网络状态变化，一般只在小规模网络中使用</div><blockquote><p><strong>动态路由配置</strong>：通过<strong>路由选择协议</strong>自动获取<strong>路由信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将因特网分为多个自治系统AS，系统内采用内部网关协议进行路由选择，系统之间采用外部网关协议进行路由选择</div><p><strong>②路由信息协议RIP</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一种内部网关协议，将路由器到直连网络的距离定义为1，到非直连网络的距离定义为经过的路由器数目加一</div><blockquote><p><strong>一开始</strong>，路由器只知道<strong>自己到直连网络的距离</strong>为<code>1</code></p></blockquote><blockquote><p><strong>每个路由器</strong>和<strong>相邻路由器</strong>周期性<strong>交换信息</strong>并<strong>更新路由表</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当接收到的路由信息中，有新的/更好的路由信息，则添加/替换</div><blockquote><p>经过<strong>若干次交换和更新</strong>后，<strong>每个路由器</strong>都知道<strong>到达本AS内各个网络的最短距离</strong>和<strong>下一跳地址</strong></p></blockquote><p><strong>③开放最短路径优先OSPF协议</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一种内部网关协议，用某一指标（距离、带宽和时延等）描述链路</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 为了适应更大的网络，可以将AS划分为更小的区域进行管理</div><blockquote><p><strong>每个路由器</strong>都会记录其<strong>相邻路由器</strong>，并通过<strong>周期性发送问候分组</strong>维护</p></blockquote><blockquote><p><strong>每个路由器</strong>将其到<strong>直连网络</strong>和<strong>邻居路由器</strong>的<strong>链路状态（LSA）</strong>发送给<strong>其他所有路由器</strong></p></blockquote><blockquote><p><strong>每个路由器</strong>都有一个<strong>数据链路状态库LSDB</strong>存储<strong>LSA</strong>，最后<strong>LSDB</strong>将存储<strong>所有链路信息</strong></p></blockquote><blockquote><p><strong>每个路由器</strong>基于<strong>LSDB</strong>进行<strong>最短路径优先</strong>计算，构建出<strong>各自到达其他路由器的最短路径</strong>，从而构建各自的<strong>路由表</strong></p></blockquote><p><strong>④边界网关协议BGP</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一种外部网关协议，由于不同的AS路由度量标准不一，只能尽力寻找一条能达到目的AS的相对较好的路由</div><blockquote><p><strong>每个AS</strong>都有<strong>一个路由器</strong>作为<strong>BGP发言人</strong>，<strong>不同的AS</strong>通过各自的<strong>BGP发言人</strong>连接</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> BGP发言人除了运行BGP协议，还需要运行其所在AS的内部网关协议</div><blockquote><p><strong>BGP发言人</strong>之间通过建立<strong>TCP连接</strong>交换<strong>路由信息</strong>，并从中找出<strong>到达各自自治系统</strong>的<strong>不存在回路</strong>的路由</p></blockquote><hr><h4 id="1-5虚拟专用网VPN"><a href="#1-5虚拟专用网VPN" class="headerlink" title="1.5虚拟专用网VPN"></a>1.5虚拟专用网VPN</h4><p><strong>①引言</strong></p><blockquote><p><strong>多个主机</strong>使用<strong>同一个公有IP地址</strong>，形成一个<strong>专用网</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> IP地址可分为专用地址和共用地址，专用地址无需申请即可使用，同时也不是唯一的</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 专用网的公有地址通常对应的是其中的一个路由器接口</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 使用专用地址的主机无法在因特网上通信，只能在专用网内通信，且专用网外的主机无法主动联系专用网内的主机</div><p><strong>②工作原理</strong></p><blockquote><p>若只在<strong>专用网内通信</strong>，则使用<strong>专用地址</strong>即可</p></blockquote><blockquote><p>若需要在<strong>因特网</strong>上进行<strong>数据传输</strong>，<strong>发送方</strong>对数据报<strong>加密</strong>并传递给<strong>发送方路由器</strong></p></blockquote><blockquote><p><strong>接收方路由器</strong>接收到后，<strong>解密</strong>数据报，并<strong>传递</strong>给<strong>对应专用网主机</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若需要访问专用网，则需要接入因特网访问其公有地址</div><p><strong>③网络地址转换NAT</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 有些专用网路由器中不止一个公用IP地址，但是远少于其专用地址，便于主机上网</div><blockquote><p>当<strong>专用网一台主机</strong>需要<strong>接入因特网</strong>时，根据其<strong>专用地址</strong>从<strong>路由器的公用IP地址</strong>中<strong>申请一个</strong>用于互联网通信</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 这样，专用地址和共用地址为一对一的关系，效率较低</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用运输层的端口号和IP地址进行转换，这样一个公用地址可以对应多个专用地址</div><hr><h3 id="2-运输层"><a href="#2-运输层" class="headerlink" title="2.运输层"></a>2.运输层</h3><h4 id="2-1概述"><a href="#2-1概述" class="headerlink" title="2.1概述"></a>2.1概述</h4><p><strong>①任务</strong></p><blockquote><p>为运行在<strong>不同主机</strong>上的<strong>进程</strong>提供直接的<strong>通信服务</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 网络通信的最终实体还是进程而非主机</div><p><strong>②端口号</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 由于不同操作系统的进程标识符不同，故统一采用16比特的端口号区分不同进程</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 端口号只有本地意义，不同计算机的相同端口号没有联系</div><blockquote><p><strong>熟知端口号</strong>：<code>0~1023</code>，分配给了TCP/IP体系中<strong>最重要的应用协议</strong>，如<strong>HTTP</strong>使用<code>80</code>，<strong>DNS</strong>使用<code>53</code></p></blockquote><blockquote><p><strong>登记端口号</strong>：<code>1024~49151</code>，为<strong>没有熟知端口号</strong>的<strong>应用程序（windows桌面应用）</strong>使用，需要<strong>在IANA机构登记</strong>以防止重复</p></blockquote><blockquote><p><strong>短暂端口号</strong>：<code>49152~65535</code>，留给<strong>客户进程（如浏览器）</strong>选择<strong>短暂使用</strong>，</p></blockquote><p><strong>③UDP和TCP</strong></p><blockquote><p><strong>UDP协议</strong>：支持<strong>单播</strong>、<strong>多播</strong>和<strong>广播</strong>，可以<strong>随时</strong>发送数据，提供<strong>不可靠传输</strong>服务</p></blockquote><blockquote><p><strong>TCP协议</strong>：<strong>仅仅</strong>支持<strong>单播</strong>，需要<strong>先建立连接</strong>然后<strong>发送数据</strong>，<strong>发送完数据</strong>后还需要<strong>释放连接</strong>，提供<strong>可靠传输</strong>服务</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> UDP以应用报文为单位进行封装，而TCP将应用报文划分为多个字节流，从发送缓存取出一部分或全部字节进行封装</div><p><strong>④TCP报文段首部格式</strong></p><blockquote><p><strong>源端口</strong>：标识<strong>发送</strong>TCP报文段的<strong>进程</strong></p></blockquote><blockquote><p><strong>目的端口</strong>：标识<strong>接收</strong>TCP报文段的<strong>进程</strong></p></blockquote><blockquote><p><strong>序号</strong>：指出TCP报文段<strong>数据载荷第一个字节</strong>的<strong>序号</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该序号指的时其再所有数据中的位置，而不是在TCP报文段的位置</div><blockquote><p><strong>确认号</strong>：指出<strong>期望接收</strong>到对方<strong>下一个TCP报文段的数据载荷第一个字节的序号</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 同时也是对之前受到数据的确认，若确认号为n，表示序号为n-1前的数据都被正确接收</div><blockquote><p><strong>ACK</strong>：当该位为<code>1</code>，<strong>确认号有效</strong>，若为<code>0</code>，则<strong>无效</strong></p></blockquote><blockquote><p><strong>SYN</strong>：TCP<strong>建立连接</strong>时<strong>同步序号</strong></p></blockquote><blockquote><p><strong>FIN</strong>：用于<strong>释放TCP连接</strong>，为<code>1</code>时表示为<strong>TCP连接释放报文段</strong></p></blockquote><blockquote><p><strong>RST</strong>：用于<strong>复位TCP连接</strong>，为<code>1</code>时表示<strong>TCP连接出现异常</strong>，需要<strong>释放连接并重新建立</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> RST置1还可用于拒绝一个非法的报文段或者拒绝打开一个TCP连接</div><blockquote><p><strong>窗口</strong>：指出<strong>发送方</strong>的<strong>接收窗口长度</strong></p></blockquote><blockquote><p><strong>填充字段</strong>：由于有些内容<strong>长度可变</strong>，需要使用填充<strong>使报文段首部能被4整除</strong></p></blockquote><hr><h4 id="2-2TCP连接"><a href="#2-2TCP连接" class="headerlink" title="2.2TCP连接"></a>2.2TCP连接</h4><p><strong>①创建</strong></p><blockquote><p><strong>被请求方</strong>首先<strong>创建传输控制块</strong>，随后进入<strong>监听状态</strong>，称为<strong>被动打开连接</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 用于存储TCP连接的重要信息，如TCP连接表等</div><blockquote><p><strong>请求方</strong>建立<strong>传输控制块</strong>，随后发送<strong>TCP连接请求报文段</strong>，并进入<strong>同步已发送状态</strong>，称为<strong>主动打开连接</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> TCP连接请求报文段SYN被置为1，表明为TCP连接请求报文段，不能携带数据，序号初始化为x</div><blockquote><p><strong>被请求方</strong>接收到<strong>TCP连接请求报文段</strong>后，如果<strong>同意建立连接</strong>，则发送<strong>TCP连接请求确认报文段</strong>，进入<strong>同步已接收状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该报文段SYN和ACK置为1，确认号为x+1，表示对TCP连接请求报文段的确认，序号初始化为y</div><blockquote><p><strong>请求方</strong>接收到<strong>TCP连接请求确认报文段</strong>后，发送<strong>二次确认报文段</strong>，进入<strong>连接建立状态</strong>，<strong>被请求方</strong>接收到<strong>二次确认报文段</strong>之后也进入<strong>连接建立状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该报文段ACK置为1，确认号为y+1，表示对TCP连接请求确认报文段的确认，序号被设为x+1</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 二次确认报文段用于防止失效的TCP连接请求报文段突然又传送到被接受方，导致其进入同步已接受状态，引发错误</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_9.png" alt="TCP连接的建立"><br><strong>②释放</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 两方都可释放连接，以请求方主动释放连接为例</div><blockquote><p><strong>请求方</strong>发送<strong>TCP连接释放报文段1</strong>，进入<strong>终止等待1状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该报文段FIN，ACK置1，声明其为TCP连接释放报文段1，设置序号u以及确认号为v</div><blockquote><p><strong>被请求方</strong>接收到<strong>TCP连接释放报文段1</strong>之后，发送<strong>TCP确认报文段1</strong>，并进入<strong>关闭等待状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该报文段ACK置1，设置序号v以及确认号u+1</div><blockquote><p><strong>请求方</strong>接收到<strong>TCP确认报文段1</strong>之后，进入<strong>终止等待2状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 此时被请求方还能向请求方发送数据</div><blockquote><p><strong>被请求方完成数据通信</strong>，进程通知其<strong>释放连接</strong>，发送<strong>TCP连接释放报文段2</strong>，并进入<strong>最后确认状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该报文段FIN，ACK置1，设置序号w，因为可能又发送了一些数据，设置确认号u+1，对一开始的重复确认</div><blockquote><p><strong>请求方</strong>接收到<strong>TCP连接释放报文段2</strong>后，发送<strong>TCP确认报文段</strong>，等待<strong>2倍MSL时间</strong>后进入<strong>关闭状态</strong>，<strong>被请求方</strong>接收到<strong>TCP确认报文段2</strong>后进入<strong>关闭状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该报文段ACK置1，设置序号u+1以及确认号w+1，对TCP连接释放报文段2进行确认</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> MSL为最长报文寿命，等待这么长时间防止确认报文段丢失</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_11.png" alt="TCP连接的释放"></p><hr><h4 id="2-3TCP功能"><a href="#2-3TCP功能" class="headerlink" title="2.3TCP功能"></a>2.3TCP功能</h4><p><strong>①流量控制</strong></p><blockquote><p><strong>控制</strong>发送方的<strong>发送速率</strong>，<strong>便于</strong>接收方<strong>接收</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 接收方根据自己接收窗口的大小动态调整发送方的发送窗口，只有落入发送窗口的数据可以被发送</div><p><strong>②拥塞控制</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 拥塞指网络中某一资源供不应求，会导致网络的性能下降，使用拥塞窗口限制发送窗口大小</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 发送窗口通常取拥塞窗口和接收窗口的小值</div><blockquote><p><strong>慢开始</strong>：<strong>一开始</strong>,<strong>拥塞窗口</strong>大小为<code>1</code>，并随着<strong>发送轮次</strong>的<strong>增大</strong>而<strong>指数级增大</strong></p></blockquote><blockquote><p><strong>拥塞避免</strong>：当<strong>拥塞窗口</strong>增大到<strong>慢开始门限</strong>，不再<strong>指数级增长</strong>，改为<strong>线性增长</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当重传计时器超时，即视为拥塞，慢开始门限变为拥塞时拥塞窗口的一半，并将拥塞窗口变为1，重新开始以上流程</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 然后，重传计时器超时可能并不代表拥塞，而是对应报文丢失，会降低网络的性能</div><blockquote><p><strong>快重传</strong>：<strong>接收方</strong>一旦<strong>接收到数据</strong>就<strong>立即</strong>发送对应的<strong>确认分组</strong>，即使收到了<strong>失序的分组</strong>，当<strong>重复</strong>收到<strong>同一个分组的三个确认分组</strong>，<strong>立即重传</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 排除了其他原因导致的重传计时器超时</div><blockquote><p><strong>快恢复</strong>：执行<strong>快重传</strong>后，<strong>慢开始门限</strong>和<strong>拥塞窗口</strong>调整为<strong>当前窗口的一半</strong>，并执行<strong>拥塞避免算法</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_10.png" alt="拥塞控制"><br><strong>③超时重传</strong></p><blockquote><p><strong>重传时限</strong>最好<strong>略大于</strong>数据的<strong>往返时间RTT</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不同数据经过的网络不同，往返时间也不同，将每次测量的到的RTT样本加权计算并更新平均往返时间RTT</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 报文段重传会导致样本失效，若仅仅丢弃该样本，可能导致重传时限无法更新导致被反复重传</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 所以每次报文段重传适当增大重传时限</div><p><strong>④可靠传输</strong></p><blockquote><p><strong>发送方</strong>：只有落入<strong>发送窗口</strong>的<strong>字节</strong>才能被<strong>发送</strong>，当收到了<strong>新的确认分组</strong>，<strong>发送窗口后沿向前移动</strong>到<strong>确认号位置</strong>，若<strong>重复收到三次同样的确认号</strong>，则<strong>重发对应的字节</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 发送窗口前沿会受到后沿和窗口大小的影响，可能向前移动，不动甚至是收缩</div><blockquote><p><strong>接收方</strong>：只有落入<strong>接收窗口</strong>的<strong>字节</strong>才能被<strong>接收</strong>，每当<strong>收到数据</strong>，会发送<strong>确认分组</strong>，确认号为<strong>最小的失序字节序号</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 易知可靠传输主要依靠接收方的确认分组实现，所以除了每次收到数据，每隔一段时间也要发送确认分组</div><hr><h3 id="3-应用层"><a href="#3-应用层" class="headerlink" title="3.应用层"></a>3.应用层</h3><h4 id="3-1引言"><a href="#3-1引言" class="headerlink" title="3.1引言"></a>3.1引言</h4><p><strong>①任务</strong></p><blockquote><p>通过<strong>应用进程的交互</strong>，实现<strong>特定网络应用</strong>，也是<strong>设计和建设计算机网络</strong>的<strong>最终目的</strong></p></blockquote><p><strong>②进程关系</strong></p><blockquote><p><strong>客户/服务器方式</strong>：进程分为<strong>客户端</strong>和<strong>服务器端</strong>，<strong>客户端</strong>向<strong>服务器端请求服务</strong>，<strong>服务器端收到请求后</strong>为其<strong>提供服务</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 服务器端总是处于运行状态，并具有固定的端口号，等待客户端的请求</div><blockquote><p><strong>对等方式</strong>：各个进程是<strong>对等的</strong>，既<strong>请求服务</strong>，也<strong>提供服务</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可扩展性好，成本低</div><hr><h4 id="3-2域名系统DNS"><a href="#3-2域名系统DNS" class="headerlink" title="3.2域名系统DNS"></a>3.2域名系统DNS</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将域名转化为IP地址，这样就可以通过便于记忆的域名寻找对应主机了</div><p><strong>①域名结构</strong></p><blockquote><p>由<strong>多级域名</strong>组成，<strong>级别越低</strong>的域名写在<strong>越左边</strong>，使用<code>.</code><strong>隔开</strong></p></blockquote><blockquote><p><strong>顶级域名</strong>：<strong>国家顶级域名</strong>、<strong>通用顶级域名</strong>和<strong>反向域</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如cn表示中国，com表示企业公司，org表示非营利性组织</div><blockquote><p><strong>二级域名</strong>：由<strong>国家自行决定</strong>，我国将其分为<strong>类别域名</strong>和<strong>行政区域名</strong>两大类</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 二级域名以下还能层层划分，表现为一种树形结构</div><p><strong>②域名服务器</strong></p><blockquote><p><strong>根域名服务器</strong>：记录所有<strong>顶级域名服务器</strong>的<strong>域名</strong>以及<strong>IP地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 二级域名以下还能层层划分，表现为一种树形结构</div><blockquote><p><strong>顶级域名服务器</strong>：记录再<strong>该顶级域名服务器</strong>注册的所有<strong>二级域名</strong></p></blockquote><blockquote><p><strong>权限域名服务器</strong>：记录<strong>某个区域</strong>的<strong>所有主机</strong>的域名</p></blockquote><blockquote><p><strong>本地域名服务器</strong>：当<strong>一个主机</strong>发出<strong>DNS请求</strong>时，先传送到<strong>本地域名服务器</strong>，由其<strong>转发</strong>到<strong>以上三种服务器</strong>中</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 本地域名服务器起到代理的作用，需要直接配置在使用该域名服务器的主机上</div><p><strong>③工作原理</strong></p><blockquote><p>当访问<strong>域名</strong>时，<strong>用户主机</strong>会在<strong>自己的DNS高速缓存</strong>中寻找域名<strong>对应的IP地址</strong></p></blockquote><blockquote><p>若没有，发送<strong>DNS查询报文</strong>给<strong>本地域名服务器</strong>，<strong>本地域名服务器</strong>在<strong>上述三种域名服务器</strong>找到<strong>对应域名</strong>后返回给<strong>主机</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 本地域名服务器向上层的查询方式可分为递归查询和迭代查询两种，递归查询代价太大，简单介绍迭代查询</div><blockquote><p><strong>本地域名服务器</strong>先向<strong>根域名服务器</strong>查询，得到对应的<strong>顶级域名服务器</strong>地址，随后从对应<strong>顶级域名服务器</strong>获得对应<strong>权限域名服务器</strong>地址，最后从<strong>权限域名服务器</strong>查找到<strong>目的域名的IP地址</strong></p></blockquote><hr><h4 id="3-3电子邮件"><a href="#3-3电子邮件" class="headerlink" title="3.3电子邮件"></a>3.3电子邮件</h4><p><strong>①组成</strong></p><blockquote><p><strong>用户代理</strong>：<strong>用户</strong>与<strong>电子邮件系统</strong>的接口，即<strong>客户端软件</strong></p></blockquote><blockquote><p><strong>邮件服务器</strong>：<strong>电子邮件系统</strong>的<strong>基础设施</strong>，用于<strong>发送</strong>和<strong>接收邮件</strong>，并<strong>维护用户的邮箱</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 邮件服务器可以看做为多个邮箱的集合</div><p><strong>②工作原理</strong></p><blockquote><p><strong>发送方</strong>使用<strong>用户代理</strong>通过<strong>邮件发送协议</strong>向<strong>发送方邮件服务器</strong>发送邮件</p></blockquote><blockquote><p><strong>发送方邮件服务器</strong>通过<strong>邮件发送协议</strong>向<strong>接收方邮件服务器</strong>发送邮件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 常用的邮件发送协议为SMTP，两方建立TCP连接后，通过SMTP命令和应答报文段实现通信</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> SMTP协议只能传送ASCLL码文本数据，不能传送二进制对象</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过MIME协议将非ASCLL码数据转化为ASCLL码数据，再使用SMTP协议进行传输</div><blockquote><p><strong>接收方</strong>使用<strong>用户代理</strong>通过<strong>邮件接收协议</strong>从<strong>接收方邮件服务器</strong>读取邮件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 邮件读取协议有POP和IMAP，前者只能从邮件服务器下载文件，后者可以在自己的计算机上操控邮件服务的邮箱</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若发送时采用了MIME，接收时也需要使用MIME将ASCLL码文本数据转化为非ASCLL码文本数据</div><hr><h4 id="3-4万维网"><a href="#3-4万维网" class="headerlink" title="3.4万维网"></a>3.4万维网</h4><p><strong>①引言</strong></p><blockquote><p><strong>定义</strong>：一个<strong>大规模</strong>、<strong>联机式</strong>的<strong>信息储藏所</strong>，是运行在因特网上的一个<strong>分布式应用</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> HTML文档描述网页的结构和内容，CSS文档描述网页的样式，JavaScript文档控制网页的行为</div><blockquote><p><strong>网页基本组成</strong>：<strong>HTML文档</strong>、<strong>CSS文档</strong>、<strong>JavaScript文档</strong>以及一些<strong>资源文件（如图片）</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> HTML文档描述网页的结构和内容，CSS文档描述网页的样式，JavaScript文档控制网页的行为</div><blockquote><p><strong>URL资源定位符</strong>：指明<strong>资源的位置</strong>，<strong>格式</strong>为<code>[协议]://[主机]:[端口]/[路径]</code></p></blockquote><p><strong>②HTTP协议</strong></p><blockquote><p><strong>定义</strong>：万维网<strong>客户端</strong>和<strong>服务端</strong>的<strong>通信格式</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 客户端和服务端首先建立TCP连接，客户端向服务端发送请求报文，服务端返回响应报文</div><blockquote><p><strong>请求报文</strong>：主要由<strong>一个请求行</strong>和<strong>多个首部行</strong>组成，以<strong>换行结尾（很少会在换行后跟实体主体）</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 请求行指明方法、URL和HTTP版本，首部行指明请求细节</div><blockquote><p><strong>响应报文</strong>：由<strong>一个状态行</strong>和<strong>多个首部行</strong>，以<strong>换行结尾（有时会在换行后跟实体主体）</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 状态行表明返回结果，如接受请求、请求错误或找不到页面等，首部行和请求报文对应</div><p><strong>③工作原理</strong></p><blockquote><p>在<strong>浏览器中输入域名</strong>，<strong>客户端</strong>和<strong>服务端</strong>建立<strong>TCP连接</strong>，客户端发送<strong>HTTP请求报文</strong>给对应的<strong>服务端</strong>，<strong>服务端</strong>返回<strong>HTTP响应报文</strong>，<strong>浏览器</strong>对<strong>HTTP响应报文</strong>进行<strong>解析</strong>，获得<strong>网站内容</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 浏览器的内核是渲染引擎，不同浏览器的显示效果不同</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将最近的一些请求和响应存放在web缓存中，若新请求与web缓存某请求相同，直接返回对应的响应，不再建立连接</div><p><strong>④Cookie</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对无状态的HTTP进行状态化</div><blockquote><p>当<strong>用户</strong>的浏览器进程<strong>首次</strong>向<strong>某网页服务端</strong>发送<strong>HTTP请求报文</strong>，<strong>该网页服务端</strong>会创建一个<strong>cookie识别码</strong>并<strong>记录用户访问该网站的各种信息</strong></p></blockquote><blockquote><p><strong>该网页服务端</strong>通过<strong>HTTP响应报文</strong>传回该<strong>Cookie识别码</strong>，<strong>客户端</strong>将其记录在对应的<strong>Cookie文件</strong>中</p></blockquote><blockquote><p>下次用户<strong>再访问该网页</strong>，会向<strong>HTTP请求报文</strong>中添加对应的<strong>Cookie识别码</strong>，<strong>网页服务端</strong>识别<strong>Cookie识别码</strong>后<strong>根据记录信息</strong>返回<strong>特定的网页</strong></p></blockquote><hr><h4 id="3-5其他常见协议"><a href="#3-5其他常见协议" class="headerlink" title="3.5其他常见协议"></a>3.5其他常见协议</h4><p><strong>①动态主机配置协议DHCP</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 各个主机从DHCP服务器请求IP地址、子网掩码、默认网关等网络配置信息</div><blockquote><p><strong>DHCP客户端</strong>广播发送<strong>DHCP发现报文</strong>，其中包含<strong>事务ID</strong>和<strong>客户端的MAC地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因为DHCP客户并不知道网络中有多少个DHCP服务器，故广播发送</div><blockquote><p><strong>DHCP服务器端</strong>接收到<strong>DHCP发现报文</strong>之后，根据<strong>客户端的MAC地址</strong>查找从<strong>数据库</strong>中查找对应的<strong>配置信息</strong>，如果<strong>没有找到</strong>则采用<strong>默认配置信息</strong>，并<strong>广播</strong>发送<strong>DHCP提供报文</strong>，其中包含<strong>事务ID</strong>和<strong>网络配置信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 服务端会采用ARP协议检测分配的IP是否被占用再分配</div><blockquote><p><strong>客户端</strong>接收<strong>DHCP提供报文</strong>，并根据<strong>事务ID</strong>判断<strong>是否属于自己</strong>，若属于，则<strong>接收并使用</strong>其中<strong>配置信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若网络中有多个DHCP服务端，则可能受到多个DHCP提供报文，选择最先到达的</div><blockquote><p><strong>DHCP客户端</strong>广播发送<strong>DHCP请求报文</strong>，其中包含<strong>事务ID</strong>、<strong>客户端的MAC地址</strong>和<strong>选择的服务端的IP地址</strong>等信息</p></blockquote><blockquote><p><strong>选择的DHCP服务端</strong>广播发送<strong>DHCP确认报文</strong>，<strong>客户端</strong>接收后就<strong>可以使用相关网络配</strong>置了</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 服务端向客户端发送报文均采用广播发送，因为直到现在客户端才有自己的IP地址</div><p><strong>②文件传送协议FTP</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件有存取权限</div><blockquote><p><strong>FTP客户端</strong>和<strong>FTP服务端</strong>建立<strong>TCP连接</strong>，并传输<strong>FTP相关控制命令</strong></p></blockquote><blockquote><p>当两者<strong>有数据需要传输时</strong>，再<strong>另外</strong>建立一个<strong>TCP连接</strong>作为<strong>数据通道</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> FTP常常用于在计算机之间批量传输文件，如XFTP软件</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 《计算机网络自顶向下》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络（上）</title>
      <link href="/2023/12/10/ji-suan-ji-wang-luo-shang/"/>
      <url>/2023/12/10/ji-suan-ji-wang-luo-shang/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络（上）"><a href="#计算机网络（上）" class="headerlink" title="计算机网络（上）"></a>计算机网络（上）</h1><h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1基本概念"><a href="#1-1基本概念" class="headerlink" title="1.1基本概念"></a>1.1基本概念</h4><p><strong>①网络</strong></p><blockquote><p>由若干<strong>节点</strong>和连接节点的<strong>链路</strong>组成</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 按照拓扑类型可分为总线型、星型、环形和网状型</div><p><strong>②互联网</strong></p><blockquote><p><strong>多个网络</strong>由<strong>路由器</strong>互联，形成<strong>互联网</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因特网是最大的互联网，使用TCP/IP协议</div><p><strong>③ISP</strong></p><blockquote><p><strong>因特网服务提供商</strong>，如中国<strong>电信</strong>、中国<strong>联通</strong>等</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 类似于树结构，只要有子节点就是父节点，所以个人也可以成为某种意义上的ISP</div><p><strong>④分组交换</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 计算机网络传输信息方式</div><blockquote><p>将<strong>数据</strong>分成<strong>多个包</strong>，每个包由<strong>描述信息</strong>和<strong>数据部分</strong>组成</p></blockquote><blockquote><p><strong>路由器</strong>收到包后，<strong>暂时存储</strong>，根据<strong>描述信息</strong>送到<strong>下一个路由器</strong>，直到送到<strong>目标地址</strong></p></blockquote><blockquote><p><strong>目的地址</strong>收到<strong>所有包</strong>后，根据<strong>描述信息</strong>将其<strong>组合到一起</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 无需建立连接、线路利用率高、出错时重发数据量小</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 有转发时延、需要传递额外的信息、出错频率变大</div><p><strong>⑤网络性能指标</strong></p><blockquote><p><strong>速率</strong>：<strong>设备</strong>在<strong>单位时间</strong>传递的<strong>比特数</strong></p></blockquote><blockquote><p><strong>带宽</strong>：<strong>网络</strong>中<strong>一个点</strong>到<strong>另一个点</strong>的<strong>最高速率</strong></p></blockquote><blockquote><p><strong>吞吐量</strong>：<strong>单位时间</strong>内能<strong>通过整个网络</strong>的数据量，受到<strong>带宽</strong>和<strong>速率</strong>的限制</p></blockquote><blockquote><p><strong>时延</strong>：由<strong>发送时延</strong>、<strong>传播时延</strong>和<strong>处理时延</strong>组成</p></blockquote><blockquote><p><strong>利用率</strong>：网络中所有<strong>信道利用率</strong>的<strong>加权平均</strong></p></blockquote><blockquote><p><strong>丢包率</strong>：一定时间内，<strong>丢失的分组</strong>数量占<strong>总分组</strong>数量的<strong>比例</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 利用率最好保持在50%左右，因为利用率越高，时延越大</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当分包出现误码，或者网络拥塞时会被丢弃，主要为后者</div><h4 id="1-2TCP-x2F-IP体系结构"><a href="#1-2TCP-x2F-IP体系结构" class="headerlink" title="1.2TCP/IP体系结构"></a>1.2TCP/IP体系结构</h4><p><strong>①构成</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 真实的TCP/IP结构只有应用层、运输层、网络层和接口层四层，为了方便理解，将接口层拆解为链路层和物理层</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 网络层是核心</div><blockquote><p><strong>应用层</strong>：解决<strong>进程间的交互</strong>问题</p></blockquote><blockquote><p><strong>运输层</strong>：解决<strong>进程</strong>之间<strong>基于网络通信</strong>的问题</p></blockquote><blockquote><p><strong>网络层</strong>：解决多个<strong>分组</strong>在<strong>网络间传输</strong>的问题</p></blockquote><blockquote><p><strong>链路层</strong>：解决<strong>分组</strong>在<strong>一个网络中传输</strong>的问题</p></blockquote><blockquote><p><strong>物理层</strong>：解决使用<strong>何种信号传输比特</strong>的问题</p></blockquote><p><strong>②基本概念</strong></p><blockquote><p><strong>实体</strong>：可以<strong>发送和接收消息</strong>的<strong>硬件</strong>或者<strong>软件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 收发双方相同层次的对应实体为对等实体</div><blockquote><p><strong>协议</strong>：控制两个<strong>对等实体</strong>进行<strong>逻辑通信的规则</strong>，<strong>对等层次</strong>之间交换的<strong>数据包</strong>称为<strong>协议数据单元PDU</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如应用层的HTTP协议，运输层的TCP协议，网络层的IP协议，链路层的CSMA协议，物理层的曼彻斯特编码等</div><blockquote><p><strong>服务</strong>：<strong>下层</strong>给<strong>相邻上层</strong>提供的<strong>功能接口</strong>，<strong>相邻层</strong>之间交换的<strong>数据包</strong>称为<strong>服务数据单元SDU</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相邻两层通过服务访问点交换信息，通过服务原语沟通</div><p><strong>③工作原理概述</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上层层包装，层层读取信息，以用户向一个网站服务器发出访问申请为例</div><blockquote><p><strong>应用层</strong>将<strong>HTTP报文</strong>发送给<strong>运输层</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> HTTP报文用于个人电脑和服务端的通信</div><blockquote><p><strong>运输层</strong>给<strong>HTTP报文</strong>添加<strong>TCP首部</strong>，形成<strong>TCP报文段</strong>，并将其发送给<strong>网络层</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> TCP首部用于区分进程并实现可靠传输</div><blockquote><p><strong>网络层</strong>给<strong>TCP报文段</strong>添加<strong>IP首部</strong>，形成<strong>IP数据报</strong>，并将其发送给<strong>链路层</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> IP首部使其可被路由器转发</div><blockquote><p><strong>链路层</strong>给<strong>IP数据报</strong>添加<strong>ETH首部</strong>和<strong>ETH尾部</strong>，形成<strong>帧</strong>，并将其发送给<strong>物理层</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ETH首部包含了目的地址和源地址，ETH尾部用于检查其是否有误码</div><blockquote><p><strong>物理层</strong>将<strong>帧</strong>转化为<strong>01序列</strong>，添加<strong>前导码</strong>，发送到<strong>下一个端口</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 前导码让下一个端口做好接收准备</div><blockquote><p>运送到<strong>路由器</strong>后，一层一层<strong>读取信息（如从IP首部获得转发端口）</strong>，再一层一层<strong>包装</strong>发送到<strong>下一个端口</strong>，如此往复，直到<strong>到达目的地</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 路由器由于没有进程，所以没有应用端和运输端</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_1.png" alt="TCP/IP体系结构工作原理"></p><h3 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2.物理层"></a>2.物理层</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①协议</strong></p><blockquote><p><strong>比特流传递时</strong>的<strong>描述信息</strong>，可分为<strong>机械特性</strong>、<strong>电气特性</strong>、<strong>功能特性</strong>和<strong>过程特性</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 物理层考虑的是如何在不同的传输媒体上传输数据比特流，传输媒体可分为导引型（如光纤）和非导引型（如wifi）</div><p><strong>②传输方式</strong></p><blockquote><p><strong>串行传输</strong>：一次发送<strong>一个比特</strong><br><strong>并行传输</strong>：一次发送<strong>多个比特</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 计算机内部通信采用并行传输，计算机之间通信采用串行传输</div><blockquote><p><strong>同步传输</strong>：<strong>字节</strong>之间<strong>没有间隔</strong>，需要保证<strong>收发双方时钟同步</strong><br><strong>异步传输</strong>：<strong>字节</strong>之间有<strong>不固定的间隔</strong>，在<strong>每个字节前后</strong>加上<strong>起始位</strong>和<strong>结束位</strong></p></blockquote><h4 id="2-2编码与调制"><a href="#2-2编码与调制" class="headerlink" title="2.2编码与调制"></a>2.2编码与调制</h4><p><strong>①引言</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对于数字信号和模拟信号，编码和调制的含义不同，计算机网络主要使用数字信号，故只介绍数字信号</div><blockquote><p><strong>编码</strong>：<strong>不改变信号性质</strong>，仅仅对<strong>信号波形</strong>进行变换</p></blockquote><blockquote><p><strong>调制</strong>：将<strong>数字信号</strong>的<strong>频率范围搬移到较高的频段</strong>，并<strong>转化为模拟信号</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_2.png" alt="信号传递过程"></p><p><strong>②编码方法</strong></p><blockquote><p><strong>曼彻斯特编码</strong>：在<strong>每个码元</strong>的<strong>中间时刻</strong>发生<strong>跳变</strong>，使用<strong>正负跳变</strong>表示比特</p></blockquote><blockquote><p><strong>差分曼彻斯特编码</strong>：跳变<strong>仅仅表示时钟</strong>，使用<strong>码元开始处电平是否变化</strong>表示比特</p></blockquote><p><strong>③调制方法</strong></p><blockquote><p><strong>基本调制方法</strong>有<strong>调幅</strong>、<strong>调频</strong>和<strong>调相</strong>，但是这样<strong>一个码元</strong>只包含<strong>一个比特信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 采用混合调制方法，如正交振幅调制QAM，一个码元可以表示16种信息</div><h4 id="2-3信道极限容量"><a href="#2-3信道极限容量" class="headerlink" title="2.3信道极限容量"></a>2.3信道极限容量</h4><p><strong>①引言</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当信号通过信道传输时，可能会导致失真，失真严重时将无法识别</div><blockquote><p><strong>影响因素</strong>：<strong>码元传输速率</strong>、<strong>信号传输距离</strong>、<strong>噪声干扰</strong>和<strong>传输媒体质量</strong>等</p></blockquote><p><strong>②奈式准则</strong></p><blockquote><p>为了避免<strong>码间串扰</strong>。<strong>码元传输速率</strong>是有<strong>上限</strong>的</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 奈式准则是理想情况（无噪声），实际上能传输的最高码元速率要远低于奈式准则给出的</div><p><strong>③香农公式</strong></p><blockquote><p>给出了<strong>带宽受限</strong>且有<strong>高斯白噪声干扰</strong>的信道的<strong>极限信息传输速率</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 想要提高信息的传输速率必须采用更好的调制方法和信道的信噪比</div><h3 id="3-链路层"><a href="#3-链路层" class="headerlink" title="3.链路层"></a>3.链路层</h3><h4 id="3-1基本功能"><a href="#3-1基本功能" class="headerlink" title="3.1基本功能"></a>3.1基本功能</h4><p><strong>①包装成帧</strong></p><blockquote><p><strong>帧头</strong>和<strong>帧尾</strong>包含重要的<strong>控制信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要内容为目的地址、源地址和帧校验序列</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果帧的其他部分也包含帧定界标志，需要与真正的帧定界符相区分，如插入“转义字符”</div><p><strong>②差错检测</strong></p><blockquote><p><strong>传输过程</strong>中，<strong>比特</strong>可能发生<strong>反转</strong>或者<strong>丢失</strong>，通过<strong>帧校验序列</strong>检测</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 常用的检测方法为循环冗余检测，两边对数据采用同样的算法，若结果一致则无误码</div><p><strong>③可靠传输</strong></p><blockquote><p>当出现<strong>分组错误</strong>、<strong>分组丢失</strong>、<strong>分组失序</strong>和<strong>分组重复</strong>等错误时，需要发送方<strong>重新发送</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可靠传输不是必须的，通常误码率高时（如无线传输），需要可靠传输服务</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可靠传输这一概念并不局限于链路层</div><h4 id="3-2可靠传输协议"><a href="#3-2可靠传输协议" class="headerlink" title="3.2可靠传输协议"></a>3.2可靠传输协议</h4><p><strong>①停止等待协议SW</strong></p><blockquote><p><strong>接收方</strong>：每次<strong>接收一个分组</strong>，若接收到<strong>正确的分组</strong>，发送<strong>确认分组</strong>，<strong>反之</strong>则发送<strong>否认分组</strong></p></blockquote><blockquote><p><strong>发送方</strong>：每次<strong>发送一个分组</strong>，只有<strong>接收到确认分组</strong>后再<strong>发送下一分组</strong>，接收到<strong>否认分组</strong>则<strong>重新发送</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 成功确认的分组将会从缓存中删除</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用超时计时器以防分组丢失，给分组添加序号防止分组重复和分组迟到</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 该方法的信道利用率较低，因为每次发送一个分组就需要等待一个往返时间</div><p><strong>②回退N帧协议GBN</strong></p><blockquote><p><strong>发送方</strong>：每次<strong>发送N个分组</strong>，若<strong>N个分组均正确</strong>，则发送<strong>下一批分组</strong>，若收到<strong>NAKy否认分组</strong>，则这一批分组中<strong>y以及y之后的分组全部重发</strong></p></blockquote><blockquote><p><strong>接收方</strong>：每次接<strong>收一个分组</strong>并<strong>逐个确认</strong>，若接收到的<strong>第x个分组以及之前的分组全部正确</strong>，则发送<strong>ACKx确认分组</strong>，若<strong>第y个分组发生错误</strong>，则发送<strong>NAKy否认分组</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 每次可以发送多个分组，提高了信道的利用率</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 一个分组的错误会导致后续分组的重传，当信道质量较差时，效率较低</div><p><strong>③选择重传协议SR</strong></p><blockquote><p><strong>发送方</strong>：<strong>可发送的分组范围</strong>称为<strong>发送窗口</strong>，<strong>落入发送窗口</strong>且<strong>没有被发送</strong>的分组会被<strong>发送</strong>，<strong>发送窗口</strong>一直<strong>向前移动</strong>，只有收到<strong>确认分组</strong>的位置才能<strong>顺利通过</strong>，否则会被<strong>卡住（超时或者收到错误分组）</strong>，被<strong>卡住</strong>的地方<strong>重新发送</strong></p></blockquote><blockquote><p><strong>接收方</strong>：<strong>接收的分组范围</strong>称为<strong>接收窗口</strong>，<strong>落入接收窗口</strong>的分组会被<strong>逐个确认</strong>，并发送<strong>对应的信号</strong>，<strong>接收窗口</strong>一直<strong>向前移动</strong>，只有<strong>确认正确</strong>的位置才能<strong>顺利通过</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 减小了错误分组对发送其他分组的影响</div><h4 id="3-3PPP协议"><a href="#3-3PPP协议" class="headerlink" title="3.3PPP协议"></a>3.3PPP协议</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> PPP协议是目前使用最广泛的点对点数据链路层协议</div><p><strong>①构成</strong></p><blockquote><p>对各种<strong>协议数据报</strong>的<strong>封装方法</strong>，即如何<strong>封装成帧</strong></p></blockquote><blockquote><p><strong>链路控制协议LCP</strong>，用于控制<strong>不同数据链路</strong>的连接</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如面向字节的异步链路和面向比特的同步链路</div><blockquote><p><strong>网络控制协议NCPs</strong>，用于<strong>支持</strong>不同的<strong>网络层协议</strong></p></blockquote><p><strong>②帧格式</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 帧头包含标志字段、地址字段、控制字段和协议字段，帧尾包含帧检验序列和标志字段</div><blockquote><p><strong>标志字段</strong>：PPP帧的<strong>定界符</strong>，取值为<code>0x7E</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当数据部分出现标志字段，采用字节填充法或者比特填充法改变其序列，接收方再将其转换回来即可</div><blockquote><p><strong>地址字段</strong>：包含<strong>源MAC地址</strong>和<strong>目的MAC地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> MAC地址是每个接口唯一的标识，也被称为硬件地址/物理地址，地址字段中的MAC地址会随着链路的改变改变</div><blockquote><p>假设从<code>MAC1</code>发送到<code>MAC2</code>再到<code>MAC3</code>，<strong>地址字段</strong>在<strong>两段链路</strong>上分别为<code>MAC1:MAC2</code>和<code>MAC2:MAC3</code></p></blockquote><blockquote><p><strong>控制字段</strong>：</p></blockquote><blockquote><p><strong>协议字段</strong>：指明帧的<strong>数据部分</strong>交给什么<strong>网络协议</strong>处理</p></blockquote><blockquote><p><strong>帧检验序列</strong>：用于<strong>检查</strong>帧是否有<strong>误码</strong></p></blockquote><p><strong>③状态</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_3.png" alt="PPP协议状态"></p><h4 id="3-4共享式局域网"><a href="#3-4共享式局域网" class="headerlink" title="3.4共享式局域网"></a>3.4共享式局域网</h4><p><strong>①概念</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在有线领域，交换式局域网已经取代了共享式局域网，无线领域由于其广播天性采用的依旧是共享式局域网</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 协调多个发送和接收站点对一个共享传输媒体的占用</div><blockquote><p><strong>静态划分信道</strong>：将<strong>信道资源</strong>划分给<strong>不同的用户</strong>，如<strong>频分多址</strong>、<strong>时分多址</strong>和<strong>码分多址</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 该类方法不灵活，通常在无线网络的物理层中使用，而不在数据链路层使用</div><blockquote><p><strong>动态接入控制</strong>：<strong>各个站点</strong>通过<strong>竞争</strong>获得<strong>链路的使用权</strong>，现在<strong>主要采用</strong>的是<strong>随机接入</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当总线空闲时，所有站点都可以发送帧，当两个设备的帧信号在总线上相遇，即发生了碰撞</div><p><strong>②CSMA/CD协议</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要应用于使用广播信道的有线局域网</div><blockquote><p><strong>多址接入MA</strong>：<strong>多个设备</strong>连接在<strong>一条总线</strong>上，<strong>竞争</strong>使用</p></blockquote><blockquote><p><strong>载波监听CS</strong>：每个设备在<strong>发送帧之前</strong>，<strong>检测总线</strong>是否<strong>空闲（有96比特时间）</strong>，如果<strong>有则发送</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 96比特时间为发送96个比特所需要的时间，也称为帧间最小间隔，使得所有站点可以平等的竞争信道，同时也可作为定界符</div><blockquote><p><strong>碰撞检测CD</strong>：每个<strong>发送帧</strong>的设备<strong>边发送边检测碰撞</strong>，一旦<strong>总线</strong>上出现<strong>碰撞</strong>，则立即<strong>停止发送</strong>，一段时间后<strong>重新发送</strong>，</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将链路端到端的往返时间称为争用期，若站点在发送信号后经过争用期还没检测到碰撞，则判定不会发生碰撞</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若连续发生多次碰撞，则使用退避算法调整各个站点的回避时间，减小碰撞概率</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 帧的长度不能太小，必须保证发送该帧的时间大于争用期，否则无法在发送前检测碰撞，需要进行填充，同时也不能太大，否则会占用总线时间过长</div><p><strong>③CSMA/CA协议</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要应用于使用广播信道的无线局域网，因为无线信道很难检测碰撞，且意义不大，故采用碰撞避免CA</div><blockquote><p><strong>帧间间隔IFS</strong>：所有<strong>站点</strong>必须在<strong>持续检测</strong>到<strong>信道空闲</strong>一段<strong>指定时间</strong>才能发送帧，这段时间即<strong>帧间间隔</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 不同帧的帧间间隔不同，越高优先级帧的帧间间隔越短，用于减少碰撞，其中SIFS帧是最短的帧间间隔，保证一个站点能做好准备</div><blockquote><p><strong>退避时间</strong>：在<strong>某些情况</strong>下，一些站点<strong>发送帧</strong>时在<strong>帧间间隔</strong>的基础上还需要<strong>再等待退避时间</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如一个站点成功发送帧后需要连续发送下一个帧时，以避免一个站点长时间占用信道</div><blockquote><p><strong>信道预约</strong>：<strong>源站</strong>在<strong>发送帧之前</strong>发送一个<strong>RTS帧</strong>，<strong>目的站</strong>收到后<strong>返回</strong>一个<strong>CTS帧</strong>，<strong>源站收到CTS帧</strong>后，<strong>其他站暂停</strong>发送帧，直到<strong>通信完成</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> RTS帧和CTS帧很短，发生碰撞以及碰撞产生的开销很小，但是可以保证通信不受干扰，所以是值得的</div><blockquote><p><strong>虚拟载波监听</strong>：<strong>RTS帧</strong>和<strong>CTS帧</strong>以及<strong>数据帧</strong>都包含了<strong>对应通信时长</strong>，所以<strong>其他站</strong>点只需要监听到<strong>三个帧中的一个</strong>，就能知道<strong>信道占用时间</strong></p></blockquote><h4 id="3-5交换式局域网"><a href="#3-5交换式局域网" class="headerlink" title="3.5交换式局域网"></a>3.5交换式局域网</h4><p><strong>①交换机</strong></p><blockquote><p>根据<strong>帧</strong>的<strong>目标mac地址</strong>，直接<strong>单独转发</strong>到<strong>目标主机</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 与共享信道不同，交换机中，每个MAC地址都有对应的接口，从而形成不同的信道，在互不干扰的情况下并行工作</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当多个主机给同一个主机发送帧时，交换机会将多个帧缓存起来，再逐个发送给目标主机</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_4.png" alt="交换机工作原理"><br><strong>②交换机帧转发过程</strong></p><blockquote><p>当交换机<strong>接收到帧</strong>后，会将<strong>发送方</strong>的<strong>MAC地址</strong>和<strong>接口号</strong>登记到<strong>帧交换表</strong>中</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 也称为交换机的自学习，如果已经登记过，便不会再次登记，随着工作的推进，记录将会越来越长</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 帧交换表的记录项是有时效的，因为由于设备损坏等原因，接口对应的MAC地址可能会改变</div><blockquote><p>读取<strong>帧的目的地址</strong>，并在<strong>帧交换表</strong>中查找<strong>接口号</strong>，若<strong>找到</strong>则<strong>直接发送</strong></p></blockquote><blockquote><p>若<strong>没有</strong>找到<strong>目的地址</strong>对应的<strong>帧交换表项</strong>，则会对<strong>所有其他接口</strong>发送该帧</p></blockquote><blockquote><p><strong>目的主机</strong>收到后<strong>接受该帧</strong>，<strong>其他主机丢弃该帧</strong></p></blockquote><p><strong>③生成树协议STP</strong></p><blockquote><p>为了提高<strong>以太网</strong>的<strong>可靠性</strong>，需要添加<strong>冗余链路</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 但是环形链路可能造成广播帧在各个交换机之间反复转发</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 交换机需要选择性的阻碍某些接口，以确保连通整个网络的同时又不形成环路</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每次物理拓扑发生变化时，都将进行生成树的重新计算</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/JW_5.png" alt="生成树协议"><br><strong>④虚拟局域网VLAN</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 广播帧的发送较为频繁，若每次广播帧都会被整个以太网的所有主机接收，则会十分浪费网络资源</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 需要使用虚拟局域网技术将以太网分为多个广播域，一个广播域的广播帧不会被另一个广播域接收</div><blockquote><p><strong>每个端口</strong>有对应的标识<strong>PVID</strong>，每当<strong>端口发送帧</strong>时，会给其插入<strong>对应的VLAN标记</strong></p></blockquote><blockquote><p>当<strong>其余端口</strong>接收到<strong>帧</strong>时，基于<strong>端口的规则</strong>，根据<strong>PVID和VLAN标记的关系</strong>决定<strong>是否接受</strong>该帧</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 交换机端口类型有Access、Trunk、Hybrid三种，其中Access常用于连接用户计算机，Trunk常用于交换机之间的连接，Hybrid皆可</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 《计算机网络自顶向下》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记（二）</title>
      <link href="/2023/12/10/python-xue-xi-bi-ji-er/"/>
      <url>/2023/12/10/python-xue-xi-bi-ji-er/</url>
      
        <content type="html"><![CDATA[<h1 id="python学习笔记（二）"><a href="#python学习笔记（二）" class="headerlink" title="python学习笔记（二）"></a>python学习笔记（二）</h1><h2 id="python进阶"><a href="#python进阶" class="headerlink" title="python进阶"></a>python进阶</h2><h3 id="1-正则表达式（Regex）"><a href="#1-正则表达式（Regex）" class="headerlink" title="1.正则表达式（Regex）"></a>1.正则表达式（Regex）</h3><p><strong>1.1定义</strong>：一种<strong>只描述文本特征</strong>文本描述方法</p><blockquote><p>与正则表达式有关的函数在<strong>re模块</strong>中</p></blockquote><p><strong>1.2字符分类</strong><br>①默认字符<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/python_8.png" alt="默认字符"><br>②自定义:[ijk]</p><blockquote><p>可以使用<code>-</code>表示字母或数字的范围，如[0-57-8]表示[012345678]</p></blockquote><p><strong>一般的</strong>正则表达式符号不会被解释，不需要使用转义字符<br>在的左方括号后加上一个插入字符<code>^</code>，就可以得到<strong>非字符类</strong>，即匹配不在这个字符类中的所有字符<br><strong>1.3步骤</strong><br>①<code>import re</code>导入re模块<br>②用<code>re.compile()</code>函数创建一个<strong>Regex对象</strong>（记得使用<strong>原始字符串</strong>）<br>③向Regex对象的<code>search()</code>方法传入想查找的字符串，它返回一个<strong>Match对象</strong><br>④调用Match对象的<code>group()</code>方法，返回实际匹配文本的<strong>字符串</strong></p><pre class="line-numbers language-none"><code class="language-none">phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d') #phoneNumRegex是一个Regex对象mo = phoneNumRegex.search('My number is 415-555-4242.') #mo是一个Match对象print('Phone number found: ' + mo.group())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>1.4修饰符号</strong>:在<strong>初始化Regex对象</strong>时使用，如果想要匹配这这些字符，需要使用对应的<strong>转义字符</strong><br>①<code>()</code>：对Regex对象进行<strong>分组</strong></p><blockquote><p>group()函数可以提取对象的<strong>某一组内容</strong>，默认是0，即不考虑分组</p></blockquote><pre class="line-numbers language-none"><code class="language-none">phoneNumRegex = re.compile(r'(\d\d\d)-(\d\d\d-\d\d\d\d)')mo = phoneNumRegex.search('My number is 415-555-4242.')mo.group(1) #得到的结果是'415'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>如果想要一次就获取<strong>所有的分组</strong>，使用<code>groups()</code>方法，返回多个组对应的<strong>字符串元组</strong></p></blockquote><p>②<code>|</code>：表示匹配许多表达式<strong>中的一个</strong>即可</p><pre class="line-numbers language-none"><code class="language-none">heroRegex = re.compile (r'Batman|Tina Fey')mo1 = heroRegex.search('Batman and Tina Fey.')mo1.group() #结果是'Batman'，即第一次匹配到的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>可以利用<code>()</code>和<code>|</code>实现某部分确定，某部分可选的正则表达式，如<code>batRegex = re.compile(r'Bat(man|mobile|copter|bat)')</code></p></blockquote><p>③<code>?</code>:表明它<strong>前面的分组</strong>在这个模式中是<strong>可选的</strong></p><blockquote><p><code>batRegex = re.compile(r'Bat(wo)?man')</code>既匹配’Batwoman’，又匹配’Batman’</p></blockquote><p>④<code>*</code>：意味着“匹配零次或多次”，即星号之前的分组，可以在文本中出现<strong>任意次</strong>，包括0次</p><blockquote><p><code>batRegex = re.compile(r'Bat(wo)*man')</code>可以匹配’Batwowowowoman’和’Batman’</p></blockquote><p>⑤<code>+</code>：类似于<code>*</code>，但是<strong>至少要一次</strong><br>⑥<code>{}</code>：类似于<code>*</code>，用于指定<strong>特定次数</strong>，<code>{n}</code>表示匹配n次，<code>{i，j}</code>代表i-j次</p><blockquote><p>贪心和非贪心匹配:Python 的正则表达式<strong>默认是“贪心”</strong>的，这表示在有二义的情况下，它们会<strong>尽可能匹配最长的字符串</strong>，花括号的“非贪心”版本匹配尽可能最短的字符串，即在<strong>结束的花括号后跟着一个问号</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">greedyHaRegex = re.compile(r'(Ha){3,5}')mo1 = greedyHaRegex.search('HaHaHaHaHa')mo1.group() #结果是'HaHaHaHaHa'nongreedyHaRegex = re.compile(r'(Ha){3,5}?')mo2 = nongreedyHaRegex.search('HaHaHaHaHa')mo2.group() #结果是'HaHaHa'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>⑦<code>^</code>/<code>$</code>：被搜索字符串必须以正则表达式对应的字符串<strong>开始/结束</strong><br>⑧<code>.</code>：匹配一个<strong>除了换行之外</strong>的所有字符</p><blockquote><p>传入<code>re.DOTALL</code>作为<code>re.compile()</code>的第二个参数，可以让句点字符匹配<code>所有字符</code>，包括换行字符</p></blockquote><p><strong>1.5拓展方法</strong><br>①<code>findall()</code>：不同于<code>search()</code>返回的Match对象只包含<code>第一次出现的匹配文本</code>，<code>findall()</code>将返回一<strong>字符串列表</strong>，包含被查找字符串中的<strong>所有匹配</strong></p><pre class="line-numbers language-none"><code class="language-none">phoneNumRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d') # has no groupsphoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000')['415-555-9999', '212-555-0000']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>如果在正则表达式中有分组，那么findall将返回<strong>元组的列表</strong>，每个元组表示一个找到的匹配，其中的项就是正则表达式中每个分组的匹配字符串</p></blockquote><pre class="line-numbers language-none"><code class="language-none">phoneNumRegex = re.compile(r'(\d\d\d)-(\d\d\d)-(\d\d\d\d)') # has groupsphoneNumRegex.findall('Cell: 415-555-9999 Work: 212-555-0000')[('415', '555', '1122'), ('212', '555', '0000')]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>②<code>sub()</code>：传入两个参数，第一个参数是一个字符串，用于取代发现和正则表达式匹配的部分，第二个参数是一个正则表达式，返回替换完成后的字符串</p><pre class="line-numbers language-none"><code class="language-none">namesRegex = re.compile(r'Agent \w+')namesRegex.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.')#返回'CENSORED gave the secret documents to CENSORED.'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>如果只想改变和对应正则表达式相匹配的<strong>一部分</strong>，可以给正则表达式参数<strong>分组</strong>，并在第一个参数开头加上<code>\n</code>，代表该字符串只替代第n组</p></blockquote><pre class="line-numbers language-none"><code class="language-none">agentNamesRegex = re.compile(r'Agent (\w)\w*')agentNamesRegex.sub(r'\1****', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob was a double agent.')#返回结果是'A**** told C**** that E**** knew B**** was a double agent.'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>③复杂的正则表达式</p><blockquote><p>可以可以向<code>re.compile()</code>传入变量<code>re.VERBOSE</code>，作为第二个参数，忽略正则表达式字符串中的空白符和注释<br>使用三重引号，可以将正则表达式定义放在多行中</p></blockquote><p>详细可见<a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/12.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md">参考文章</a></p><h3 id="2-并发编程"><a href="#2-并发编程" class="headerlink" title="2.并发编程"></a>2.并发编程</h3><p><strong>2.1相关概念</strong><br>①并发编程：让程序同时执行多个任务<br>②进程：操作系统中<strong>正在执行</strong>的程序</p><blockquote><p>操作系统以进程为单位分配存储空间，每个进程都有自己的<strong>地址空间</strong>、<strong>数据栈</strong>以及其他用于跟踪进程执行的<strong>辅助数据</strong><br>不同进程通过<strong>进程间通信机制</strong>（IPC）来实现数据共享，具体的方式包括<strong>管道</strong>、<strong>信号</strong>、<strong>套接字</strong>、<strong>共享内存区</strong>等</p></blockquote><p>③线程：进程中可以获得CPU调度的执行单元</p><blockquote><p>某个时刻能够获得CPU的只有唯一的一个<strong>线程</strong></p></blockquote><p><strong>2.2多进程</strong><br><a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/13.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.md">参考文章</a></p><h3 id="3-面向对象编程"><a href="#3-面向对象编程" class="headerlink" title="3.面向对象编程"></a>3.面向对象编程</h3><p><strong>4.1类的定义</strong></p><pre class="line-numbers language-none"><code class="language-none">class Student(object):    # __init__是一个特殊方法用于在创建对象时进行初始化操作    # 通过这个方法我们可以为学生对象绑定name和age两个属性    def __init__(self, name, age):        self.name = name        self.age = age    def study(self, course_name):        print('%s正在学习%s.' % (self.name, course_name))    # PEP 8要求标识符的名字用全小写多个单词用下划线连接    # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)    def watch_movie(self):        if self.age &lt; 18:            print('%s只能观看《熊出没》.' % self.name)        else:            print('%s正在观看岛国爱情大电影.' % self.name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①在Python中可以使用<code>class</code>关键字定义类，其中<code>object</code>是所有类的基类，即<strong>顶级父类</strong>，这意味着在Python中定义的任何类都可以调用<code>object</code>类的方法（如<code>__init__</code>方法），并继承<code>object</code>类的特性<br>②类中的函数被称为<strong>方法</strong>，以描述对象的动态特征，其中方法的<strong>第一个参数</strong>通常被命名为<code>self</code>，Python会自动将对象绑定到第一个参数上<br>③<code>__init__</code>方法定义了类的<strong>属性</strong>，这些属性是描述类的关键</p><p><strong>4.2对象的创建与使用</strong></p><pre class="line-numbers language-none"><code class="language-none">def main():    # 创建学生对象并指定姓名和年龄    stu1 = Student('骆昊', 38)    # 给对象发study消息    stu1.study('Python程序设计')    # 给对象发watch_av消息    stu1.watch_movie()    stu2 = Student('王大锤', 15)    stu2.study('思想品德')    stu2.watch_movie()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①可以通过<code>对象.方法名/属性名</code>访问类的方法和属性</p><blockquote><p>对象的创建不使用<code>__init__</code>方法，而是使用<strong>类名</strong>创建，使用类名创建对象实际上是通过<strong>调用构造函数</strong>来创建对象</p></blockquote><p>②属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用<strong>两个下划线</strong>作为开头</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> python程序员遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重</div><p><strong>4.3property装饰器</strong></p><pre class="line-numbers language-none"><code class="language-none">class Person(object):    def __init__(self, name, age):        self._name = name        self._age = age    # 访问器 - getter方法    @property    def name(self):        return self._name    # 访问器 - getter方法    @property    def age(self):        return self._age    # 修改器 - setter方法    @age.setter    def age(self, age):        self._age = age    def play(self):        if self._age &lt;= 16:            print('%s正在玩飞行棋.' % self._name)        else:            print('%s正在玩斗地主.' % self._name)def main():    person = Person('王大锤', 12)    person.play()    person.age = 22    person.play()    # person.name = '白元芳'  # AttributeError: can't set attributeif __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①<code>@property</code>:将一个<strong>方法</strong>转换为相应的<strong>属性</strong>，将<strong>方法的调用方式</strong>变为<strong>属性的访问方式</strong></p><blockquote><p>具体而言，<code>@property</code>装饰器定义了一个<code>getter</code>方法，用于获取属性的值,如果没有<code>@property</code>的话，<code>person.age</code>应为<code>person.age()</code></p></blockquote><p>②在定义了<strong>访问器</strong>后,可以使用<code>age.setter</code>等装饰器定义对应的<code>setter</code>方法，记住要有<strong>对应的前缀</strong>，且方法名需要一致（即<code>age</code>）<br><strong>4.4静态方法和类方法：</strong>当类中需要一些方法，但是不是基于具体对象实例的，如在<strong>创建对象前</strong>验证其是否合理的方法<br>①静态方法：使用<code>@staticmethod</code>修饰器定义，直接通过<code>类名.方法名()</code>调用</p><blockquote><p>静态方法属于<strong>类本身</strong>，所以在定义时不需要<code>self</code>参数</p></blockquote><pre class="line-numbers language-none"><code class="language-none">from math import sqrtclass Triangle(object):    def __init__(self, a, b, c):        self._a = a        self._b = b        self._c = c    @staticmethod    def is_valid(a, b, c):        return a + b &gt; c and b + c &gt; a and a + c &gt; bdef main():    a, b, c = 3, 4, 5    # 静态方法和类方法都是通过给类发消息来调用的    if Triangle.is_valid(a, b, c):        t = Triangle(a, b, c)    else:        print('无法构成三角形.')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②类方法：使用<code>@classmethod</code>修饰器定义类方法，直接通过<code>类名.方法名()</code>调用</p><blockquote><p>方法的第一个参数约定名为<code>cls</code>，类似于<code>self</code>，但是<code>cls</code>代表是对应的类，允许在类方法内部访问<strong>类级别</strong>的属性和方法</p></blockquote><pre class="line-numbers language-none"><code class="language-none">from time import time, localtime, sleepclass Clock(object):    """数字时钟"""    def __init__(self, hour=0, minute=0, second=0):        self._hour = hour        self._minute = minute        self._second = second    @classmethod    def now(cls):        ctime = localtime(time())        return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)def main():    # 通过类方法创建对象并获取系统时间    clock = Clock.now()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4.5继承和继承</strong>：</p><pre class="line-numbers language-none"><code class="language-none">class Person(object):    """人"""    def __init__(self, name, age):        self._name = name        self._age = age    @property    def name(self):        return self._name    @property    def age(self):        return self._age    @age.setter    def age(self, age):        self._age = age    def play(self):        print('%s正在愉快的玩耍.' % self._name)    def watch_av(self):        if self._age &gt;= 18:            print('%s正在观看爱情动作片.' % self._name)        else:            print('%s只能观看《熊出没》.' % self._name)class Student(Person):    """学生"""    def __init__(self, name, age, grade):        super().__init__(name, age)        self._grade = grade    @property    def grade(self):        return self._grade    @grade.setter    def grade(self, grade):        self._grade = grade    def study(self, course):        print('%s的%s正在学习%s.' % (self._grade, self._name, course))class Teacher(Person):    """老师"""    def __init__(self, name, age, title):        super().__init__(name, age)        self._title = title    @property    def title(self):        return self._title    @title.setter    def title(self, title):        self._title = title    def teach(self, course):        print('%s%s正在讲%s.' % (self._name, self._title, course))def main():    stu = Student('王大锤', 15, '初三')    stu.study('数学')    stu.watch_av()    t = Teacher('骆昊', 38, '砖家')    t.teach('Python程序设计')    t.watch_av()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>①继承：子类除了继承父类提供的属性和方法，还可以定义自己<strong>特有</strong>的属性和方法，所以子类比父类拥有的更多的能力<br>②多态：子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，不同的子类表现不同</p><blockquote><p>抽象类是一种专门让其他类继承的类，<strong>不能创建对应的对象</strong>，子类可以重写其中的<strong>抽象方法</strong>从而实现多态</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果</div><pre class="line-numbers language-none"><code class="language-none">from abc import ABCMeta, abstractmethodclass Pet(object, metaclass=ABCMeta):    """宠物"""    def __init__(self, nickname):        self._nickname = nickname    @abstractmethod    def make_voice(self):        """发出声音"""        passclass Dog(Pet):    """狗"""    def make_voice(self):        print('%s: 汪汪汪...' % self._nickname)class Cat(Pet):    """猫"""    def make_voice(self):        print('%s: 喵...喵...' % self._nickname)def main():    pets = [Dog('旺财'), Cat('凯蒂'), Dog('大黄')]    for pet in pets:        pet.make_voice()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2023/12/10/ha-xi-biao/"/>
      <url>/2023/12/10/ha-xi-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1定义"><a href="#1-1定义" class="headerlink" title="1.1定义"></a>1.1定义</h4><blockquote><p>建立<strong>键</strong><code>key</code>与<strong>值</strong><code>value</code>的<strong>映射</strong>，根据<strong>映射关系</strong>快速<strong>根据键找到值</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 哈希表的增删查改操作的时间复杂度都是O(1)</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 哈希表本质上是利用空间换时间</div><h4 id="1-2哈希算法"><a href="#1-2哈希算法" class="headerlink" title="1.2哈希算法"></a>1.2哈希算法</h4><p><strong>①定义</strong></p><blockquote><p>即<strong>键与值的映射关系</strong>，构造<strong>散列函数</strong><code>h</code>，通过<code>h(key)</code>找到<strong>对应值的位置</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上是将一个较大的输入空间映射到一个较小的输出空间</div><p><strong>②构造</strong></p><blockquote><p>将<code>key</code>转化为<strong>哈希值</strong>，如将<code>key</code>的<strong>每个字符的ASCALL码相加</strong></p></blockquote><blockquote><p>对<strong>哈希值</strong>进行<strong>二次操作</strong>，如<strong>对容器大小取模</strong>，从而<strong>缩小范围</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 哈希算法的构造准则就是计算简单和减少冲突，有专业的哈希算法，如SHA系列，一些编程语言也有内置哈希算法</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用大质数作为模数时，可以最大化地保证哈希值的均匀分布，因为质数不会与其他数字存在公约数</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 只有不可变对象是可哈希的</div><hr><h3 id="2-冲突处理"><a href="#2-冲突处理" class="headerlink" title="2.冲突处理"></a>2.冲突处理</h3><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 通常情况下，哈希表的输入空间远远大于输出空间，冲突无法避免，需要一定的方法处理冲突</div><h4 id="2-1开放定址"><a href="#2-1开放定址" class="headerlink" title="2.1开放定址"></a>2.1开放定址</h4><p><strong>①定义</strong></p><blockquote><p>若发生了<strong>第<code>i</code>次冲突</strong>，试探性地将<strong>其地址增加</strong><code>di</code>，即<code>hi(key)=h(key)+di</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这里的冲突不是总计的冲突，而是当前元素发生冲突的次数，即对于每个元素，i都是从0开始计数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 查找元素时，倘若不匹配，试探性地假设其发生冲突，使用哈希函数向后遍历，直到找到该元素或者遇到空元素</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不能在开放寻址哈希表中直接删除元素，若删除了某个元素，与其发生冲突且存储时间晚于该元素的元素无法被查询</div><blockquote><p>通常采用<strong>懒删除</strong>，即<strong>不直接删除该元素</strong>，使用<strong>标记</strong>表示该元素被删除</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 查找元素时，可以记录遇到的首个标记元素，将查找到的元素与其交换位置，从而释放空间</div><p><strong>②分类</strong></p><blockquote><p><strong>线性探测法</strong>：<code>di=i</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 线性探测会产生聚集现象，即冲突数据集中在某一块，从而导致那里更容易发生冲突</div><blockquote><p><strong>平方探测法</strong>：<code>di</code>序列为<code>1、-1、4、-4....i^2、-i^2</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只要散列表的长度是某个4k+1形式的素数时，平方探测法可以探查到整个散列表空间</div><blockquote><p><strong>双散列探测法</strong>：<code>di=i*h2(key)</code>，其中<strong>h2为另一个非0散列函数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> h2应该保证尽量多的哈希存储单元能被探测到，如h2 = p-h1</div><h4 id="2-2分离链接"><a href="#2-2分离链接" class="headerlink" title="2.2分离链接"></a>2.2分离链接</h4><blockquote><p><strong>原始哈希表</strong>中，<strong>每个地址</strong>对应的只是<strong>一个值</strong>，<strong>分离链接法</strong>采用的是<strong>链表</strong>，先<strong>找到对应链表</strong>再<strong>遍历该链表</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 分离链接的本质是扩容，此处不采用数组，因为数组一开始就要有一定的长度，会造成空间浪费</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当链表很长时，可以将其转化为红黑树或者AVL树，优化查找时间</div><hr><h3 id="3-哈希表的实现"><a href="#3-哈希表的实现" class="headerlink" title="3.哈希表的实现"></a>3.哈希表的实现</h3><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因为哈希表的特性就是快速查找，所以其主体采用结构数组实现</div><h4 id="3-1分离链接哈希表"><a href="#3-1分离链接哈希表" class="headerlink" title="3.1分离链接哈希表"></a>3.1分离链接哈希表</h4><p><strong>①结构代码</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 链表节点 */typedef struct Node {    Pair *pair;    struct Node *next;} Node;/* 分离链接哈希表 */typedef struct {    int size;         // 键值对数量    int capacity;     // 哈希表容量    double loadThres; // 触发扩容的负载因子阈值    int extendRatio;  // 扩容倍数    Node **buckets;   // 桶数组} HashMapChaining;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②构造和析构</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 构造函数 */HashMapChaining *newHashMapChaining() {    HashMapChaining *hashMap = (HashMapChaining *)malloc(sizeof(HashMapChaining));    hashMap-&gt;size = 0;    hashMap-&gt;capacity = 4;    hashMap-&gt;loadThres = 2.0 / 3.0;    hashMap-&gt;extendRatio = 2;    hashMap-&gt;buckets = (Node **)malloc(hashMap-&gt;capacity * sizeof(Node *));    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {        hashMap-&gt;buckets[i] = NULL;    }    return hashMap;}/* 析构函数 */void delHashMapChaining(HashMapChaining *hashMap) {    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {        Node *cur = hashMap-&gt;buckets[i];        while (cur) {            Node *tmp = cur;            cur = cur-&gt;next;            free(tmp-&gt;pair);            free(tmp);        }    }    free(hashMap-&gt;buckets);    free(hashMap);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③增删查改</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 查询操作 */char *get(HashMapChaining *hashMap, int key) {    int index = hashFunc(hashMap, key);    // 遍历桶，若找到 key 则返回对应 val    Node *cur = hashMap-&gt;buckets[index];    while (cur) {        if (cur-&gt;pair-&gt;key == key) {            return cur-&gt;pair-&gt;val;        }        cur = cur-&gt;next;    }    return ""; // 若未找到 key 则返回空字符串}/* 添加操作 */void put(HashMapChaining *hashMap, int key, const char *val) {    // 当负载因子超过阈值时，执行扩容    if (loadFactor(hashMap) &gt; hashMap-&gt;loadThres) {        extend(hashMap);    }    int index = hashFunc(hashMap, key);    // 遍历桶，若遇到指定 key ，则更新对应 val 并返回    Node *cur = hashMap-&gt;buckets[index];    while (cur) {        if (cur-&gt;pair-&gt;key == key) {            strcpy(cur-&gt;pair-&gt;val, val); // 若遇到指定 key ，则更新对应 val 并返回            return;        }        cur = cur-&gt;next;    }    // 若无该 key ，则将键值对添加至尾部    Pair *newPair = (Pair *)malloc(sizeof(Pair));    newPair-&gt;key = key;    strcpy(newPair-&gt;val, val);    Node *newNode = (Node *)malloc(sizeof(Node));    newNode-&gt;pair = newPair;    newNode-&gt;next = hashMap-&gt;buckets[index];    hashMap-&gt;buckets[index] = newNode;    hashMap-&gt;size++;}/* 扩容哈希表 */void extend(HashMapChaining *hashMap) {    // 暂存原哈希表    int oldCapacity = hashMap-&gt;capacity;    Node **oldBuckets = hashMap-&gt;buckets;    // 初始化扩容后的新哈希表    hashMap-&gt;capacity *= hashMap-&gt;extendRatio;    hashMap-&gt;buckets = (Node **)malloc(hashMap-&gt;capacity * sizeof(Node *));    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {        hashMap-&gt;buckets[i] = NULL;    }    hashMap-&gt;size = 0;    // 将键值对从原哈希表搬运至新哈希表    for (int i = 0; i &lt; oldCapacity; i++) {        Node *cur = oldBuckets[i];        while (cur) {            put(hashMap, cur-&gt;pair-&gt;key, cur-&gt;pair-&gt;val);            Node *temp = cur;            cur = cur-&gt;next;            // 释放内存            free(temp-&gt;pair);            free(temp);        }    }    free(oldBuckets);}/* 删除操作 */void removeItem(HashMapChaining *hashMap, int key) {    int index = hashFunc(hashMap, key);    Node *cur = hashMap-&gt;buckets[index];    Node *pre = NULL;    while (cur) {        if (cur-&gt;pair-&gt;key == key) {            // 从中删除键值对            if (pre) {                pre-&gt;next = cur-&gt;next;            } else {                hashMap-&gt;buckets[index] = cur-&gt;next;            }            // 释放内存            free(cur-&gt;pair);            free(cur);            hashMap-&gt;size--;            return;        }        pre = cur;        cur = cur-&gt;next;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④其他</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 哈希函数 */int hashFunc(HashMapChaining *hashMap, int key) {    return key % hashMap-&gt;capacity;}/* 负载因子 */double loadFactor(HashMapChaining *hashMap) {    return (double)hashMap-&gt;size / (double)hashMap-&gt;capacity;}/* 打印哈希表 */void print(HashMapChaining *hashMap) {    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {        Node *cur = hashMap-&gt;buckets[i];        printf("[");        while (cur) {            printf("%d -&gt; %s, ", cur-&gt;pair-&gt;key, cur-&gt;pair-&gt;val);            cur = cur-&gt;next;        }        printf("]\n");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2开放寻址哈希表"><a href="#3-2开放寻址哈希表" class="headerlink" title="3.2开放寻址哈希表"></a>3.2开放寻址哈希表</h4><p><strong>①结构</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 开放寻址哈希表 */typedef struct {    int size;         // 键值对数量    int capacity;     // 哈希表容量    double loadThres; // 触发扩容的负载因子阈值    int extendRatio;  // 扩容倍数    Pair **buckets;   // 桶数组    Pair *TOMBSTONE;  // 删除标记} HashMapOpenAddressing;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②构造与析构</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 构造函数 */HashMapOpenAddressing *newHashMapOpenAddressing() {    HashMapOpenAddressing *hashMap = (HashMapOpenAddressing *)malloc(sizeof(HashMapOpenAddressing));    hashMap-&gt;size = 0;    hashMap-&gt;capacity = 4;    hashMap-&gt;loadThres = 2.0 / 3.0;    hashMap-&gt;extendRatio = 2;    hashMap-&gt;buckets = (Pair **)malloc(sizeof(Pair *) * hashMap-&gt;capacity);    hashMap-&gt;TOMBSTONE = (Pair *)malloc(sizeof(Pair));    hashMap-&gt;TOMBSTONE-&gt;key = -1;    hashMap-&gt;TOMBSTONE-&gt;val = "-1";    return hashMap;}/* 析构函数 */void delHashMapOpenAddressing(HashMapOpenAddressing *hashMap) {    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {        Pair *pair = hashMap-&gt;buckets[i];        if (pair != NULL &amp;&amp; pair != hashMap-&gt;TOMBSTONE) {            free(pair-&gt;val);            free(pair);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③增删查改</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 搜索 key 对应的桶索引 */int findBucket(HashMapOpenAddressing *hashMap, int key) {    int index = hashFunc(hashMap, key);    int firstTombstone = -1;    // 线性探测，当遇到空桶时跳出    while (hashMap-&gt;buckets[index] != NULL) {        // 若遇到 key ，返回对应桶索引        if (hashMap-&gt;buckets[index]-&gt;key == key) {            // 若之前遇到了删除标记，则将键值对移动至该索引            if (firstTombstone != -1) {                hashMap-&gt;buckets[firstTombstone] = hashMap-&gt;buckets[index];                hashMap-&gt;buckets[index] = hashMap-&gt;TOMBSTONE;                return firstTombstone; // 返回移动后的桶索引            }            return index; // 返回桶索引        }        // 记录遇到的首个删除标记        if (firstTombstone == -1 &amp;&amp; hashMap-&gt;buckets[index] == hashMap-&gt;TOMBSTONE) {            firstTombstone = index;        }        // 计算桶索引，越过尾部返回头部        index = (index + 1) % hashMap-&gt;capacity;    }    // 若 key 不存在，则返回添加点的索引    return firstTombstone == -1 ? index : firstTombstone;}/* 查询操作 */char *get(HashMapOpenAddressing *hashMap, int key) {    // 搜索 key 对应的桶索引    int index = findBucket(hashMap, key);    // 若找到键值对，则返回对应 val    if (hashMap-&gt;buckets[index] != NULL &amp;&amp; hashMap-&gt;buckets[index] != hashMap-&gt;TOMBSTONE) {        return hashMap-&gt;buckets[index]-&gt;val;    }    // 若键值对不存在，则返回空字符串    return "";}/* 添加操作 */void put(HashMapOpenAddressing *hashMap, int key, char *val) {    // 当负载因子超过阈值时，执行扩容    if (loadFactor(hashMap) &gt; hashMap-&gt;loadThres) {        extend(hashMap);    }    // 搜索 key 对应的桶索引    int index = findBucket(hashMap, key);    // 若找到键值对，则覆盖 val 并返回    if (hashMap-&gt;buckets[index] != NULL &amp;&amp; hashMap-&gt;buckets[index] != hashMap-&gt;TOMBSTONE) {        free(hashMap-&gt;buckets[index]-&gt;val);        hashMap-&gt;buckets[index]-&gt;val = (char *)malloc(sizeof(strlen(val + 1)));        strcpy(hashMap-&gt;buckets[index]-&gt;val, val);        hashMap-&gt;buckets[index]-&gt;val[strlen(val)] = '\0';        return;    }    // 若键值对不存在，则添加该键值对    Pair *pair = (Pair *)malloc(sizeof(Pair));    pair-&gt;key = key;    pair-&gt;val = (char *)malloc(sizeof(strlen(val + 1)));    strcpy(pair-&gt;val, val);    pair-&gt;val[strlen(val)] = '\0';    hashMap-&gt;buckets[index] = pair;    hashMap-&gt;size++;}/* 删除操作 */void removeItem(HashMapOpenAddressing *hashMap, int key) {    // 搜索 key 对应的桶索引    int index = findBucket(hashMap, key);    // 若找到键值对，则用删除标记覆盖它    if (hashMap-&gt;buckets[index] != NULL &amp;&amp; hashMap-&gt;buckets[index] != hashMap-&gt;TOMBSTONE) {        Pair *pair = hashMap-&gt;buckets[index];        free(pair-&gt;val);        free(pair);        hashMap-&gt;buckets[index] = hashMap-&gt;TOMBSTONE;        hashMap-&gt;size--;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④其他</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 哈希函数 */int hashFunc(HashMapOpenAddressing *hashMap, int key) {    return key % hashMap-&gt;capacity;}/* 负载因子 */double loadFactor(HashMapOpenAddressing *hashMap) {    return (double)hashMap-&gt;size / (double)hashMap-&gt;capacity;}/* 扩容哈希表 */void extend(HashMapOpenAddressing *hashMap) {    // 暂存原哈希表    Pair **bucketsTmp = hashMap-&gt;buckets;    int oldCapacity = hashMap-&gt;capacity;    // 初始化扩容后的新哈希表    hashMap-&gt;capacity *= hashMap-&gt;extendRatio;    hashMap-&gt;buckets = (Pair **)malloc(sizeof(Pair *) * hashMap-&gt;capacity);    hashMap-&gt;size = 0;    // 将键值对从原哈希表搬运至新哈希表    for (int i = 0; i &lt; oldCapacity; i++) {        Pair *pair = bucketsTmp[i];        if (pair != NULL &amp;&amp; pair != hashMap-&gt;TOMBSTONE) {            put(hashMap, pair-&gt;key, pair-&gt;val);            free(pair-&gt;val);            free(pair);        }    }    free(bucketsTmp);}/* 打印哈希表 */void print(HashMapOpenAddressing *hashMap) {    for (int i = 0; i &lt; hashMap-&gt;capacity; i++) {        Pair *pair = hashMap-&gt;buckets[i];        if (pair == NULL) {            printf("NULL\n");        } else if (pair == hashMap-&gt;TOMBSTONE) {            printf("TOMBSTONE\n");        } else {            printf("%d -&gt; %s\n", pair-&gt;key, pair-&gt;val);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图结构（上）</title>
      <link href="/2023/12/10/tu-jie-gou-shang/"/>
      <url>/2023/12/10/tu-jie-gou-shang/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法—图结构（上）"><a href="#数据结构与算法—图结构（上）" class="headerlink" title="数据结构与算法—图结构（上）"></a>数据结构与算法—图结构（上）</h1><h2 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1图"><a href="#1-1图" class="headerlink" title="1.1图"></a>1.1图</h4><p><strong>①定义</strong></p><blockquote><p><strong>图</strong>：由一个<strong>非空</strong>的<strong>有限顶点集合</strong><code>V</code>和一个<strong>有限边集合</strong><code>E</code>组成</p></blockquote><p><strong>②分类</strong></p><blockquote><p><strong>有向图/无向图</strong>：图中的<strong>边有/无方向</strong></p></blockquote><blockquote><p><strong>非连通图/连通图</strong>：图中是/否有顶点<strong>没有边与其他顶点相连</strong></p></blockquote><blockquote><p><strong>有权图/无权图</strong>：图中的<strong>边是否有权重</strong></p></blockquote><h4 id="1-2图的表示"><a href="#1-2图的表示" class="headerlink" title="1.2图的表示"></a>1.2图的表示</h4><p><strong>①邻接矩阵</strong></p><blockquote><p>若<strong>顶点数</strong>为<code>n</code>，则<strong>邻接矩阵</strong>为一<code>nxn</code>的<strong>矩阵G</strong>，若<code>G[i][j]</code><strong>非零</strong>，表示<strong>有边从顶点i指向顶点j</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若边无权重，用1表示，若边有权重，修改对应数值即可</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若图为无向图，对应邻接矩阵为对角线为0的对称矩阵，可以使用数组存储矩阵对角线以下元素，节省空间</div><blockquote><p><strong>数组长度</strong>为<code>n(n+1)/2</code>，<code>G[i][j]</code>在数组中<strong>对应下标</strong>为<code>i(i+1)/2+j</code></p></blockquote><p><strong>②邻接表</strong></p><blockquote><p>若<strong>顶点数</strong>为<code>n</code>，则<strong>邻接表</strong>为<strong>长度为n的数组</strong>，<strong>每个元素</strong>存储一<strong>链表</strong>，存储了<strong>该顶点</strong>的<strong>所有邻接顶点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相比邻接矩阵，邻接表节省了内存空间，但是增删查改的效率不如邻接矩阵</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以将链表转化为搜索树和哈希表等提高效率</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_13.png" alt="图的表示"></p><h3 id="2-图的基本实现"><a href="#2-图的基本实现" class="headerlink" title="2.图的基本实现"></a>2.图的基本实现</h3><h4 id="2-1邻接矩阵实现"><a href="#2-1邻接矩阵实现" class="headerlink" title="2.1邻接矩阵实现"></a>2.1邻接矩阵实现</h4><p><strong>①结构代码</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 基于邻接矩阵实现的无向图结构体 */typedef struct {    int vertices[MAX_SIZE];    int adjMat[MAX_SIZE][MAX_SIZE];    int size;} GraphAdjMat;/* 构造函数 */GraphAdjMat *newGraphAdjMat() {    GraphAdjMat *graph = (GraphAdjMat *)malloc(sizeof(GraphAdjMat));    graph-&gt;size = 0;    for (int i = 0; i &lt; MAX_SIZE; i++) {        for (int j = 0; j &lt; MAX_SIZE; j++) {            graph-&gt;adjMat[i][j] = 0;        }    }    return graph;}/* 析构函数 */void delGraphAdjMat(GraphAdjMat *graph) {    free(graph);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②顶点操作</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 添加顶点即添加一行一列，时间复杂度为O(n)，删除顶点即删除一行一列，时间复杂度为O(n^2)</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将所有顶点添加入初始图，即为图的初始化，时间复杂度为O(n^2)</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 删除顶点最坏情况即删除首行首列，需要移动(n-1)^2个顶点</div><pre class="line-numbers language-none"><code class="language-none">/* 添加顶点 */void addVertex(GraphAdjMat *graph, int val) {    if (graph-&gt;size == MAX_SIZE) {        fprintf(stderr, "图的顶点数量已达最大值\n");        return;    }    // 添加第 n 个顶点，并将第 n 行和列置零    int n = graph-&gt;size;    graph-&gt;vertices[n] = val;    for (int i = 0; i &lt;= n; i++) {        graph-&gt;adjMat[n][i] = graph-&gt;adjMat[i][n] = 0;    }    graph-&gt;size++;}/* 删除顶点 */void removeVertex(GraphAdjMat *graph, int index) {    if (index &lt; 0 || index &gt;= graph-&gt;size) {        fprintf(stderr, "顶点索引越界\n");        return;    }    // 在顶点列表中移除索引 index 的顶点    for (int i = index; i &lt; graph-&gt;size - 1; i++) {        graph-&gt;vertices[i] = graph-&gt;vertices[i + 1];    }    // 在邻接矩阵中删除索引 index 的行    for (int i = index; i &lt; graph-&gt;size - 1; i++) {        for (int j = 0; j &lt; graph-&gt;size; j++) {            graph-&gt;adjMat[i][j] = graph-&gt;adjMat[i + 1][j];        }    }    // 在邻接矩阵中删除索引 index 的列    for (int i = 0; i &lt; graph-&gt;size; i++) {        for (int j = index; j &lt; graph-&gt;size - 1; j++) {            graph-&gt;adjMat[i][j] = graph-&gt;adjMat[i][j + 1];        }    }    graph-&gt;size--;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③边操作</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度均为O(1)</div><pre class="line-numbers language-none"><code class="language-none">/* 添加边 */// 参数 i, j 对应 vertices 元素索引void addEdge(GraphAdjMat *graph, int i, int j) {    if (i &lt; 0 || j &lt; 0 || i &gt;= graph-&gt;size || j &gt;= graph-&gt;size || i == j) {        fprintf(stderr, "边索引越界或相等\n");        return;    }    graph-&gt;adjMat[i][j] = 1;    graph-&gt;adjMat[j][i] = 1;}/* 删除边 */// 参数 i, j 对应 vertices 元素索引void removeEdge(GraphAdjMat *graph, int i, int j) {    if (i &lt; 0 || j &lt; 0 || i &gt;= graph-&gt;size || j &gt;= graph-&gt;size || i == j) {        fprintf(stderr, "边索引越界或相等\n");        return;    }    graph-&gt;adjMat[i][j] = 0;    graph-&gt;adjMat[j][i] = 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2邻接表实现"><a href="#2-2邻接表实现" class="headerlink" title="2.2邻接表实现"></a>2.2邻接表实现</h4><blockquote><p>与<strong>邻接矩阵</strong>不同，<strong>邻接表</strong>的<strong>顶点总数</strong><code>n</code>和<strong>总边数</strong><code>m</code>均是有意义的<br><strong>①结构代码</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用列表组代替链表，邻接表本质上时顶点与邻接顶点列表的对应关系，故使用哈希表存储邻接表</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若邻接表中顶点和索引相对应，则需要移动之后的所有顶点，效率较低</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 每个顶点对应唯一的Vertex实例，删除某一顶点无需改动其他顶点</div><pre class="line-numbers language-none"><code class="language-none">/* 节点结构体 */typedef struct AdjListNode {    Vertex *vertex;           // 顶点    struct AdjListNode *next; // 后继节点} AdjListNode;/* 查找顶点对应的节点 */AdjListNode *findNode(GraphAdjList *graph, Vertex *vet) {    for (int i = 0; i &lt; graph-&gt;size; i++) {        if (graph-&gt;heads[i]-&gt;vertex == vet) {            return graph-&gt;heads[i];        }    }    return NULL;}/* 添加边辅助函数 */void addEdgeHelper(AdjListNode *head, Vertex *vet) {    AdjListNode *node = (AdjListNode *)malloc(sizeof(AdjListNode));    node-&gt;vertex = vet;    // 头插法    node-&gt;next = head-&gt;next;    head-&gt;next = node;}/* 删除边辅助函数 */void removeEdgeHelper(AdjListNode *head, Vertex *vet) {    AdjListNode *pre = head;    AdjListNode *cur = head-&gt;next;    // 在链表中搜索 vet 对应节点    while (cur != NULL &amp;&amp; cur-&gt;vertex != vet) {        pre = cur;        cur = cur-&gt;next;    }    if (cur == NULL)        return;    // 将 vet 对应节点从链表中删除    pre-&gt;next = cur-&gt;next;    // 释放内存    free(cur);}/* 基于邻接表实现的无向图类 */typedef struct {    AdjListNode *heads[MAX_SIZE]; // 节点数组    int size;                     // 节点数量} GraphAdjList;/* 构造函数 */GraphAdjList *newGraphAdjList() {    GraphAdjList *graph = (GraphAdjList *)malloc(sizeof(GraphAdjList));    if (!graph) {        return NULL;    }    graph-&gt;size = 0;    for (int i = 0; i &lt; MAX_SIZE; i++) {        graph-&gt;heads[i] = NULL;    }    return graph;}/* 析构函数 */void delGraphAdjList(GraphAdjList *graph) {    for (int i = 0; i &lt; graph-&gt;size; i++) {        AdjListNode *cur = graph-&gt;heads[i];        while (cur != NULL) {            AdjListNode *next = cur-&gt;next;            if (cur != graph-&gt;heads[i]) {                free(cur);            }            cur = next;        }        free(graph-&gt;heads[i]-&gt;vertex);        free(graph-&gt;heads[i]);    }    free(graph);}/* 查找顶点对应的节点 */AdjListNode *findNode(GraphAdjList *graph, Vertex *vet) {    for (int i = 0; i &lt; graph-&gt;size; i++) {        if (graph-&gt;heads[i]-&gt;vertex == vet) {            return graph-&gt;heads[i];        }    }    return NULL;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②边操作</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 添加边直接在列表末尾添加即可，时间复杂度为O(1)，删除边需要遍历链表，时间复杂度为O(m)</div><pre class="line-numbers language-none"><code class="language-none">/* 添加边 */void addEdge(GraphAdjList *graph, Vertex *vet1, Vertex *vet2) {    AdjListNode *head1 = findNode(graph, vet1);    AdjListNode *head2 = findNode(graph, vet2);    assert(head1 != NULL &amp;&amp; head2 != NULL &amp;&amp; head1 != head2);    // 添加边 vet1 - vet2    addEdgeHelper(head1, vet2);    addEdgeHelper(head2, vet1);}/* 删除边 */void removeEdge(GraphAdjList *graph, Vertex *vet1, Vertex *vet2) {    AdjListNode *head1 = findNode(graph, vet1);    AdjListNode *head2 = findNode(graph, vet2);    assert(head1 != NULL &amp;&amp; head2 != NULL);    // 删除边 vet1 - vet2    removeEdgeHelper(head1, head2-&gt;vertex);    removeEdgeHelper(head2, head1-&gt;vertex);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③顶点操作</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 添加顶点只需要添加邻接表项，时间复杂度为O(1)，删除顶点需要遍历邻接表以及对应的边，时间复杂度为O(m+n)</div><pre class="line-numbers language-none"><code class="language-none">/* 添加顶点 */void addVertex(GraphAdjList *graph, Vertex *vet) {    assert(graph != NULL &amp;&amp; graph-&gt;size &lt; MAX_SIZE);    AdjListNode *head = (AdjListNode *)malloc(sizeof(AdjListNode));    head-&gt;vertex = vet;    head-&gt;next = NULL;    // 在邻接表中添加一个新链表    graph-&gt;heads[graph-&gt;size++] = head;}/* 删除顶点 */void removeVertex(GraphAdjList *graph, Vertex *vet) {    AdjListNode *node = findNode(graph, vet);    assert(node != NULL);    // 在邻接表中删除顶点 vet 对应的链表    AdjListNode *cur = node, *pre = NULL;    while (cur) {        pre = cur;        cur = cur-&gt;next;        free(pre);    }    // 遍历其他顶点的链表，删除所有包含 vet 的边    for (int i = 0; i &lt; graph-&gt;size; i++) {        cur = graph-&gt;heads[i];        pre = NULL;        while (cur) {            pre = cur;            cur = cur-&gt;next;            if (cur &amp;&amp; cur-&gt;vertex == vet) {                pre-&gt;next = cur-&gt;next;                free(cur);                break;            }        }    }    // 将该顶点之后的顶点向前移动，以填补空缺    int i;    for (i = 0; i &lt; graph-&gt;size; i++) {        if (graph-&gt;heads[i] == node)            break;    }    for (int j = i; j &lt; graph-&gt;size - 1; j++) {        graph-&gt;heads[j] = graph-&gt;heads[j + 1];    }    graph-&gt;size--;    free(vet);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-图的遍历"><a href="#3-图的遍历" class="headerlink" title="3.图的遍历"></a>3.图的遍历</h3><h4 id="3-1广度优先遍历BFS"><a href="#3-1广度优先遍历BFS" class="headerlink" title="3.1广度优先遍历BFS"></a>3.1广度优先遍历BFS</h4><p><strong>①思想</strong></p><blockquote><p>从<strong>某个节点</strong>出发，<strong>优先遍历</strong>该节点所有<strong>邻接节点</strong>，随后<strong>广度优先遍历</strong>其各个<strong>邻接节点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 类似于树的先序遍历，一层层向外扩张</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 广度优先遍历的序列不是唯一的，因为相同距离的节点访问顺序是随机的</div><p><strong>②代码实现</strong></p><blockquote><p>将<strong>起点入队</strong>，<strong>队首出队</strong>并<strong>记录访问</strong>，并将该顶点<strong>所有邻接顶点入队</strong>，如此<strong>循环</strong>，直到<strong>访问所有顶点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 所有顶点都会入队出队，且所有边都会被访问两次，故时间复杂度为O(n+m)</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 已经访问过的节点不再入队</div><pre class="line-numbers language-none"><code class="language-none">/* 节点队列结构体 */typedef struct {    Vertex *vertices[MAX_SIZE];    int front, rear, size;} Queue;/* 构造函数 */Queue *newQueue() {    Queue *q = (Queue *)malloc(sizeof(Queue));    q-&gt;front = q-&gt;rear = q-&gt;size = 0;    return q;}/* 判断队列是否为空 */int isEmpty(Queue *q) {    return q-&gt;size == 0;}/* 入队操作 */void enqueue(Queue *q, Vertex *vet) {    q-&gt;vertices[q-&gt;rear] = vet;    q-&gt;rear = (q-&gt;rear + 1) % MAX_SIZE;    q-&gt;size++;}/* 出队操作 */Vertex *dequeue(Queue *q) {    Vertex *vet = q-&gt;vertices[q-&gt;front];    q-&gt;front = (q-&gt;front + 1) % MAX_SIZE;    q-&gt;size--;    return vet;}/* 检查顶点是否已被访问 */int isVisited(Vertex **visited, int size, Vertex *vet) {    // 遍历查找节点，使用 O(n) 时间    for (int i = 0; i &lt; size; i++) {        if (visited[i] == vet)            return 1;    }    return 0;}/* 广度优先遍历 BFS */// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点void graphBFS(GraphAdjList *graph, Vertex *startVet, Vertex **res, int *resSize, Vertex **visited, int *visitedSize) {    // 队列用于实现 BFS    Queue *queue = newQueue();    enqueue(queue, startVet);    visited[(*visitedSize)++] = startVet;    // 以顶点 vet 为起点，循环直至访问完所有顶点    while (!isEmpty(queue)) {        Vertex *vet = dequeue(queue); // 队首顶点出队        res[(*resSize)++] = vet;      // 记录访问顶点        // 遍历该顶点的所有邻接顶点        AdjListNode *node = findNode(graph, vet);        while (node != NULL) {            // 跳过已被访问过的顶点            if (!isVisited(visited, *visitedSize, node-&gt;vertex)) {                enqueue(queue, node-&gt;vertex);             // 只入队未访问的顶点                visited[(*visitedSize)++] = node-&gt;vertex; // 标记该顶点已被访问            }            node = node-&gt;next;        }    }    // 释放内存    free(queue);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2深度优先遍历DFS"><a href="#3-2深度优先遍历DFS" class="headerlink" title="3.2深度优先遍历DFS"></a>3.2深度优先遍历DFS</h4><p><strong>①思想</strong></p><blockquote><p>从<strong>某一节点</strong>出发，不断访问<strong>当前节点</strong>的<strong>某个邻接节点</strong>，直到<strong>尽头返回</strong>，<strong>返回后再继续向后走</strong>，以此类推，直到<strong>所有顶点遍历完成</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 深度优先遍历是一种优先走到底，无路可走再回头的遍历方式，同样，深度优先遍历的序列也不是唯一的</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以人为设置节点的访问优先级，从而统一遍历后序列</div><p><strong>②代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 所有顶点都会被访问，所有边都会被访问两次，故时间复杂度为O(n+m)</div><pre class="line-numbers language-none"><code class="language-none">/* 检查顶点是否已被访问 */int isVisited(Vertex **res, int size, Vertex *vet) {    // 遍历查找节点，使用 O(n) 时间    for (int i = 0; i &lt; size; i++) {        if (res[i] == vet) {            return 1;        }    }    return 0;}/* 深度优先遍历 DFS 辅助函数 */void dfs(GraphAdjList *graph, Vertex **res, int *resSize, Vertex *vet) {    // 记录访问顶点    res[(*resSize)++] = vet;    // 遍历该顶点的所有邻接顶点    AdjListNode *node = findNode(graph, vet);    while (node != NULL) {        // 跳过已被访问过的顶点        if (!isVisited(res, *resSize, node-&gt;vertex)) {            // 递归访问邻接顶点            dfs(graph, res, resSize, node-&gt;vertex);        }        node = node-&gt;next;    }}/* 深度优先遍历 DFS */// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点void graphDFS(GraphAdjList *graph, Vertex *startVet, Vertex **res, int *resSize) {    dfs(graph, res, resSize, startVet);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图结构（下）</title>
      <link href="/2023/12/10/tu-jie-gou-xia/"/>
      <url>/2023/12/10/tu-jie-gou-xia/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="图结构（下）"><a href="#图结构（下）" class="headerlink" title="图结构（下）"></a>图结构（下）</h2><h3 id="1-图的最短路径"><a href="#1-图的最短路径" class="headerlink" title="1.图的最短路径"></a>1.图的最短路径</h3><h4 id="4-1无权图单源最短路径"><a href="#4-1无权图单源最短路径" class="headerlink" title="4.1无权图单源最短路径"></a>4.1无权图单源最短路径</h4><p><strong>①思路</strong></p><blockquote><p>从起点出发，先找到和他距离为1的<strong>没有访问过</strong>的节点，然后在此基础上寻找距离为2的节点，以此类推，直到找到终点</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_22.png" alt="思路"><br><strong>②伪码描述</strong></p><blockquote><p>其中<code>dist</code>数组将没访问的节点与原点的距离设置为一个负数，可以同时起到<code>Visited</code>函数作用<br><code>path</code>记录的是最短路径中，当前节点的上一个节点信息</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_23.png" alt="伪码描述"></p><h4 id="4-2有权图单源最短路径"><a href="#4-2有权图单源最短路径" class="headerlink" title="4.2有权图单源最短路径"></a>4.2有权图单源最短路径</h4><p><strong>①思路</strong>：选定原点<code>s</code>，然后访问其<strong>邻接点</strong>，计算其路径长度并存储在<code>dist[]</code>中（<code>dist[]</code>记录的是原点<strong>经过已收录点</strong>到对应点的距离，初始值都为<strong>正无穷</strong>），选择一个<code>dist[]</code><strong>最小的未收录的点</strong>收录，随后访问收录点的<strong>未收录邻接点</strong>，更新<code>dist[]</code>，在更新的过程中，要注意新收录点可能会影响其邻接点的<code>dist[]</code>，即<strong>只经过旧收录点的路径不是最短的了</strong>，需要更新<code>dist[]</code>和<code>path[]</code>，以此类推，直到所有点都被收录。<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_24.png" alt="Dijkstra"><br><strong>②伪码描述</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_25.png" alt="伪码描述"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_26.png" alt="时间复杂度"></p><h4 id="4-3多源最短路算法"><a href="#4-3多源最短路算法" class="headerlink" title="4.3多源最短路算法"></a>4.3多源最短路算法</h4><p><strong>①思路</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_27.png" alt="Floyd"><br><strong>②伪码描述</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_28.png" alt="伪码描述"></p><h3 id="2-最小生成树"><a href="#2-最小生成树" class="headerlink" title="2.最小生成树"></a>2.最小生成树</h3><h4 id="2-1定义"><a href="#2-1定义" class="headerlink" title="2.1定义"></a>2.1定义</h4><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_29.png" alt="最小生成树"></p><h4 id="2-2贪心算法"><a href="#2-2贪心算法" class="headerlink" title="2.2贪心算法"></a>2.2贪心算法</h4><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_30.png" alt="贪心算法"></p><h4 id="2-3prim算法"><a href="#2-3prim算法" class="headerlink" title="2.3prim算法"></a>2.3prim算法</h4><p>①思路：先选择一个起点，选择其<strong>权重最小的邻接点</strong>并收录，随后选择<strong>已收录点</strong>的权重最小的邻接点，但是不能构成回路，以此类推，直到收录所有的点<br>②伪码描述<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_31.png" alt="伪码描述"></p><h4 id="2-4Kruskal算法"><a href="#2-4Kruskal算法" class="headerlink" title="2.4Kruskal算法"></a>2.4Kruskal算法</h4><p>①思路：选择其中<strong>未被选择的权值最小的边</strong>（可以是多条）将顶点连接起来，以此类推，但是在过程中不能形成回路，直到收录了V-1条边<br>②伪码描述<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_32.png" alt="伪码描述"></p><blockquote><p>回路的检查：一开始将所有顶点看作为独立集合，新加边就是合并集合，如果新加入的边的两边顶点已经是一个集合的了，则会形成回路</p></blockquote><h3 id="3-拓扑排序"><a href="#3-拓扑排序" class="headerlink" title="3.拓扑排序"></a>3.拓扑排序</h3><p><strong>6.1定义</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_33.png" alt="拓扑排序"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_34.png" alt="例子"><br><strong>6.2算法</strong><br>①思想：每次输出所有<strong>没有前驱节点</strong>的节点<br>②伪码描述<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_35.png" alt="伪码描述"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_36.png" alt="算法改进"></p><h3 id="4-关键路径（项目管理问题）"><a href="#4-关键路径（项目管理问题）" class="headerlink" title="4.关键路径（项目管理问题）"></a>4.关键路径（项目管理问题）</h3><p><strong>7.1定义</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_37.png" alt="定义"><br><strong>7.2思路</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_38.png" alt="思路"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小技能大作用</title>
      <link href="/2023/12/10/xiao-ji-neng-da-zuo-yong/"/>
      <url>/2023/12/10/xiao-ji-neng-da-zuo-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="小技能大作用"><a href="#小技能大作用" class="headerlink" title="小技能大作用"></a>小技能大作用</h1><h2 id="容易被人忽视的小技能"><a href="#容易被人忽视的小技能" class="headerlink" title="容易被人忽视的小技能"></a>容易被人忽视的小技能</h2><h3 id="1-信息检索"><a href="#1-信息检索" class="headerlink" title="1.信息检索"></a>1.信息检索</h3><h4 id="1-1搜索语法"><a href="#1-1搜索语法" class="headerlink" title="1.1搜索语法"></a>1.1搜索语法</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要介绍谷歌的搜索语法，因为谷歌目前最准确</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 搜索语法主要是一些限制性语句，用于精准定位</div><p><strong>①关键词限制</strong></p><blockquote><p><code>intitle:[关键词]</code>：<strong>标题</strong>需要包含对应<strong>关键词</strong></p></blockquote><blockquote><p><code>allintitle:[关键词1] [关键词2]...[关键词n]</code>：同上，<strong>标题</strong>需要<strong>同时</strong>包含<strong>多个关键词</strong></p></blockquote><blockquote><p><code>intext:[关键词1] [关键词2]...[关键词n]</code>：<strong>文章内容</strong>中必须<strong>同时</strong>包含对应<strong>关键词</strong></p></blockquote><blockquote><p><code>inurl:[关键词]</code>：<strong>链接</strong>必须包含的<strong>关键词</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这些关键词也可以使用英文双引号""进行限制，表示关键词连续完整出现，否则可能是同音字和近义词等</div><p><strong>②其他限制</strong></p><blockquote><p><code>site:[完整的域名]</code> ：限制<strong>来源网址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 与inurl不同，增加该限制后，来源网址是唯一的</div><blockquote><p><code>imagesize[长x宽]:[lenthxwidth]</code>:限制<strong>图片大小</strong></p></blockquote><blockquote><p><code>filetype:[文件后缀]</code>：限制<strong>文件格式</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 关键词之间以及限制选项之间需要使用空格隔开</div><h4 id="1-2资源网站"><a href="#1-2资源网站" class="headerlink" title="1.2资源网站"></a>1.2资源网站</h4><blockquote><p><strong>搜索引擎</strong>：google</p></blockquote><blockquote><p><strong>报告</strong>：199it.com</p></blockquote><blockquote><p><strong>学术论文</strong>：谷歌学术、scihub</p></blockquote><blockquote><p><strong>电子书</strong>：zlibarary、鸠摩搜书</p></blockquote><blockquote><p><strong>视频</strong>：coursera、youtube</p></blockquote><blockquote><p><strong>素材</strong>：pexels、piaxbay</p></blockquote><blockquote><p><strong>网盘搜索引擎</strong>：如<strong>百度云盘</strong>的<strong>盘搜搜</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以在save.tube上从其中对应网站下载高清素材，且有版权的网站都有对应的下载器</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 直接谷歌xx行业必逛的网站、best xxx sites或者在similarsites中输入域名找相似网站</div><h4 id="1-3在线工具"><a href="#1-3在线工具" class="headerlink" title="1.3在线工具"></a>1.3在线工具</h4><blockquote><p><strong>canva</strong>：一款<strong>在线设计</strong>工具，可以制作<strong>海报</strong>、<strong>视频</strong>和<strong>概念图</strong>等</p></blockquote><blockquote><p><strong>remove</strong>：<strong>抠图</strong></p></blockquote><blockquote><p><strong>腾讯智影</strong>：<strong>文字转语音</strong></p></blockquote><blockquote><p><strong>clipchamp</strong>：<strong>在线剪辑视频</strong></p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 工作流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2023/12/10/pai-xu-suan-fa/"/>
      <url>/2023/12/10/pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><p><strong>①排序</strong></p><blockquote><p>对<strong>一组数据</strong>按照<strong>特定顺序</strong>进行排列</p></blockquote><p><strong>②评价指标</strong></p><blockquote><p><strong>运行效率</strong>：<strong>时间复杂度</strong>尽量低，且<strong>总体操作量</strong>，即<strong>时间复杂度</strong>的<strong>各项系数</strong>较少，</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对于大型数据，主要考虑时间复杂度，对于小型数据，主要考虑总体操作量</div><blockquote><p><strong>空间利用率</strong>：尽量不使用<strong>额外空间</strong>，而是在<strong>原数组</strong>中直接实现</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 此外还需要考虑递归产生的栈帧等</div><blockquote><p><strong>稳定性</strong>：<strong>完成排序</strong>后，<strong>相等元素</strong>在<strong>数组</strong>中的<strong>相对顺序</strong>不发生改变</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因为相同的数据本质上还是不同的，如根据对象成员的值对对象进行排列</div><blockquote><p><strong>自适应性</strong>：是否对<strong>较差数据（如逆序数据）</strong>也有较好的<strong>处理效果</strong></p></blockquote><p><strong>③分类</strong></p><blockquote><p><strong>遍历排序</strong>：<strong>冒泡</strong>排序、<strong>插入</strong>排序、<strong>希尔</strong>排序、<strong>选择</strong>排序</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其中插入排序常用于小型数据排序，因为其稳定，且总体操作量较小</div><blockquote><p><strong>递归排序</strong>：<strong>快速</strong>排序、<strong>归并</strong>排序、<strong>桶</strong>排序</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其中快速排序的比操作的总数量最少，且出现最差情况的概率很低，常用于大型数据的排序</div><h3 id="2-遍历排序"><a href="#2-遍历排序" class="headerlink" title="2.遍历排序"></a>2.遍历排序</h3><h4 id="2-1冒泡排序"><a href="#2-1冒泡排序" class="headerlink" title="2.1冒泡排序"></a>2.1冒泡排序</h4><p><strong>①思路</strong></p><blockquote><p><strong>从左至右</strong>遍历<code>nums</code>，每次遍历比较<strong>对应元素</strong>与其<strong>相邻右元素</strong>，若<strong>右元素大/小于该元素</strong>，则<strong>交换两者位置</strong>，这样就将<strong>未排序区间</strong>的<strong>最小/大元素</strong>放在其<strong>最右端</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为稳定排序，因为冒泡排序每次改变的范围较小，且遇到相等元素不交换，不会改变其相对位置</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_14.png" alt="冒泡排序"><br><strong>②代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 最坏时间复杂度为O(n^2)，最好时间复杂度为O(n)，空间复杂度为O(1)</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其中flag用于判断每次遍历中是否发生了交换，即判断是否已经排序好</div><pre class="line-numbers language-none"><code class="language-none">/* 冒泡排序（标志优化）*/void bubbleSortWithFlag(int nums[], int size) {    // 外循环：未排序区间为 [0, i]    for (int i = 0; i &lt; size - 1; i++) {        bool flag = false;        // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端        for (int j = 0; j &lt; size - 1 - i; j++) {            if (nums[j] &gt; nums[j + 1]) {                int temp = nums[j];                nums[j] = nums[j + 1];                nums[j + 1] = temp;                flag = true;            }        }        if (!flag)            break;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2插入排序"><a href="#2-2插入排序" class="headerlink" title="2.2插入排序"></a>2.2插入排序</h4><p><strong>①思路</strong></p><blockquote><p>开始时以<code>nums[0]</code>为<strong>已排序区间</strong>，<strong>依次</strong>将<strong>剩余元素</strong>插入，<strong>加入元素</strong>依次<strong>从右向左</strong>与<strong>已排序区间元素</strong>比较，如果<strong>大于插入元素</strong>，则<strong>向后移动一位</strong>，直到找到<strong>对应位置</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为稳定排序，因为冒泡排序每次改变的范围较小，且遇到相等元素不交换，不会改变其相对位置</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_15.png" alt="插入排序"><br><strong>②代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 最坏时间复杂度为O(n^2)，最好时间复杂度为O(n)，空间复杂度为O(1)</div><pre class="line-numbers language-none"><code class="language-none">/* 插入排序 */void insertionSort(int nums[], int size) {    // 外循环：已排序元素数量为 1, 2, ..., n    for (int i = 1; i &lt; size; i++) {        int base = nums[i], j = i - 1;        // 内循环：将 base 插入到已排序部分的正确位置        while (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {            // 将 nums[j] 向右移动一位            nums[j + 1] = nums[j];            j--;        }        // 将 base 赋值到正确位置        nums[j + 1] = base;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3希尔排序"><a href="#2-3希尔排序" class="headerlink" title="2.3希尔排序"></a>2.3希尔排序</h4><p><strong>①思路</strong></p><h4 id="2-4选择排序"><a href="#2-4选择排序" class="headerlink" title="2.4选择排序"></a>2.4选择排序</h4><p><strong>①思路</strong></p><blockquote><p>开启一个<strong>循环</strong>，每次循环从<strong>未排序区间</strong>中选择<strong>最大/小的元素</strong>放在<strong>已排序区间的末尾</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 为非稳定性排序，将最小元素放在已排序区间末尾的过程可能会改变相等元素的相对位置</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_16.png" alt="选择排序的不稳定性"><br><strong>②代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 最好和最坏时间复杂度均为O(n^2)，空间复杂度为O(1)</div><pre class="line-numbers language-none"><code class="language-none">/* 选择排序 */void selectionSort(int nums[], int n) {    // 外循环：未排序区间为 [i, n-1]    for (int i = 0; i &lt; n - 1; i++) {        // 内循环：找到未排序区间内的最小元素        int k = i;        for (int j = i + 1; j &lt; n; j++) {            if (nums[j] &lt; nums[k])                k = j; // 记录最小元素的索引        }        // 将该最小元素与未排序区间的首个元素交换        int temp = nums[i];        nums[i] = nums[k];        nums[k] = temp;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5堆排序"><a href="#2-5堆排序" class="headerlink" title="2.5堆排序"></a>2.5堆排序</h4><p><strong>①思路</strong></p><blockquote><p><strong>基于数组</strong>构建<strong>最大堆</strong>，将<strong>堆顶元素</strong>与<strong>堆底元素</strong>交换，<strong>堆的大小减一</strong>，<strong>已排序元素加一</strong>，随后<strong>从顶至底堆化</strong>，<strong>重复</strong>上述步骤，直到<strong>堆的大小为1</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 堆排序本质上是选择排序，只不过使用堆来实现</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 为非稳定排序，在交换堆顶元素和堆底元素时，可能会交换相等元素</div><p><strong>②代码实现</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 最好最坏时间复杂度为O(nlogn)，空间复杂度为O(1)</div><pre class="line-numbers language-none"><code class="language-none">/* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */void siftDown(int nums[], int n, int i) {    while (1) {        // 判断节点 i, l, r 中值最大的节点，记为 ma        int l = 2 * i + 1;        int r = 2 * i + 2;        int ma = i;        if (l &lt; n &amp;&amp; nums[l] &gt; nums[ma])            ma = l;        if (r &lt; n &amp;&amp; nums[r] &gt; nums[ma])            ma = r;        // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出        if (ma == i) {            break;        }        // 交换两节点        int temp = nums[i];        nums[i] = nums[ma];        nums[ma] = temp;        // 循环向下堆化        i = ma;    }}/* 堆排序 */void heapSort(int nums[], int n) {    // 建堆操作：堆化除叶节点以外的其他所有节点    for (int i = n / 2 - 1; i &gt;= 0; --i) {        siftDown(nums, n, i);    }    // 从堆中提取最大元素，循环 n-1 轮    for (int i = n - 1; i &gt; 0; --i) {        // 交换根节点与最右叶节点（即交换首元素与尾元素）        int tmp = nums[0];        nums[0] = nums[i];        nums[i] = tmp;        // 以根节点为起点，从顶至底进行堆化        siftDown(nums, i, 0);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-分治排序"><a href="#3-分治排序" class="headerlink" title="3.分治排序"></a>3.分治排序</h3><h4 id="3-1快速排序"><a href="#3-1快速排序" class="headerlink" title="3.1快速排序"></a>3.1快速排序</h4><p><strong>①思路</strong></p><blockquote><p>从<code>nums</code>中<strong>选择一元素</strong>作为<strong>哨兵</strong>，将所有<strong>比哨兵小</strong>的元素放在其<strong>左侧</strong>，<strong>比哨兵大</strong>的放在其<strong>右侧</strong>，随后在对<strong>左右子数组</strong>进行<strong>相同的操作</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 快速排序的好坏取决于哨兵的选择，若选择的哨兵导致左右数组完全平衡，则可能退化为冒泡排序</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以将哨兵选择为数组头元素、中点元素和尾元素的中位数</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 为非稳定性排序，若相等元素被选为哨兵，则其余相等项与其相对顺序可能会改变</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_17.png" alt="快速排序"><br><strong>②代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 最坏时间复杂度为O(n^2)，最好时间复杂度为O(nlogn)，空间复杂度为O(n)，递归函数需要额外的栈帧</div><pre class="line-numbers language-none"><code class="language-none">/* 元素交换 */void swap(int nums[], int i, int j) {    int tmp = nums[i];    nums[i] = nums[j];    nums[j] = tmp;}/* 快速排序类（中位基准数优化） */// 选取三个元素的中位数int medianThree(int nums[], int left, int mid, int right) {    // 此处使用异或运算来简化代码    // 异或规则为 0 ^ 0 = 1 ^ 1 = 0, 0 ^ 1 = 1 ^ 0 = 1    if ((nums[left] &lt; nums[mid]) ^ (nums[left] &lt; nums[right]))        return left;    else if ((nums[mid] &lt; nums[left]) ^ (nums[mid] &lt; nums[right]))        return mid;    else        return right;}// 哨兵划分（三数取中值）int partitionMedian(int nums[], int left, int right) {    // 选取三个候选元素的中位数    int med = medianThree(nums, left, (left + right) / 2, right);    // 将中位数交换至数组最左端    swap(nums, left, med);    // 以 nums[left] 作为基准数    int i = left, j = right;    while (i &lt; j) {        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])            j--; // 从右向左找首个小于基准数的元素        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])            i++;          // 从左向右找首个大于基准数的元素        swap(nums, i, j); // 交换这两个元素    }    swap(nums, i, left); // 将基准数交换至两子数组的分界线    return i;            // 返回基准数的索引}// 快速排序类-快速排序void quickSort(int nums[], int left, int right) {    // 子数组长度为 1 时终止递归    if (left &gt;= right) {        return;    }    // 哨兵划分    int pivot = partition(nums, left, right);    // 递归左子数组、右子数组    quickSort(nums, left, pivot - 1);    quickSort(nums, pivot + 1, right);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2归并排序"><a href="#3-2归并排序" class="headerlink" title="3.2归并排序"></a>3.2归并排序</h4><p><strong>①思路</strong></p><blockquote><p>将数组<code>nums</code>不断<strong>二分</strong>为<strong>两个子数组</strong>，直到<strong>子数组长度为1</strong>，<strong>从底至顶</strong>将子数组<strong>合并为有序数组</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 对于链表，归并排序相较于其他排序算法具有显著优势，空间复杂度可降为O(1)</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_18.png" alt="归并排序"><br><strong>②代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 最好最坏时间复杂度为O(nlogn)，空间复杂度为O(n)，其中栈帧为O(nlogn)，但是需要额外借助数组，故为O(n)</div><pre class="line-numbers language-none"><code class="language-none">/* 合并左子数组和右子数组 */void merge(int *nums, int left, int mid, int right) {    // 左子数组区间 [left, mid], 右子数组区间 [mid+1, right]    // 创建一个临时数组 tmp ，用于存放合并后的结果    int tmpSize = right - left + 1;    int *tmp = (int *)malloc(tmpSize * sizeof(int));    // 初始化左子数组和右子数组的起始索引    int i = left, j = mid + 1, k = 0;    // 当左右子数组都还有元素时，比较并将较小的元素复制到临时数组中    while (i &lt;= mid &amp;&amp; j &lt;= right) {        if (nums[i] &lt;= nums[j]) {            tmp[k++] = nums[i++];        } else {            tmp[k++] = nums[j++];        }    }    // 将左子数组和右子数组的剩余元素复制到临时数组中    while (i &lt;= mid) {        tmp[k++] = nums[i++];    }    while (j &lt;= right) {        tmp[k++] = nums[j++];    }    // 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间    for (k = 0; k &lt; tmpSize; ++k) {        nums[left + k] = tmp[k];    }    // 释放内存    free(tmp);}/* 归并排序 */void mergeSort(int *nums, int left, int right) {    // 终止条件    if (left &gt;= right)        return; // 当子数组长度为 1 时终止递归    // 划分阶段    int mid = (left + right) / 2;    // 计算中点    mergeSort(nums, left, mid);      // 递归左子数组    mergeSort(nums, mid + 1, right); // 递归右子数组    // 合并阶段    merge(nums, left, mid, right);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3桶排序"><a href="#3-3桶排序" class="headerlink" title="3.3桶排序"></a>3.3桶排序</h4><p><strong>①思路</strong></p><blockquote><p>设置<code>k</code>个具有<strong>大小顺序</strong>的<strong>桶</strong>，将<strong>数据</strong>根据<strong>桶的大小范围</strong>分配到<strong>不同的桶</strong>中，<strong>分别</strong>在这些<strong>桶中对数据进行排序</strong>，排序后<strong>根据桶的顺序合并</strong>即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 桶排序的稳定性根据其桶内使用的算法决定</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 桶排序适用于处理体量很大的数据，桶通常使用链表实现</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_19.png" alt="桶排序"><br><strong>②代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 最好时间复杂度接近O(n+k)，最坏时间复杂度为桶使用的算法，空间复杂度为O(n+k)</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当桶的数量较多且数据均匀分布在桶内时，桶排序的速率最高</div><blockquote><p>可以先<strong>粗略的分</strong>，然后在此基础上将<strong>大桶再细分</strong>，直到<strong>每个桶大小相近</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/* 桶排序 */void bucketSort(float nums[], int size) {    // 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素    int k = size / 2;    float **buckets = calloc(k, sizeof(float *));    for (int i = 0; i &lt; k; i++) {        // 每个桶最多可以分配 k 个元素        buckets[i] = calloc(ARRAY_SIZE, sizeof(float));    }    // 1. 将数组元素分配到各个桶中    for (int i = 0; i &lt; size; i++) {        // 输入数据范围 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]        int bucket_idx = nums[i] * k;        int j = 0;        // 如果桶中有数据且数据小于当前值 nums[i], 要将其放到当前桶的后面，相当于 cpp 中的 push_back        while (buckets[bucket_idx][j] &gt; 0 &amp;&amp; buckets[bucket_idx][j] &lt; nums[i]) {            j++;        }        float temp = nums[i];        while (j &lt; ARRAY_SIZE &amp;&amp; buckets[bucket_idx][j] &gt; 0) {            swap(&amp;temp, &amp;buckets[bucket_idx][j]);            j++;        }        buckets[bucket_idx][j] = temp;    }    // 2. 对各个桶执行排序    for (int i = 0; i &lt; k; i++) {        qsort(buckets[i], ARRAY_SIZE, sizeof(float), compare_float);    }    // 3. 遍历桶合并结果    for (int i = 0, j = 0; j &lt; k; j++) {        for (int l = 0; l &lt; ARRAY_SIZE; l++) {            if (buckets[j][l] &gt; 0) {                nums[i++] = buckets[j][l];            }        }    }    // 释放上述分配的内存    for (int i = 0; i &lt; k; i++) {        free(buckets[i]);    }    free(buckets);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4计数排序"><a href="#3-4计数排序" class="headerlink" title="3.4计数排序"></a>3.4计数排序</h4><p><strong>①思想</strong></p><blockquote><p><strong>遍历</strong>数组，找到其<strong>最大值</strong><code>m</code>，创建一个<strong>长度</strong>为<code>m+1</code>的<strong>辅助数组</strong><code>counter</code>，再次<strong>遍历数组</strong>，遇到<strong>数字</strong><code>num</code>，则<strong>辅助数组对应位置</strong><code>counter[num]</code><strong>加一</strong>，<strong>遍历完</strong>后，再遍历<strong>辅助数组</strong>，将元素<strong>依次按照对应位置的值取出</strong>即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 本质上还是桶排序，桶的个数为m+1，且只能非负整数元素进行排序，且仅适用于数据量大且数据范围小的情况</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以将对应元素转化为非负整数再使用该方法，如给负数加上一个大的偏移量</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 上述计数排序实现是不稳定的，且无法根据对象的某个成员对对象进行排列</div><blockquote><p>引入<strong>结果数组</strong><code>res</code>，<strong>得到<code>counter</code>数组</strong>后，再<strong>倒序遍历</strong><code>nums</code>数组，<strong>每次遍历</strong>，根据<code>premix[num]-1</code>，得到其<strong>在结果数组的索引</strong>，随后<code>counter[num]</code><strong>减一</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> premix为前缀和，premix-1代表元素num在结果数组res中最后一次出现的索引</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_21.png" alt="计数排序"><br><strong>②代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(n+m)，空间复杂度为O(n+m)，其中m为辅助数组的长度</div><pre class="line-numbers language-none"><code class="language-none">/* 计数排序 */// 完整实现，可排序对象，并且是稳定排序void countingSort(int nums[], int size) {    // 1. 统计数组最大元素 m    int m = 0;    for (int i = 0; i &lt; size; i++) {        if (nums[i] &gt; m) {            m = nums[i];        }    }    // 2. 统计各数字的出现次数    // counter[num] 代表 num 的出现次数    int *counter = malloc(sizeof(int) * m);    for (int i = 0; i &lt; size; i++) {        counter[nums[i]]++;    }    // 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”    // 即 counter[num]-1 是 num 在 res 中最后一次出现的索引    for (int i = 0; i &lt; m; i++) {        counter[i + 1] += counter[i];    }    // 4. 倒序遍历 nums ，将各元素填入结果数组 res    // 初始化数组 res 用于记录结果    int *res = malloc(sizeof(int) * size);    for (int i = size - 1; i &gt;= 0; i--) {        int num = nums[i];        res[counter[num] - 1] = num; // 将 num 放置到对应索引处        counter[num]--;              // 令前缀和自减 1 ，得到下次放置 num 的索引    }    // 使用结果数组 res 覆盖原数组 nums    memcpy(nums, res, size * sizeof(int));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5基数排序"><a href="#3-5基数排序" class="headerlink" title="3.5基数排序"></a>3.5基数排序</h4><p><strong>①思想</strong></p><blockquote><p><strong>先根据</strong>元素的<strong>某一关键字</strong>进行<strong>桶排序</strong>，<strong>在此基础上</strong>，再根据<strong>另一关键字</strong>进行<strong>桶排序</strong>，直到遍历完<strong>所有关键字</strong>，如一堆<strong>三位数</strong>，依次对<strong>个位数</strong>、<strong>十位数</strong>和<strong>百位数</strong>进行<strong>计数排序</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 稳定性取决于所用的计数排序</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通过排序次数减少桶的数量</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 后一轮排序会覆盖前一轮排序的结果，不同的关键词顺序会造成不同的结果，通常优先排列优先级低的关键字</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_20.png" alt="基数排序"><br><strong>②代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(n+m)，空间复杂度为O(n+m)，m为辅助数组的长度</div><pre class="line-numbers language-none"><code class="language-none">/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */int digit(int num, int exp) {    // 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算    return (num / exp) % 10;}/* 计数排序（根据 nums 第 k 位排序） */void countingSortDigit(int nums[], int size, int exp) {    // 十进制的位范围为 0~9 ，因此需要长度为 10 的桶    int *counter = (int *)malloc((sizeof(int) * 10));    // 统计 0~9 各数字的出现次数    for (int i = 0; i &lt; size; i++) {        // 获取 nums[i] 第 k 位，记为 d        int d = digit(nums[i], exp);        // 统计数字 d 的出现次数        counter[d]++;    }    // 求前缀和，将“出现个数”转换为“数组索引”    for (int i = 1; i &lt; 10; i++) {        counter[i] += counter[i - 1];    }    // 倒序遍历，根据桶内统计结果，将各元素填入 res    int *res = (int *)malloc(sizeof(int) * size);    for (int i = size - 1; i &gt;= 0; i--) {        int d = digit(nums[i], exp);        int j = counter[d] - 1; // 获取 d 在数组中的索引 j        res[j] = nums[i];       // 将当前元素填入索引 j        counter[d]--;           // 将 d 的数量减 1    }    // 使用结果覆盖原数组 nums    for (int i = 0; i &lt; size; i++) {        nums[i] = res[i];    }}/* 基数排序 */void radixSort(int nums[], int size) {    // 获取数组的最大元素，用于判断最大位数    int max = INT32_MIN;    for (size_t i = 0; i &lt; size - 1; i++) {        if (nums[i] &gt; max) {            max = nums[i];        }    }    // 按照从低位到高位的顺序遍历    for (int exp = 1; max &gt;= exp; exp *= 10)        // 对数组元素的第 k 位执行计数排序        // k = 1 -&gt; exp = 1        // k = 2 -&gt; exp = 10        // 即 exp = 10^(k-1)        countingSortDigit(nums, size, exp);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-其他排序方法"><a href="#4-其他排序方法" class="headerlink" title="4.其他排序方法"></a>4.其他排序方法</h3><h4 id="4-1表排序"><a href="#4-1表排序" class="headerlink" title="4.1表排序"></a>4.1表排序</h4><blockquote><p><strong>不</strong>直接排序<strong>元素本身</strong>，而是<strong>排序其指针</strong>，需要一个<strong>辅助数组</strong>存储<strong>排序后的指针</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这里的指针是广义的，包含元素的位置信息即可</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 上述排序方法都需要交换元素的位置，若元素过大，则交换元素的代价较大，通过排序元素的指针间接排序元素</div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（一）</title>
      <link href="/2023/12/10/cao-zuo-xi-tong-yi/"/>
      <url>/2023/12/10/cao-zuo-xi-tong-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（一）"><a href="#操作系统（一）" class="headerlink" title="操作系统（一）"></a>操作系统（一）</h1><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="1-操作系统的启动"><a href="#1-操作系统的启动" class="headerlink" title="1.操作系统的启动"></a>1.操作系统的启动</h3><h4 id="1-1引导扇区的读入"><a href="#1-1引导扇区的读入" class="headerlink" title="1.1引导扇区的读入"></a>1.1引导扇区的读入</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以X86 PC为例（使用16位寄存器）</div><blockquote><p>开机时，PC处于<strong>实模式</strong>，<code>CS:IP</code>被<strong>初始化</strong>为<code>FFFFH:0000H</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CPU的工作模式影响CPU的寻址方式、寄存器大小等</div><blockquote><p>CPU寻址<code>FFFFH:0000H</code>，即<strong>ROM BIOS映射区</strong>，并<strong>检查硬件</strong></p></blockquote><blockquote><p>将磁盘<strong>0磁道0扇区</strong>读入<code>7C00H处</code>，并设置<code>CS:IP</code>为<code>07c0H:0000H</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 0磁道0扇区即操作系统的引导扇区（bootsect.s），一个扇区512个字节</div><h4 id="1-2bootsect-s概述"><a href="#1-2bootsect-s概述" class="headerlink" title="1.2bootsect.s概述"></a>1.2<code>bootsect.s</code>概述</h4><blockquote><p>将<code>07C0H:0000</code>处的引导程序<strong>移动</strong>到<code>9000H:0000H</code>处，并跳转到<strong>下一条指令移动后的位置（因为还要继续执行<code>bootsect.s</code>）</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将07C0H:0000到9000H:0000H这段地址空间腾出来，给操作系统使用</div><blockquote><p>利用<strong>13号中断</strong>读取<code>setup.s</code><strong>所在扇区</strong>，以及<strong>操作系统所在扇区</strong>（都按顺序放在<code>bootsect.s</code>之后），并完成一些<strong>辅助工作（如显示开机画面）</strong>，最后跳转到<code>setup.s</code>地址入口</p></blockquote><h4 id="1-3setup-s程序概述"><a href="#1-3setup-s程序概述" class="headerlink" title="1.3setup.s程序概述"></a>1.3<code>setup.s</code>程序概述</h4><blockquote><p>获得相关<strong>硬件信息</strong>，如<strong>扩展内存大小、显卡参数</strong>等，并存放在<strong>某段地址中</strong>，以便之后<strong>操作系统的初始化</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 实模式下寻址大小只有1M，所以要扩展内存</div><blockquote><p>将<strong>操作系统</strong>读入到<strong>0地址处</strong>（之前在<code>setup.s</code>程序后），并完成一些<strong>准备工作</strong>，并进入<strong>保护模式（32位模式）</strong>，最后跳转到<strong>0地址处</strong>执行<strong>操作系统的第一个模 块</strong><code>head.s</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这里的准备工作包括gdt表和idt表的初始化，进入保护模式后CS根据其值查询gdt表获得32位段地址，与32位IP进行相加，获得32位地址</div><h4 id="1-4head-s概述"><a href="#1-4head-s概述" class="headerlink" title="1.4head.s概述"></a>1.4<code>head.s</code>概述</h4><blockquote><p>完成一些<strong>准备工作</strong>（如<strong>重新建立gdt表</strong>和<strong>idt表</strong>），并进入操作系统的<strong>main函数（通过内嵌汇编）</strong>，进行内存等对象的<strong>初始化并开始工作</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> head.s变为32位汇编（GNU as汇编），内嵌汇编</div><hr><h3 id="2-系统调用"><a href="#2-系统调用" class="headerlink" title="2.系统调用"></a>2.系统调用</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><blockquote><p><strong>shell实现概述</strong><br><code>shell</code>读取<strong>用户输入</strong>并调用<code>fork()</code>和<code>exec()</code>这两个<strong>系统调用</strong>执行用户输入 </p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 系统调用即由系统提供的函数接口</div><blockquote><p><strong>POSIX标准</strong>：由<strong>IEEE</strong>制定，每个操作系统<strong>都应该提供</strong>类似功能的<strong>系统调用</strong>（如<code>fork()</code>和<code>open()</code>） </p></blockquote><h4 id="2-2内核态和用户态"><a href="#2-2内核态和用户态" class="headerlink" title="2.2内核态和用户态"></a>2.2内核态和用户态</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 内核态和用户态本质上是内存的不同部分，拥有不同的权限，由硬件实现</div><blockquote><p><strong>CPL</strong>：<strong>当前执行指令的特权级</strong>，用<strong>CS的最低两位</strong>来表示</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 操作系统启动后即进入用户态，CPL被初始化为3，系统调用可以将其变为0</div><blockquote><p><strong>DPL</strong>：当前指令<strong>访问的目标段的特权级</strong>，放在<strong>GDT表</strong>中</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> GDT表的每一个表项用于描述一个地址，机器启动时初始化</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 0是内核态，3是用户态，当CPL≤DPL时，可以访问</div><h4 id="2-3陷入内核态概述"><a href="#2-3陷入内核态概述" class="headerlink" title="2.3陷入内核态概述"></a>2.3陷入内核态概述</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通过特定中断进入内核，如Linux是int 80H</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以Linux系统下调用printf函数为例</div><blockquote><p><strong>用户程序</strong>调用<code>printf</code><strong>库函数</strong>，<code>printf</code><strong>库函数</strong>调用<code>write</code><strong>库函数</strong></p></blockquote><blockquote><p><code>write</code>通过<strong>宏</strong><code>_syscall3</code>调用了<code>int 80H</code><strong>中断</strong>，并根据<strong>宏的参数</strong>将<strong>系统调用号等信息</strong>传递给<code>int 80H</code><strong>中断</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 给int 80H传递数据本质上是给对应的寄存器赋值</div><blockquote><p>调用中断后，读取对应的<strong>idt表项</strong>，并获得<strong>对应中断处理函数</strong><code>system_call</code>的<strong>起始地址</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 80H中断idt表项的DPL为3，以便用户程序访问，system_call的CPL为0（对应CS为8），当调用system_call函数时，即已经陷入内核</div><blockquote><p><code>system_call</code>函数首先<strong>跳转到内核的数据段和代码段</strong>，并根据<strong>系统调用号</strong>在<code>_sys_call_table</code>表（<strong>一个函数指针数组</strong>）中查找<strong>对应系统调用处理函数入口</strong>，并调用该函数</p></blockquote><hr><h3 id="3-进程和线程"><a href="#3-进程和线程" class="headerlink" title="3.进程和线程"></a>3.进程和线程</h3><h4 id="3-1基本概念"><a href="#3-1基本概念" class="headerlink" title="3.1基本概念"></a>3.1基本概念</h4><p><strong>①并发</strong></p><blockquote><p>CPU是<strong>取指执行</strong>，但是有些指令，如<strong>I/O指令</strong>，执行<strong>非常慢</strong>，且执行过程<strong>不使用CPU</strong>，可以在<strong>等待时执行别的指令</strong>，这就是<strong>并发</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一条I/O指令执行时间为简单指令的10的六次方倍</div><p><strong>②进程和线程</strong></p><blockquote><p><strong>进程</strong>：<strong>运行中的程序</strong>，除了<strong>对应的程序</strong>之外，还有<strong>记录其信息（如各个寄存器的值、运行状态等）的结构（PCB）</strong>以及<strong>对应资源</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> PCB保留了进程运行时的信息，以便于进程之间的切换，当进程1切换到进程2时，更新并保存进程1的PCB，随后读取进程2的PCB，为进程2运行布置好环境</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 不同的进程解决不同的任务，可以通过管理PCB管理进程</div><blockquote><p><strong>线程</strong>：一个进程可能有<strong>多个指令执行序列</strong>，<strong>每个指令执行序列</strong>就是<strong>线程</strong>，每个线程也有对应的<strong>记录其信息的结构（TCB）</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以一个网页为例，一个线程用于从服务器接收数据，一个线程用于显示文本，一个线程用于处理图片</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 同一个进程的线程共享进程资源，故线程切换的代价较小，又保留了并发的优点</div><p><strong>③运行状态</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/OS_1.png" alt="运行状态"></p><h4 id="3-2线程切换"><a href="#3-2线程切换" class="headerlink" title="3.2线程切换"></a>3.2线程切换</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 进程的切换和线程的切换类似，只是多了内存映射的切换而已</div><p><strong>①引言</strong></p><blockquote><p><strong>函数调用</strong>：C语言中，当<strong>一个函数调用另一个函数</strong><code>func(p1,p2,p3)</code>时，会先<strong>向栈内压入返回地址</strong>、<code>p1</code>、<code>p2</code>和<code>p3</code>，随后<strong>跳转到对应函数的入口</strong>，当函数<strong>结束时</strong>，<strong>将栈内参数弹出</strong>，返回到原来的函数继续执行</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 函数以}结束，}相当于iret指令</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 线程和进程的切换也类似于函数的调用，需要一个栈保存相关信息</div><p><strong>②用户级线程</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 用户级线程不需要陷入内核，没有用户级进程这一说法，因为进程必须访问计算机资源</div><blockquote><p><strong>线程栈</strong>：每个线程都有<strong>自己的线程栈</strong>，用于实现<strong>当前线程的函数调用</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 线程之间不能共用栈，因为iret只是简单的弹栈，可能会导致线程1调用的函数返回时返回到线程2中</div><blockquote><p><strong>切换概述</strong>：<strong>切换TCB</strong>，并<strong>根据TCB切换线程栈</strong></p></blockquote><blockquote><p><strong>创建概述</strong>：为线程<strong>申请内存</strong>，创建<strong>TCB和线程栈</strong>，建立<strong>线程栈和TCB的联系</strong></p></blockquote><p><strong>③核心级线程</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 有些线程需要调用计算机资源，则必须陷入内核</div><blockquote><p><strong>线程栈</strong>：核心级线程除了<strong>用户态有一个栈（用户栈）</strong>，<strong>内核态还有一个栈（内核栈）</strong>，因为其<strong>在内核态也需要调用函数</strong></p></blockquote><p><strong>④核心级线程切换概述</strong></p><blockquote><p>当<strong>线程1</strong>接收到中断，<strong>陷入内核</strong>，<strong>从用户栈转移到内核栈</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> system_call将相关信息压入内核栈，如用户栈的指针，返回地址和标志寄存器，以及一段包含iret的代码</div><blockquote><p>当<strong>线程1在内核中堵塞</strong>，切换到<strong>线程2的TCB和内核栈</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 线程2即陷入内核但是因为某种原因未执行完的线程</div><blockquote><p><strong>线程2</strong>在内核中完成一些<strong>收尾工作（当然也可能再次阻塞）</strong>，通过<strong>内核栈的iret指令返回用户栈</strong></p></blockquote><p><strong>④核心级线程创建概述</strong></p><blockquote><p>申请<strong>TCB、内核栈和用户栈</strong>的<strong>内存空间</strong></p></blockquote><blockquote><p><strong>关联TCB</strong>和<strong>内核栈</strong>以及<strong>用户栈</strong>，<strong>初始化内核栈</strong>和<strong>用户栈</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中内核栈需要包含用户栈的指针以及初始返回地址</div><h4 id="3-3子进程"><a href="#3-3子进程" class="headerlink" title="3.3子进程"></a>3.3子进程</h4><p><strong>①<code>fork()</code></strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 父进程调用该系统调用创建子进程</div><blockquote><p><code>fork()</code>调用<code>_copy_process</code>，为子进程<strong>申请内存空间</strong>，<strong>创建并初始化子进程的内核栈和TCB</strong>，<strong>和父进程共用用户栈</strong>，并将其<code>eax</code>值设置为<code>0</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> _copy_process的参数是父进程陷入内核时压入内核栈的参数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> fork()的返回值是eax值，为0表示其是子进程，用于和父进程区分</div><p><strong>②子进程的运行</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以shell为例，假设执行ls</div><blockquote><p><code>shell</code><strong>主体代码</strong>如下</p></blockquote><pre class="line-numbers language-none"><code class="language-none">int main(int argc,char* argv[]){  while(1)  {    scanf("%s",cmd);    if(!fork())    {      exec(cmd);    }    wait(0);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>shell</code>通过<strong>读取用户输入创建对应子进程</strong>，</p></blockquote><blockquote><p>通过<code>fork()</code>的<strong>返回值判断是子进程还是父进程</strong></p></blockquote><blockquote><p>如果是<strong>子进程</strong>，<code>exec()</code>通过中断<strong>进入内核</strong>，修改<strong>子进程的内核栈</strong>，<strong>中断返回后</strong>执行的就是<code>ls</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要是将对应pc指向ls代码初始地址，并创建子进程自己的用户栈并修改对应寄存器</div><h4 id="3-4进程调度"><a href="#3-4进程调度" class="headerlink" title="3.4进程调度"></a>3.4进程调度</h4><p><strong>①调度指标</strong></p><blockquote><p><strong>周转时间</strong>：任务<strong>开始</strong>到任务<strong>结束</strong></p></blockquote><blockquote><p><strong>响应时间</strong>：从<strong>给出操作</strong>到<strong>发出响应</strong></p></blockquote><blockquote><p><strong>吞吐量</strong>：<strong>任务时间占比</strong>，因为系统有<strong>内耗</strong>，如<strong>进程切换</strong>也需要时间</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 进程调度的目标就是使得每个程序的指标都尽可能高，也有矛盾，如要求响应时间则表示进程切换频繁，导致系统内耗增加</div><p><strong>②基本调度算法</strong></p><blockquote><p><strong>SJF</strong>：<strong>短作业优先</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以保证周转，但是无法保证响应时间</div><blockquote><p><strong>RR</strong>：<strong>按照时间片轮转调度</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以保证响应时间，但是无法保证周转时间</div><blockquote><p><strong>优先级算法</strong>：<strong>动态调整优先级</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 任务主要可分为I/O约束型（前台）和CPU约束型（后台），一般要求先满足前台的要求</div><p><strong>③例子</strong></p><blockquote><p><strong>linux0.11</strong>的<code>schedule()</code>函数<br>找到<strong>任务列表</strong>中，处于<strong>运行状态且时间片大于0的最大</strong>的任务，如果能找到则<strong>调度该任务</strong><br>如果所有处于<strong>运行状态的任务时间片都为0</strong>，则将<strong>所有任务</strong>的时间片变为<code>（当前时间片/2）+（时间片初值）</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这样保证正在阻塞的程序的时间片会变得更高，使得被阻塞的程序优先级更高</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 假设一个进程的初始时间片为p，且一开始就一直阻塞，他的时间片最长也不会超过2p（p+p/2+p/4...）</div><pre class="line-numbers language-none"><code class="language-none">woid Schedule(void){  while(1)  {    c = -1;    next = 0;    i = NR_TASKS;    p = &amp;task[NR_TASKS];    while(--i)    {      //找到任务列表中，处于运行状态且时间片最大的任务      if((*p-&gt;state == TASK_RUNNING)&amp;&amp;(*p)-&gt;COUNTER &gt; c)      {        C = (*p)-&gt;counter;        next = i;      }      //如果找到则调度该程序      if(c) break;    }    //如果所有处于运行状态的任务时间片都为0，则将所有任务的时间片变为（当前时间片/2）+（时间片初值）    for(p = &amp;LAST_TASK;p &gt; &amp;FIRST_TASK;--p)    (*p)-&gt;counter = ((*p)-&gt;counter&gt;&gt;1)+(*p)-&gt;priotity;  }  switch_to(next);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计算机取指执行<br>系统调用也被称为程序的一个标准库<br>虚拟化CPU：将单个CPU转化为多个虚拟CPU<br>虚拟化内存：每个进程都有自己的虚拟地址空间，操作系统将其映射到物理内存上<br>时分共享技术：让一个进程只运行一个时间片，然后切换到其他进程<br>进程的重要组成部分：自己的内存即地址空间，寄存器状态<br>进程创建：将代码和静态数据（初始化变量）加载到进程的地址空间中（从磁盘中读入）只加载需要执行的部分，为程序的运行时栈（存放返局部变量、函数参数和返回地址）和堆（动态分配）分配内存，完成一些初始化任务，跳转到main函数，然后开始执行<br>每个进程都有对应的进程描述符</p><p>程序是一种状态机，执行一条语句就是从一个状态转移到下一个状态<br>gdb vim<br>C语言函数调用，每次调用会产生一个新的栈帧，每个栈中含有变量和pc指针等，返回就是弹栈，C程序的状态就是堆栈的状态</p><p>递归转化为非递归？汉诺塔</p><p>对于二进制程序，状态就是内存、寄存器等的值<br>计算机系统基础<br>程序本身只是计算，需要使用系统调用syscall请求操作系统调用硬件资源退出程序等</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 《操作系统导论》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统（二）</title>
      <link href="/2023/12/10/cao-zuo-xi-tong-er/"/>
      <url>/2023/12/10/cao-zuo-xi-tong-er/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统（二）"><a href="#操作系统（二）" class="headerlink" title="操作系统（二）"></a>操作系统（二）</h1><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="1-进程同步"><a href="#1-进程同步" class="headerlink" title="1.进程同步"></a>1.进程同步</h3><h4 id="1-1信号量"><a href="#1-1信号量" class="headerlink" title="1.1信号量"></a>1.1信号量</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 进程之间需要合作，需要通过信号量来相互通信，从而合理推进进程</div><p><strong>①代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 信号量是内核中的全局变量</div><pre class="line-numbers language-none"><code class="language-none">struct sqmaphore{  int value; //记录资源个数  PCB *queue; //记录等待在该信号量上的进程}//进程通过函数p申请使用资源，如果资源不足，则沉睡p(sqmaphore s){  s.value--;  if(s.value &lt; 0)  {    sleep(s.queue);  }}//进程通过v生产资源，如果资源不足，则唤醒v(sqmaphore s){  s.value++;  if(s.value &lt;= 0)  {    wake(s.queue);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②实例</strong></p><blockquote><p>有两个<strong>进程</strong>，分别为<strong>生产者</strong>和<strong>消费者</strong>，<strong>生产者</strong>向缓存区<strong>写入字符</strong>，<strong>消费者</strong>从缓存区<strong>读出字符</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不同的进程，对同一个信号量的使用是不相同的，对于生产者，只有缓存区有空位才能工作，对于消费者只有缓存区有数据才能工作</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其中mutex为互斥信号量，防止生产者和消费者同时对缓存区进行操作</div><pre class="line-numbers language-none"><code class="language-none">//定义缓存区int buffer [BUFFER_SIZE];//定义信号量sqmaphore full = 0;sqmaphore empty = BUFFER_SIZE;sqmaphore mutex = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//生产者程序Producer(*item,in){  P(empty);  p(mutex); //互斥信号量  将item写入到in对应位置;  v(mutex);  v(full);  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//消费者程序Consumer(*item,out){  P(full);  p(mutex); //互斥信号量  将out对应位置数据读出;  v(mutex);  v(empty);  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2临界区"><a href="#1-2临界区" class="headerlink" title="1.2临界区"></a>1.2临界区</h4><p><strong>①引言</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 信号量由多个进程共用，但是进程调度可能导致一个进程还没有修改好信号量，就切到另一个相关进程</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当一个进程修改但没有修改完信号量时，禁止其他进程修改信号量，即将信号量操作放入临界区中</div><pre class="line-numbers language-none"><code class="language-none">P1.register = empty;P1.register = P1.register - 1;//发生进程调度，切到P2进程P2.register = empty;P2.register = P2.register - 1;////发生进程调度，切到P1进程empty = P1.register<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②基本原则</strong></p><blockquote><p><strong>互斥进入</strong>：只有<strong>一个进程</strong>可以访问</p></blockquote><blockquote><p><strong>有空让进</strong>：当临界区<strong>空闲</strong>时，尽快使得<strong>一个进程</strong>进入</p></blockquote><blockquote><p><strong>优先等待</strong>：进程从<strong>发出进入请求</strong>到<strong>允许进入</strong>的时间不能过长</p></blockquote><pre class="line-numbers language-none"><code class="language-none">剩余区进入区临界区退出区剩余区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③实现</strong></p><blockquote><p><strong>面包店算法</strong>：当进程<strong>想进入临界区</strong>，会获得一个<strong>序号</strong>，<strong>序号最小</strong>的可以<strong>进入临界区</strong>，<strong>退出时</strong>序号变为<code>0</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 过于复杂，效率较低</div><blockquote><p><strong>阻止调度</strong>：进入临界区时，<strong>禁止中断（<code>cli()</code>）</strong>，直到<strong>退出临界区才允许中断（<code>sti()</code>）</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只适用于单CPU，因为cli和sti只能禁止当前CPU的中断，其他CPU可能还会进入临界区</div><blockquote><p><strong>硬件原子指令</strong>：<strong>临界区</strong>和<strong>互斥信号量</strong>使用非常相似，只要将<strong>互斥信号量的修改</strong>变为<strong>原子操作</strong>即可，即<strong>锁信号量</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">boolean TestAndSet(boolean &amp;x){  boolean rv = x;  x = true;  return rv;}剩余区while(TestAndSet(&amp;lock));临界区lock = false;剩余区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3死锁"><a href="#1-3死锁" class="headerlink" title="1.3死锁"></a>1.3死锁</h4><p><strong>①概述</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 多个进程互相等待对方持有资源时，谁都无法执行，这就是死锁</div><blockquote><p>如下，<strong>生产者</strong>使得<code>mutex</code>从<code>1</code>变为<code>0</code>，倘若其在<code>p(empty)</code>处<strong>阻塞</strong>，进程<strong>切换到消费者</strong>，<strong>消费者直接阻塞</strong>，无法清空缓冲区，从而导致<strong>生产者和消费者一起一直阻塞</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">//生产者程序Producer(*item,in){  P(mutex);  p(empty);   将item写入到in对应位置;  v(mutex);  v(full);  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//消费者程序Consumer(*item,out){  P(mutex);  p(full);   将out对应位置数据读出;  v(mutex);  v(empty);  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②出现条件</strong></p><blockquote><p><strong>互斥使用</strong>：资源只能被<strong>一个进程占有</strong></p></blockquote><blockquote><p><strong>不可抢占</strong>：只有对应进程<strong>自动放弃对应资源</strong>，才能被<strong>其他进程</strong>使用</p></blockquote><blockquote><p><strong>请求和保持</strong>：进程需要<strong>先占用一个资源</strong>，然后根据这个资源<strong>申请下一个资源</strong></p></blockquote><blockquote><p><strong>循环等待</strong>：资源分配中出现<strong>一个环路</strong></p></blockquote><p><strong>③处理方法</strong></p><blockquote><p><strong>预防</strong>：检测每个<strong>资源请求</strong>，如果<strong>造成死锁就自动拒绝</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 银行家算法：根据每个进程占有的资源、需要的资源和当前空余的资源决定进程执行序列</div><blockquote><p><strong>恢复</strong>：<strong>死锁出现时</strong>，使一些进程<strong>回滚</strong>，<strong>让出资源</strong></p></blockquote><blockquote><p><strong>忽略</strong>：<strong>忽略死锁</strong>，在<strong>运行一会就关机</strong>的机器上常用</p></blockquote><h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2.内存管理"></a>2.内存管理</h3><h4 id="2-1重定位"><a href="#2-1重定位" class="headerlink" title="2.1重定位"></a>2.1重定位</h4><p><strong>①引言</strong></p><blockquote><p><strong>逻辑地址</strong>：<strong>用户程序中直接给出</strong>的地址，如<code>call 40</code>中的<code>40</code><br><strong>物理地址</strong>：<strong>存储单元的编号</strong>，是<strong>真实且唯一</strong>的</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要通过逻辑地址找到对应的物理地址，即重定位</div><p><strong>②重定位时机</strong></p><blockquote><p><strong>编译时</strong>：程序只能放在<strong>内存固定位置</strong></p></blockquote><blockquote><p><strong>载入时</strong>:程序一旦<strong>载入内存就不能动了</strong></p></blockquote><blockquote><p><strong>运行时</strong>：<strong>动态</strong>记录<strong>逻辑地址</strong>和<strong>物理地址</strong>的关系</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一般采用运行时重定位，因为进程在内存中位置是动态变化的，只有卫星等一烧录就不改变的采用编译时重定位</div><h4 id="2-2内存分割"><a href="#2-2内存分割" class="headerlink" title="2.2内存分割"></a>2.2内存分割</h4><p><strong>①程序分段</strong></p><blockquote><p>程序由<strong>多个段</strong>组成，<strong>每个段</strong>有各自的<strong>特点和用途</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 程序段只读，数据段可写，栈段向下增长等</div><p><strong>②内存分区</strong></p><blockquote><p>将程序<strong>各个段</strong>放入<strong>内存分区</strong>中，<strong>分区大小根据段大小调整</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 程序内的逻辑地址由段号和段内偏移组成，每个段号和某块内存区域相对应（记录在进程的LDT表中）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 因为不可能每次一个程序段的大小刚好和空闲区域大小相当，内存分区会产生内存碎片，导致内存使用率低</div><blockquote><p>不能<strong>整理内存</strong>将<strong>内存碎片合并</strong>，因为<strong>得不偿失</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/OS_2.png" alt="内存分区"><br><strong>③内存分页</strong></p><blockquote><p>将<strong>程序</strong>分为多个<strong>固定大小的部分</strong>，并将<strong>内存</strong>分为多个<strong>固定大小的页</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个进程也有一个固定的页表，其中记录了两者的对应关系，即用页地址取代段地址</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 内存分页能减少内存的浪费，顶多浪费1页</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 为了减少内存的浪费，页的大小尽量得小，但是会造成页表过大</div><blockquote><p><strong>页表</strong>需要<strong>连续记录整个内存</strong>，这样<strong>便于查找（O(1)）</strong>，<strong>不连续记录</strong>则需要使用<strong>查找算法</strong>，得不偿失</p></blockquote><p><strong>④多级页表和快表</strong></p><blockquote><p><strong>多级页表</strong>：类似于<strong>多级目录</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 多级页表可以只连续记录使用了那段内存空间，不用记录整个内存空间，可以有效减少页表大小</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 但是多级页表增加了访问的次数，速度会慢一些</div><blockquote><p><strong>快表（<code>TLB</code>）</strong>：一个<strong>寄存器</strong>，存放<strong>经常使用的页</strong>，可以有效<strong>减少访问时间</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 快表可以通过硬件设置，直接找到对应的页，速度非常快，且由于程序内存访问具有局部性，TLB命中率高</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/OS_3.png" alt="多级页表"><br><strong>⑤段页结合</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 程序员希望使用段，物理内存希望使用页，为了同时满足上层和硬件，将段页结合使用</div><blockquote><p>如<code>call 300</code>，<code>300</code>为<strong>逻辑地址</strong>，根据<strong>LDT表</strong>找到对应<strong>虚拟地址</strong><code>00045300</code>，再根据<strong>页表</strong>找到对应<strong>物理地址</strong><code>0007300</code></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/OS_4.png" alt="段页结合"></p><h4 id="2-3内存交换"><a href="#2-3内存交换" class="headerlink" title="2.3内存交换"></a>2.3内存交换</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 换入换出可以实现大内存，假设虚拟内存有4G，但是实际物理内存只有1G，将访问的部分映射到物理内存即可</div><p><strong>①内存换入</strong></p><blockquote><p>当<strong>MMU</strong>无法根据<strong>用户请求的虚拟地址</strong>找到对应<strong>物理地址</strong>，产生<strong>缺页中断</strong>，调用对应<strong>中断处理程序</strong>，申请<strong>空闲页</strong>，将<strong>磁盘数据读入</strong>，做好<strong>映射关系</strong>，随后<strong>继续执行</strong></p></blockquote><p><strong>②内存换出</strong></p><blockquote><p>选择<strong>一页</strong>换出到<strong>磁盘</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 内存换出类似于进程调度，但是内存换出的频率更高，颗粒度更小</div><blockquote><p><strong>clock算法</strong>：<strong>每一页</strong>都有一个<strong>标志位</strong>，<strong>每次访问</strong>一个页时，<strong>硬件自动设置该位</strong>，为<code>1</code>置<code>0</code>，并<strong>继续扫描</strong>，为<code>0</code><strong>淘汰</strong>该页</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 为LUR算法粗略实现，即淘汰最近最少使用的页，因为LUR的精细实现代价太大，得不偿失</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果缺页情况很少，到最后很可能大部分页标志位为1，退化为FIFO，所以需要再来一个更快的扫描指针定时清除R位</div><h3 id="3-文件系统"><a href="#3-文件系统" class="headerlink" title="3.文件系统"></a>3.文件系统</h3><h4 id="3-1文件树"><a href="#3-1文件树" class="headerlink" title="3.1文件树"></a>3.1文件树</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对于用户来说，文件的位置就是它的路径，对于操作系统来说就是区块号，需要将两者相互转换</div><p><strong>①磁盘分区</strong></p><blockquote><p><strong>引导区</strong>：存放<strong>引导程序</strong></p></blockquote><blockquote><p><strong>超级块</strong>：记录磁盘<strong>整体信息</strong>，如<strong>各个区的起始位置</strong></p></blockquote><blockquote><p><strong>I节点位图</strong>：记录<strong>Inode指针区</strong>的<strong>统计信息</strong>，如有哪些<strong>空闲空间</strong></p></blockquote><blockquote><p><strong>盘块位图</strong>：记录<strong>数据区</strong>的<strong>统计信息</strong>，如有哪些<strong>空闲空间</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> inode为linux中记录文件信息（如区块号）的结构</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/OS_5.png" alt="磁盘分区"><br><strong>②路径到inode</strong></p><blockquote><p>如<code>/home/my</code>，首先从<strong>Inode指针区第一个位置</strong>找到<strong>根目录</strong>的<code>inode</code>指针，从而找到<strong>根目录</strong>的<code>inode</code><strong>结构</strong></p></blockquote><blockquote><p><strong>根目录</strong>的<code>inode</code><strong>结构</strong>中存放了<strong>各个目录项</strong>的<strong>名字字符串</strong>与其在<strong>Inode指针区的位置</strong></p></blockquote><blockquote><p><strong>匹配名字字符串</strong>即可找到<code>home</code><strong>目录</strong>的<code>inode</code><strong>结构</strong>，类似的<strong>一层一层寻找下去</strong></p></blockquote><p><strong>③inode到区块号</strong></p><blockquote><p><strong>每个文件</strong>对应的<strong>inode结构</strong>中有一个<strong>索引表</strong>，记录了文件<strong>各个部分对应的区块号</strong></p></blockquote><h4 id="3-2磁盘定位"><a href="#3-2磁盘定位" class="headerlink" title="3.2磁盘定位"></a>3.2磁盘定位</h4><p><strong>①原理</strong></p><blockquote><p><strong>柱面（C）</strong>：描述是<strong>磁头相对磁盘位置</strong></p></blockquote><blockquote><p><strong>磁头（H）</strong>：描述是使用<strong>哪一个磁头读</strong></p></blockquote><blockquote><p><strong>扇区（S）</strong>：磁盘的<strong>访问单位</strong>，长度为<strong>512字节</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 磁头移动到对应磁道，旋转磁盘找到对应的扇区，即根据CHS定位磁盘</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了提高计算机读取磁盘的效率，增大读写单位（每次读写扇区的个数），本质上是用空间换时间</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/OS_6.png" alt="磁盘"><br><strong>②区块号到CHS</strong></p><blockquote><p>由<strong>磁盘驱动程序</strong>将<strong>区块号</strong>转化为<strong>CHS</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 为了提升磁盘读写的效率（读取一个区块时，经量少切换磁头），区块在磁盘上是连续且有直接计算关系的：Block = CxHxS+HxS+S</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/OS_7.png" alt="区块到CHS"></p><h4 id="3-3磁盘调度"><a href="#3-3磁盘调度" class="headerlink" title="3.3磁盘调度"></a>3.3磁盘调度</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当多个区块需要被访问时，一时间只有一个能被访问</div><p><strong>①磁盘访问时间</strong></p><blockquote><p>由<strong>写入控制器时间</strong>、<strong>寻道时间</strong>、<strong>旋转时间</strong>和<strong>传输时间</strong>组成</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中主要部分是寻道时间和旋转时间，即找到对应扇区的时间</div><p><strong>②调度算法</strong></p><blockquote><p><strong>电梯算法</strong>：选择<strong>区块号和当前磁头位置距离最小</strong>的区块申请</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 单向选择，只有当一个方向的区块全部选择完，再反方向申请</div><h3 id="4-设备驱动"><a href="#4-设备驱动" class="headerlink" title="4.设备驱动"></a>4.设备驱动</h3><h4 id="4-1引言"><a href="#4-1引言" class="headerlink" title="4.1引言"></a>4.1引言</h4><p><strong>①概述</strong></p><blockquote><p>计算机<strong>使用外设的本质</strong>就是<strong>修改外设控制卡的寄存器</strong>，外设工作完毕后，通过<strong>中断</strong>向计算机<strong>传递信息</strong></p></blockquote><p><strong>②文件视图</strong></p><blockquote><p><strong>设备</strong>在<strong>操作系统中</strong>视为一种<strong>特殊的文件</strong>，也是通过类似于<code>open()</code>，<code>read()</code>等<strong>文件操作函数</strong>操作</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 《操作系统导论》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法基础</title>
      <link href="/2023/12/10/shu-ju-jie-gou-yu-suan-fa-yin-yan/"/>
      <url>/2023/12/10/shu-ju-jie-gou-yu-suan-fa-yin-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="数据结构与算法基础"><a href="#数据结构与算法基础" class="headerlink" title="数据结构与算法基础"></a>数据结构与算法基础</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 同样的问题，不同的方法效率不同，对于计算机的处理方法，主要有以下三个影响因素</div><p><strong>①数据的组织方式</strong></p><blockquote><p>如<strong>书架</strong>上<strong>书</strong>可以<strong>随便放</strong>，也可以<strong>分类放</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 前者方便存放，后者方便查找</div><p><strong>②空间利用率</strong></p><blockquote><p>如<strong>迭代</strong>与<strong>递归</strong>，后者所需空间<strong>远大于</strong>前者</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 递归需要保存结束前所有函数调用的栈帧，直到函数返回才会被释放</div><p><strong>③算法的巧妙程度</strong></p><blockquote><p>详情见<strong>实例</strong></p></blockquote><h4 id="1-2基本概念"><a href="#1-2基本概念" class="headerlink" title="1.2基本概念"></a>1.2基本概念</h4><p><strong>①定义</strong></p><blockquote><p><strong>算法</strong>：一个<strong>有限指令集</strong>，接受一些<strong>输入</strong>后，经过<strong>有限的步骤</strong>后，得到一定的<strong>输出</strong>，且能<strong>处理不合理输入</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 每条指令不能有歧义，且在计算机处理范围内，不依赖任何具体实现手段</div><blockquote><p><strong>数据结构</strong>：<strong>数据对象</strong>在计算机中的<strong>组织方式</strong>，可分为<strong>逻辑结构</strong>和<strong>物理存储结构</strong>两方面</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 逻辑结构可分为线性结构和非线性结构，物理存储结构分为连续存储和链式存储（零星分布）</div><blockquote><p>常见的<strong>线性结构</strong>有<strong>线性表</strong>，<strong>非线性结构</strong>有<strong>树</strong>、<strong>图</strong>等</p></blockquote><blockquote><p><strong>线性表</strong>采用<strong>数组</strong>实现，即为<strong>连续存储</strong>，采用<strong>链表</strong>实现，则为<strong>链式存储</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果缺少连续大块的内存空间，则数据结构最好采用链式存储</div><p><strong>②指标</strong></p><blockquote><p><strong>空间复杂度</strong><code>S(n)</code>：执行时<strong>占用存储单元的长度</strong></p></blockquote><blockquote><p><strong>时间复杂度</strong><code>T(n)</code>：执行时<strong>耗费的时长</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> n为问题的规模，即需要处理的数据的个数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常时间复杂度和空间复杂度并不能兼得，需要做出取舍</div><h4 id="1-3迭代与递归"><a href="#1-3迭代与递归" class="headerlink" title="1.3迭代与递归"></a>1.3迭代与递归</h4><p><strong>①迭代</strong></p><blockquote><p><strong>概述</strong>：采用<strong>循环结构</strong>，在满足一定的条件下<strong>重复执行某段代码</strong>，直到这个<strong>条件不再满足</strong></p></blockquote><p><strong>②递归</strong></p><blockquote><p><strong>递</strong>：程序不断<strong>调用自身</strong>，并设置一个<strong>终止条件</strong>，<strong>每次调用</strong>都更加<strong>靠近这个终止条件</strong></p></blockquote><blockquote><p><strong>归</strong>：当<strong>触发终止条件</strong>，便从<strong>根据终止条件对应的值</strong>开始<strong>逐层返回</strong>，计算最终结果</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通常终止条件是传入的参数为某一值，然后每次调用都靠近这个值</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 递归的本质就是将问题分解为更小的子问题，天然适合处理分分治问题</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 终止条件对应的结果是一个确切的结果，否则无法完成递归</div><p><strong>②举例</strong></p><blockquote><p><strong>概述</strong>：计算从<code>1</code>到<code>n</code>的<strong>总和</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 迭代适用于简单循环任务，递归适用于子问题分解任务</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 递归是基于函数调用栈实现的，可以显式利用一个栈模拟函数调用栈的行为，将递归转化为迭代</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 但是转换后会导致代码可读性变差，且对于一些复杂问题，模拟系统调用栈的行为较为困难</div><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//迭代实现</span><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">+=</span>i    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//递归实现</span><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//终止条件</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">//递</span>  <span class="token keyword">int</span> jmp <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//归</span>  <span class="token keyword">return</span> n<span class="token operator">+</span>jmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_0.png" alt="递归过程"></p><h3 id="2-复杂度分析"><a href="#2-复杂度分析" class="headerlink" title="2.复杂度分析"></a>2.复杂度分析</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①复杂度分析</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 复杂度计算的是其随问题规模增大时的变化趋势，即T(n)/S(n)的函数渐进上界</div><blockquote><p><strong>函数渐进上界</strong>：若存在<strong>正实数</strong><code>c</code>和<strong>实数</strong><code>n0</code>，当<code>n &gt; n0</code>时，均有<code>T(n) &lt;= cf(n)</code>，则<code>f(n)</code>为<code>T(n)</code><strong>渐进上界</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 由定义可知，渐进上界通常为函数的最高阶</div><p><strong>②算法相关空间</strong></p><blockquote><p><strong>输入空间</strong>：存储算法的<strong>输入数据</strong></p></blockquote><blockquote><p><strong>暂存空间</strong>：存储算法在<strong>运行过程</strong>中的<strong>变量</strong>、<strong>函数上下文</strong>等数据</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 还可分为存储变量等数据的数据空间，保存调用函数上下文的的栈帧数据，以及保存编译后程序指令的指令空间</div><blockquote><p><strong>输出空间</strong>：存储算法的<strong>输出数据</strong></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* 调用的函数 */</span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 执行某些操作...</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">algorithm</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token comment">// 输入空间</span><span class="token punctuation">{</span>     <span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">// 数据空间（常量）</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// 数据空间（变量）</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 栈帧空间（调用函数）</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>  <span class="token comment">// 输出空间</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2时间复杂度"><a href="#2-2时间复杂度" class="headerlink" title="2.2时间复杂度"></a>2.2时间复杂度</h4><p><strong>①估算思路</strong></p><blockquote><p>所有<strong>与n无关</strong>的部分看作<code>1</code>，因为其最后为<code>T(n)</code>的<strong>常数部分</strong></p></blockquote><blockquote><p><strong>与n有关</strong>的部分，将其分为<strong>多个独立部分</strong>，<strong>分别计算</strong>其复杂度，取其中<strong>最大的</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 每种部分的复杂度不尽相同，需要自己分析，本质上是算其中基本语句的执行次数，如单层循环的复杂度为n</div><blockquote><p>如果有<strong>嵌套类型</strong>，先从<strong>最里层嵌套</strong>计算，<strong>每一层嵌套的复杂度相乘</strong>得到<strong>整体的复杂度</strong></p></blockquote><p><strong>②常见类型</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 以最差时间复杂度为例</div><blockquote><p><code>O(n^2)</code>：<strong>两层嵌套循环</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">int quadratic(int n){    int count = 0;    // 循环次数与数组长度成平方关系    for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; n; j++) {            count++;        }    }    return count;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>O(2^n)</code>：以下<strong>递归次数为n</strong>，每次递归都将<strong>一分为二</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">/* 指数阶（递归实现） */int expRecur(int n){    if (n == 1)        return 1;    return expRecur(n - 1) + expRecur(n - 1) + 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>O(logn)</code>：以下只需要<strong>迭代logn次</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">int logarithmic(float n){    int count = 0;    while (n &gt; 1) {        n = n / 2;        count++;    }    return count;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>O(n!)</code>：以下<strong>循环n次</strong>，<strong>第一次</strong>循环<strong>分裂出n个</strong>，<strong>第二次</strong>循环<strong>每个都分裂出n-1个</strong>，依次类推</p></blockquote><pre class="line-numbers language-none"><code class="language-none">/* 阶乘阶（递归实现） */int factorialRecur(int n) {    if (n == 0)        return 1;    int count = 0;    for (int i = 0; i &lt; n; i++) {        count += factorialRecur(n - 1);    }    return count;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3空间复杂度"><a href="#2-3空间复杂度" class="headerlink" title="2.3空间复杂度"></a>2.3空间复杂度</h4><p><strong>①估算思路</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通常只关心最差空间复杂度，其中最差指最差输入数据和峰值内存占用</div><blockquote><p><strong>概述</strong>：分别计算<strong>各个空间</strong>的<strong>空间复杂度</strong>，取<strong>最大值</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 空间复杂度的计算主要计算占用的内存数量</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 其中递归函数需要注意栈帧空间的大小</div><blockquote><p><strong>迭代</strong>过程<strong>每次调用</strong>完就<strong>释放了栈帧空间</strong>，空间复杂度为<code>O(1)</code></p></blockquote><blockquote><p><strong>递归</strong>过程每次调用<strong>没有释放栈帧空间</strong>，故空间复杂度为<code>O(n)</code></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 执行某些操作</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* 循环 O(1) */</span><span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/* 递归 O(n) */</span><span class="token keyword">void</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②常见类型</strong></p><blockquote><p><code>O(n^2)</code>：构建<code>n*n</code>的<strong>矩阵</strong></p></blockquote><blockquote><p><code>O(2^n)</code>：构建<code>n</code>层的<strong>二叉树</strong></p></blockquote><hr><h3 id="3-经典算法实例"><a href="#3-经典算法实例" class="headerlink" title="3.经典算法实例"></a>3.经典算法实例</h3><blockquote><p><strong>最大子列和问题</strong>：给定<strong>N个整数</strong>的序列，求出其中<strong>连续n个子列和</strong>的<strong>最大值</strong>，其中<code>n≤N</code></p></blockquote><h4 id="3-1-暴力穷举法"><a href="#3-1-暴力穷举法" class="headerlink" title="3.1.暴力穷举法"></a>3.1.暴力穷举法</h4><p><strong>①基本思想</strong></p><blockquote><p>求出<strong>所有连续子列和</strong>，从中找出<strong>最大</strong>的子列和，<strong>时间复杂度</strong>为<code>O(n^3)</code></p></blockquote><p><strong>②代码实现</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">MaxSubseqSum1</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> ThisSum<span class="token punctuation">,</span>MaxSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> #确定起点  <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span> #确定终点    <span class="token punctuation">{</span>      ThisSum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span>i<span class="token punctuation">;</span>k<span class="token operator">&lt;=</span>j<span class="token punctuation">,</span>k<span class="token operator">++</span><span class="token punctuation">)</span> #将第i到第j个叠加到一起      <span class="token punctuation">{</span>        ThisSum<span class="token operator">=</span>ThisSum<span class="token operator">+</span>A<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>ThisSum<span class="token operator">&gt;</span>MaxSum<span class="token punctuation">)</span>      MaxSum<span class="token operator">=</span>ThisSum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> MaxSum<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2改进的暴力穷举法"><a href="#3-2改进的暴力穷举法" class="headerlink" title="3.2改进的暴力穷举法"></a>3.2改进的暴力穷举法</h4><p><strong>①思想</strong></p><blockquote><p>基于上述算法做出了一定<strong>改进</strong>。计算子列和是在<strong>已经计算完成</strong>的子列和<strong>加上最新项</strong>更新获得，可以<strong>省去k循环</strong>，<strong>时间复杂度</strong>为<code>O(n^2)</code></p></blockquote><p><strong>②代码实现</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">MaxSubseqSum2</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> ThisSum<span class="token punctuation">,</span>MaxSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">/*i是子列左端*/</span>  <span class="token punctuation">{</span>    ThisSum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">/*j是子列右端*/</span>    <span class="token punctuation">{</span>      ThisSum<span class="token operator">=</span>ThisSum<span class="token operator">+</span>A<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/*对于相同的i和不同的j，只需要在j-1的基础上累加最新项即可*/</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>ThisSum<span class="token operator">&gt;</span>MaxSum<span class="token punctuation">)</span>      MaxSum<span class="token operator">=</span>ThisSum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> MaxSum<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3分而治之"><a href="#3-3分而治之" class="headerlink" title="3.3分而治之"></a>3.3分而治之</h4><p><strong>①思想</strong>：？<br><strong>②代码实现</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXN</span> <span class="token expression"><span class="token number">100000</span></span></span><span class="token keyword">int</span> <span class="token function">MaxofThreeNum</span> <span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span>  \\ 求三个数中得最大值<span class="token punctuation">{</span>   <span class="token keyword">int</span> maxSum<span class="token punctuation">;</span>    maxSum <span class="token operator">=</span> a <span class="token operator">&gt;</span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>    maxSum <span class="token operator">=</span> maxSum <span class="token operator">&gt;</span> c <span class="token operator">?</span> maxSum <span class="token operator">:</span> c<span class="token punctuation">;</span>    <span class="token keyword">return</span> maxSum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">DivideConquer</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> mid<span class="token punctuation">;</span>    <span class="token keyword">int</span> leftMaxSum<span class="token punctuation">,</span> rightMaxSum<span class="token punctuation">;</span>    <span class="token keyword">int</span> leftBoardSum<span class="token punctuation">,</span> rightBoardSum<span class="token punctuation">;</span>    <span class="token keyword">int</span> leftMaxBoardSum<span class="token punctuation">,</span> rightMaxBoardSum<span class="token punctuation">;</span>   <span class="token comment">/* 退出条件 */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span>         <span class="token keyword">return</span> data<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* “分的过程” */</span>    mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">//找到中分点</span>        <span class="token comment">/* 递归求两边的最大值 */</span>    leftMaxSum <span class="token operator">=</span> <span class="token function">DivideConquer</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 左边最大值</span>    rightMaxSum <span class="token operator">=</span> <span class="token function">DivideConquer</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 右边最大值</span>     <span class="token comment">/* 跨越边界的最大值 := leftMaxBoardSum + rightMaxBoardSum  */</span>     leftMaxBoardSum <span class="token operator">=</span> data<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>     leftBoardSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> mid<span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> left<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        leftBoardSum <span class="token operator">+=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leftBoardSum <span class="token operator">&gt;</span> leftMaxBoardSum<span class="token punctuation">)</span>            leftMaxBoardSum <span class="token operator">=</span> leftBoardSum<span class="token punctuation">;</span>     <span class="token punctuation">}</span>   <span class="token comment">//左边界扫描</span>    rightMaxBoardSum <span class="token operator">=</span> data<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    rightBoardSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        rightBoardSum <span class="token operator">+=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>rightBoardSum <span class="token operator">&gt;</span> rightMaxBoardSum<span class="token punctuation">)</span>            rightMaxBoardSum <span class="token operator">=</span> rightBoardSum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment">//有边界扫描 </span>    <span class="token comment">/* 治的过程，最大值为左边的最大值、右边最大值，跨越边界最大值之中的最大值 */</span>    <span class="token keyword">return</span> <span class="token function">MaxofThreeNum</span><span class="token punctuation">(</span>leftMaxSum<span class="token punctuation">,</span> rightMaxSum<span class="token punctuation">,</span> leftMaxBoardSum <span class="token operator">+</span> rightMaxBoardSum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">MaxSubSeqSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">)</span>  <span class="token comment">// 改变函数接口</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">DivideConquer</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">int</span> data<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">MaxSubSeqSum</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-在线处理"><a href="#5-在线处理" class="headerlink" title="5.在线处理"></a>5.在线处理</h4><p><strong>①思想</strong></p><blockquote><p>一开始<strong>子列左端为A[0]<strong>，逐个</strong>向右累加</strong>，若当前子列和<strong>为负数则舍去</strong>，因为一个<strong>负的子列和部分只会使得子列和变小</strong>,算法时间复杂度为<code>O(n)</code></p></blockquote><p><strong>②代码实现</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">MaxSubseqSum4</span><span class="token punctuation">(</span><span class="token keyword">int</span> A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> ThisSum<span class="token punctuation">,</span>MaxSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>N<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token comment">/*i是子列左端*/</span>  <span class="token punctuation">{</span>    ThisSum<span class="token operator">=</span>ThisSum<span class="token operator">+</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ThisSum<span class="token operator">&gt;=</span>MaxSum<span class="token punctuation">)</span>    MaxSum<span class="token operator">=</span>ThisSum<span class="token punctuation">;</span>    <span class="token keyword">else</span>    ThisSum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> MaxSum<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索算法</title>
      <link href="/2023/12/10/sou-suo-suan-fa/"/>
      <url>/2023/12/10/sou-suo-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h4><p><strong>①定义</strong></p><blockquote><p>在<strong>数据结构</strong>中搜索<strong>一个或一组满足特定条件的元素</strong></p></blockquote><p><strong>②分类</strong></p><blockquote><p><strong>遍历搜索</strong>：<strong>暴力穷举</strong>、<strong>广度优先</strong>和<strong>深度优先</strong>等</p></blockquote><blockquote><p><strong>基于先验信息搜索</strong>：<strong>二分查找</strong>、<strong>哈希查找</strong>、<strong>树查找</strong>等</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 效率高，但是需要对数据进行预处理和维护，需要额外的时间和空间开支</div><h4 id="1-2搜索算法的选择"><a href="#1-2搜索算法的选择" class="headerlink" title="1.2搜索算法的选择"></a>1.2搜索算法的选择</h4><blockquote><p><strong>遍历</strong>：适用于<strong>数据更新频繁</strong>的场景</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 线性搜索适用于数组和链表，广度优先和深度优先使用于图和树</div><blockquote><p><strong>二分查找</strong>：适用于<strong>数据量大</strong>，<strong>数据更新不频繁</strong>的场景</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 数据更新频繁，导致数据处理和维护成本过高</div><blockquote><p><strong>哈希查找</strong>：适合<strong>数据量不大</strong>且<strong>查询性能要求高</strong>的场景，但无法提供<strong>有序性数据</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 哈希查找时间复杂度为O(1)，但需要额外维护哈希表，空间复杂度较高</div><blockquote><p><strong>树查找</strong>：适用于<strong>海量数据</strong>且<strong>数据更新不频繁</strong>的场景</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 为了防止树退化，每次数据更新都需要维持树的平衡</div><h3 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2.二分查找"></a>2.二分查找</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><blockquote><p>给定一<strong>长度</strong>为<code>n</code>，<strong>从小到大</strong>的<strong>整数数组</strong><code>nums</code>，数组不包含<strong>重复元素</strong>，查找并返回<strong>对应元素</strong><code>target</code>，若<strong>不存在</strong>则返回<code>-1</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上是基于分治的搜索算法，每轮减少一半搜索范围，时间复杂度为O(logn)，且无需额外空间</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 仅仅适用于有序数组，因为数组访问效率高，且为了保持数组有序性，每次插入的时间复杂度为O(n)</div><h4 id="2-2工作原理"><a href="#2-2工作原理" class="headerlink" title="2.2工作原理"></a>2.2工作原理</h4><blockquote><p><strong>初始化</strong>两<strong>“指针”</strong><code>head = 0</code>和<code>tail = n-1</code>，采用<strong>双闭区间</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> tail还可取n，并采用左闭右开区间，对应的实现细节也有所不同，但是更加推荐双闭区间</div><blockquote><p>取<code>middle = (head+tail)/2</code>，<strong>向下取整</strong>，根据<code>num[middle]</code>和<code>target</code>的关系决定<strong>对应操作</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> head和tail均为int类型，head+tail可能会超过int类型的范围，对于大型数据，常取middle = head+(tail-head)/2</div><blockquote><p><strong>若</strong><code>num[middle] &lt; target</code>，说明<code>target</code>在区间<code>[middle+1,tail]</code>中，取<code>head = middle+1</code><strong>更新区间</strong></p></blockquote><blockquote><p><strong>若</strong><code>num[middle] &gt; target</code>，说明<code>target</code>在区间<code>[head,middle-1]</code>中，取<code>tail = middle-1</code><strong>更新区间</strong></p></blockquote><blockquote><p><strong>若</strong><code>num[middle] == target</code>，<strong>直接返回</strong><code>middle</code>即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以数组从小到大为前提，本质上还是缩小区间</div><blockquote><p><strong>一直依此循环</strong>，直到<strong>找到</strong><code>target</code>，或者<code>head &gt; tail</code>，表示<code>target</code><strong>不在数组中</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若数组最大元素小于target，可能会导致head指针越界，即结束时head == n，不过对查找结果无影响</div><h4 id="2-3代码实现"><a href="#2-3代码实现" class="headerlink" title="2.3代码实现"></a>2.3代码实现</h4><pre class="line-numbers language-none"><code class="language-none">/* 二分查找（双闭区间） */int binarySearch(int *nums, int len, int target) {    // 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素    int i = 0, j = len - 1;    // 循环，当搜索区间为空时跳出（当 i &gt; j 时为空）    while (i &lt;= j) {        int m = i + (j - i) / 2; // 计算中点索引 m        if (nums[m] &lt; target)    // 此情况说明 target 在区间 [m+1, j] 中            i = m + 1;        else if (nums[m] &gt; target) // 此情况说明 target 在区间 [i, m-1] 中            j = m - 1;        else // 找到目标元素，返回其索引            return m;    }    // 未找到目标元素，返回 -1    return -1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4基于二分查找的插入"><a href="#2-4基于二分查找的插入" class="headerlink" title="2.4基于二分查找的插入"></a>2.4基于二分查找的插入</h4><p><strong>①引言</strong></p><blockquote><p>给定一<strong>长度</strong>为<code>n</code>，<strong>从小到大</strong>的<strong>整数数组</strong><code>nums</code>，将<code>target</code>插入<strong>数组</strong><code>nums</code>中，并<strong>保持其有序性</strong>，若数组中<strong>已存在</strong>元素<code>target</code>，则插入到<strong>最左边target的左方</strong></p></blockquote><p><strong>②思路</strong></p><blockquote><p>使用<strong>二分法</strong>查找<code>target</code></p></blockquote><blockquote><p>若<strong>找到</strong>对应<code>target</code>，还需要<strong>进一步</strong>找到<strong>最左边的target</strong>，<strong>插入位置</strong>即<strong>最左边的<code>target</code>位置</strong></p></blockquote><blockquote><p>修改<strong>二分法</strong>查找过程中<code>nums[middle] == target</code>的<strong>步骤</strong>，使用<code>tail = middle-1</code><strong>更新区间</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> nums[middle] == target说明在最左边target左边的元素在[head,middle-1]中，迭代到最后i指向最左边的target</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 插入到对应元素左方，即替代对应元素</div><blockquote><p>若<strong>没找到</strong>对应<code>target</code>，<strong>插入位置</strong>即<strong>二分结束时的head指针</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 二分过程中，head和tail不断接近target，结束时，head指向首个大于target的元素，tail指向首个小于target的元素</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 要注意head指针越界的情况</div><p><strong>③代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 二分查找插入点（存在重复元素） */int binarySearchInsertion(int *nums, int numSize, int target) {    int i = 0, j = numSize - 1; // 初始化双闭区间 [0, n-1]    while (i &lt;= j) {        int m = i + (j - i) / 2; // 计算中点索引 m        if (nums[m] &lt; target) {            i = m + 1; // target 在区间 [m+1, j] 中        } else if (nums[m] &gt; target) {            j = m - 1; // target 在区间 [i, m-1] 中        } else {            j = m - 1; // 首个小于 target 的元素在区间 [i, m-1] 中        }    }    // 返回插入点 i    return i;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5基于二分查找的边界查找"><a href="#2-5基于二分查找的边界查找" class="headerlink" title="2.5基于二分查找的边界查找"></a>2.5基于二分查找的边界查找</h4><p><strong>①引言</strong></p><blockquote><p>给定一<strong>长度</strong>为<code>n</code>，<strong>从小到大</strong>的<strong>整数数组</strong><code>nums</code>，若其中有<code>target</code>元素，返回其<strong>左/右边界</strong>，<strong>没有</strong>则返回<code>-1</code></p></blockquote><p><strong>②思路1</strong></p><blockquote><p><strong>基于二分查找的插入</strong>本质上就是在<strong>寻找左边界</strong>，基于该方法<strong>稍作修改</strong>即可</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> target+1的左边界的左边，即target的右边界，故查找target的右边界等价于查找target+1的左边界</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这里的target+1也可以不存在于数组中</div><pre class="line-numbers language-none"><code class="language-none">/* 二分查找最左一个 target */int binarySearchLeftEdge(int *nums, int numSize, int target) {    // 等价于查找 target 的插入点    int i = binarySearchInsertion(nums, numSize, target);    // 未找到 target ，返回 -1    if (i == numSize || nums[i] != target) {        return -1;    }    // 找到 target ，返回索引 i    return i;}/* 二分查找最右一个 target */int binarySearchRightEdge(int *nums, int numSize, int target) {    // 转化为查找最左一个 target + 1    int i = binarySearchInsertion(nums, numSize, target + 1);    // j 指向最右一个 target ，i 指向首个大于 target 的元素    int j = i - 1;    // 未找到 target ，返回 -1    if (j == -1 || nums[j] != target) {        return -1;    }    // 找到 target ，返回索引 j    return j;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③思路2</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 二分查找不存在的元素target时，最终head和tail会分别指向首个大于、小于target的位置</div><blockquote><p>将查找<code>target</code>的<strong>左边界</strong>，转化为<strong>二分查找</strong><code>target-0.5</code>，并<strong>返回</strong><code>head</code></p></blockquote><blockquote><p>将查找<code>target</code>的<strong>右边界</strong>，转化为<strong>二分查找</strong><code>target+0.5</code>，并<strong>返回</strong><code>tail</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这里加减0.5以确保其一定不再数组中</div><hr><h3 id="3-哈希查找"><a href="#3-哈希查找" class="headerlink" title="3.哈希查找"></a>3.哈希查找</h3><h4 id="3-1引言"><a href="#3-1引言" class="headerlink" title="3.1引言"></a>3.1引言</h4><blockquote><p>给定一个<strong>整数数组</strong><code>nums</code>和一个<strong>目标元素</strong><code>target</code>，在数组中搜索<strong>和为<code>target</code>的两个元素</strong>，并返回它们的<strong>数组索引</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果采用暴力穷举，时间复杂度为O(n^2)，过于复杂</div><h4 id="3-2思路"><a href="#3-2思路" class="headerlink" title="3.2思路"></a>3.2思路</h4><blockquote><p>建立一<strong>哈希表</strong>作为<strong>辅助</strong>，<code>key</code>为<strong>数组元素</strong>，<code>value</code>为<strong>元素索引</strong></p></blockquote><blockquote><p><strong>遍历数组</strong>，<strong>每次</strong>判断<code>target - nums[i]</code>是否在<strong>哈希表</strong>中（若<strong>存在</strong>则返回<strong>两个元素的索引</strong>并<strong>退出</strong>），并<strong>将该元素添加进哈希表</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 时间复杂度为O(n)，但空间复杂度变为O(n)，本质是用空间换时间</div><h4 id="3-3代码实现"><a href="#3-3代码实现" class="headerlink" title="3.3代码实现"></a>3.3代码实现</h4><pre class="line-numbers language-none"><code class="language-none">/* 哈希表 */typedef struct {    int key;    int val;    UT_hash_handle hh; // 基于 uthash.h 实现} HashTable;/* 哈希表查询 */HashTable *find(HashTable *h, int key) {    HashTable *tmp;    HASH_FIND_INT(h, &amp;key, tmp);    return tmp;}/* 哈希表元素插入 */void insert(HashTable *h, int key, int val) {    HashTable *t = find(h, key);    if (t == NULL) {        HashTable *tmp = malloc(sizeof(HashTable));        tmp-&gt;key = key, tmp-&gt;val = val;        HASH_ADD_INT(h, key, tmp);    } else {        t-&gt;val = val;    }}/* 哈希查找 */int *twoSumHashTable(int *nums, int numsSize, int target, int *returnSize) {    HashTable *hashtable = NULL;    for (int i = 0; i &lt; numsSize; i++) {        HashTable *t = find(hashtable, target - nums[i]);        if (t != NULL) {            int *res = malloc(sizeof(int) * 2);            res[0] = t-&gt;val, res[1] = i;            *returnSize = 2;            return res;        }        insert(hashtable, nums[i], i);    }    *returnSize = 0;    return NULL;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树形结构（上）</title>
      <link href="/2023/12/10/shu-xing-jie-gou-shang/"/>
      <url>/2023/12/10/shu-xing-jie-gou-shang/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="树形结构（上）"><a href="#树形结构（上）" class="headerlink" title="树形结构（上）"></a>树形结构（上）</h2><h3 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1.二叉树"></a>1.二叉树</h3><h4 id="1-1树"><a href="#1-1树" class="headerlink" title="1.1树"></a>1.1树</h4><p><strong>①定义</strong></p><blockquote><p>每个树都有一个<strong>根节点</strong>，<strong>其余节点</strong>可分为<strong>互不相交的子树</strong>，且只有<strong>一个父节点</strong>和<strong>若干个子节点</strong>，<strong>没有子节点</strong>的节点称为<strong>叶节点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 树明显是基于递归定义的，所以有关树的很多算法都用到了递归思想</div><p><strong>②儿子兄弟表示法</strong></p><blockquote><p><strong>每个节点</strong>存储<strong>两个指针</strong>，<strong>左指针</strong>指向<strong>最左的儿子节点</strong>，<strong>右指针</strong>指向<strong>相邻兄弟节点</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 所有的树都可以通过儿子兄弟表示法转化为二叉树，所以树的主要研究对象为二叉树</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_3.png" alt="儿子-兄弟表示法"></p><h4 id="1-2二叉树"><a href="#1-2二叉树" class="headerlink" title="1.2二叉树"></a>1.2二叉树</h4><p><strong>①定义</strong></p><blockquote><p>由<strong>根节点</strong>和同为<strong>二叉树</strong>的<strong>左子树</strong>和<strong>右子树</strong>组成，即<strong>每个节点</strong>最多只能有<strong>两个子节点</strong>，称为<strong>左节点</strong>和<strong>右节点</strong></p></blockquote><p><strong>②特殊二叉树</strong></p><blockquote><p><strong>完美二叉树</strong>：当二叉树有<strong>n层</strong>时，有<strong>2^n-1个节点</strong>，<strong>叶子节点</strong>只能出现在<strong>最下面一层</strong></p></blockquote><blockquote><p><strong>完全二叉树</strong>：对二叉树中节点<strong>从上至下</strong>，<strong>从左往右</strong>进行<strong>编号</strong>，<strong>编号为i</strong>的节点与<strong>满二叉树</strong>中<strong>编号为i</strong>的节点<strong>位置相同</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 完全二叉树即从某一叶节点缺失所有右边的兄弟节点，左边的兄弟节点不缺失的完美二叉树</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_4.png" alt="特殊二叉树"></p><h4 id="1-3二叉树的存储结构"><a href="#1-3二叉树的存储结构" class="headerlink" title="1.3二叉树的存储结构"></a>1.3二叉树的存储结构</h4><p><strong>①链表</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 二叉树通常使用链表存储，缺省情况下树使用链表实现</div><blockquote><p><strong>节点结构</strong>分别有<strong>指向左子节点的指针</strong>和<strong>指向右子节点的指针</strong>，<strong>整个二叉树</strong>只需要知道其<strong>根节点指针</strong>即可<br><strong>②数组</strong><br>将二叉树转化为<strong>广义的完全二叉树</strong>，<strong>从上至下</strong>，<strong>从左往右</strong>进行<strong>编号</strong>，节点的<strong>编号</strong>就是其在<strong>数组的索引</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不存在的节点表示为空</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若一节点为i，则其左子节点为2i+1，右子节点为2i+2，父节点为(i-1)/2，访问速度较快</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 数组需要连续内存空间，不适合存储数据量过大的树，且若二叉树和完全二叉树相差较大时，会造成巨大的空间浪费</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_7.png" alt="二叉树的数组表示"></p><h3 id="2-二叉树的遍历"><a href="#2-二叉树的遍历" class="headerlink" title="2.二叉树的遍历"></a>2.二叉树的遍历</h3><h4 id="2-1层序遍历"><a href="#2-1层序遍历" class="headerlink" title="2.1层序遍历"></a>2.1层序遍历</h4><p><strong>①定义</strong></p><blockquote><p><strong>向下逐层</strong>遍历二叉树，<strong>每一层</strong>按照<strong>从左到右</strong>的顺序<strong>访问节点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 层序遍历本质上是广度优先遍历，体现了一种“一圈一圈向外扩展”的逐层遍历方式</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 层序遍历的逐层推进和队列的先进先出本质上一样的</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_5.png" alt="层序遍历"><br><strong>②非递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">//时间复杂度和空间复杂度均为O(n)int *levelOrder(TreeNode *root, int *size) {    /* 辅助队列 */    int front, rear;    int index, *arr;    TreeNode *node;    TreeNode **queue;    /*动态申请队列，队列保存的是节点指针，所以最终表现形态为节点指针的指针*/    queue = (TreeNode **)malloc(sizeof(TreeNode *) * MAX_SIZE);    // 队列伪指针    front = 0, rear = 0;    // 加入根节点    queue[rear++] = root;    // 初始化一个列表，用于保存遍历序列    /* 辅助数组 */    arr = (int *)malloc(sizeof(int) * MAX_SIZE);    // 数组指针    index = 0;    /*利用队列实现层序遍历*/    while (front &lt; rear) {        // 队列出队        node = queue[front++];        // 保存节点值        arr[index++] = node-&gt;val;        if (node-&gt;left != NULL) {            // 左子节点入队            queue[rear++] = node-&gt;left;        }        if (node-&gt;right != NULL) {            // 右子节点入队            queue[rear++] = node-&gt;right;        }    }    // 更新数组长度的值    *size = index;    arr = realloc(arr, sizeof(int) * (*size));    // 释放辅助数组空间    free(queue);    return arr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2前序、中序和后续遍历"><a href="#2-2前序、中序和后续遍历" class="headerlink" title="2.2前序、中序和后续遍历"></a>2.2前序、中序和后续遍历</h4><p><strong>①定义</strong></p><blockquote><p><strong>前序遍历</strong>：先访问<strong>根节点</strong>，<strong>前序遍历</strong>其<strong>左子树</strong>，再<strong>前序遍历</strong>其<strong>右子树</strong></p></blockquote><blockquote><p><strong>中序遍历</strong>：<strong>中序遍历</strong>其<strong>左子树</strong>，访问<strong>根节点</strong>，再<strong>中序遍历</strong>其<strong>右子树</strong></p></blockquote><blockquote><p><strong>后序遍历</strong>：<strong>后序遍历</strong>其<strong>左子树</strong>，<strong>后续遍历</strong>其<strong>右子树</strong>，访问其<strong>根节点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这三种遍历本质上是深度优先遍历，体现了一种“先走到尽头，再回溯继续”的遍历方式</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 对于一个节点，有三次访问的时刻，即第一次访问（没有访问其子节点），从左子树返回访问和从右子树返回访问，三种遍历方式就是分别再三次访问时输出</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_6.png" alt="前序、中序和后续遍历"><br><strong>②三种遍历的递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">//时间复杂度和空间复杂度均为O(n)/* 前序遍历 */void preOrder(TreeNode *root, int *size) {    if (root == NULL)        return;    // 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树    arr[(*size)++] = root-&gt;val;    preOrder(root-&gt;left, size);    preOrder(root-&gt;right, size);}/* 中序遍历 */void inOrder(TreeNode *root, int *size) {    if (root == NULL)        return;    // 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树    inOrder(root-&gt;left, size);    arr[(*size)++] = root-&gt;val;    inOrder(root-&gt;right, size);}/* 后序遍历 */void postOrder(TreeNode *root, int *size) {    if (root == NULL)        return;    // 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点    postOrder(root-&gt;left, size);    postOrder(root-&gt;right, size);    arr[(*size)++] = root-&gt;val;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3.二叉搜索树"></a>3.二叉搜索树</h3><h4 id="3-1定义"><a href="#3-1定义" class="headerlink" title="3.1定义"></a>3.1定义</h4><blockquote><p><strong>左子树</strong>中<strong>所有节点</strong>的值<code>&lt;</code><strong>根节点</strong>的值<code>&lt;</code><strong>右子树</strong>中<strong>所有节点</strong>的值，且其<strong>左右子树</strong>都是<strong>二叉搜索树</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 二叉搜索树的中序遍历序列是升序的，所以从二叉搜索树中获取有序数据时间复杂度仅仅为O(n)</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 二叉搜索树的增删查改操作的时间复杂度均为O(logn)</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 二叉搜索树不允许存在重复节点</div><h4 id="3-2查找"><a href="#3-2查找" class="headerlink" title="3.2查找"></a>3.2查找</h4><p><strong>①递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">Position Find(ElementType x,BinTree BST){  /*没找到，递归退出条件  if(!Bst)    return NULL;  /*递归查找  if(x&gt;Bst-&gt;Data)    return Find(x,BST-&gt;Right);  else if(x&lt;Bst-&gt;Data)    return Find(x,BST-&gt;Left);  /*成功找到，递归退出条件  else    return BST;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②非递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">Position Find(ElementType x,BinTree BST){  while(BST)  {    if(x &gt; BST-&gt;Data)      BST = BST-&gt;Right;    else if(x &lt; BST-&gt;Data)      BST = BST-&gt;Left;    else      return BST;  }  return NULL;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3插入"><a href="#3-3插入" class="headerlink" title="3.3插入"></a>3.3插入</h4><p><strong>①递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">BinTree Insert(ElementType x,BinTree BST){  /*递归退出条件，找到对应插入位置，即一个空位置  if(!BST)  {    BST = malloc(sizeof(struct TreeNode));    BST-&gt;Data = x;    BST-&gt;Left = BST-&gt;Right =NULL;  }  else  {    if(x &lt; BST-&gt;Data)      BST-&gt;Left = Insert(x,BST-&gt;Left);     else if(x &gt; BST-&gt;Data)      BST-&gt;Right = Insert(x,BST-&gt;Right);  }  return BST;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②非递归实现</strong></p><pre class="line-numbers language-none"><code class="language-none">BinTree Insert(ElementType x,BinTree BST){  while(BST)  {    if(x &gt; BST-&gt;Data)    {      if(!BST-&gt;Right)      {      BST-&gt;Right = malloc(sizeof(struct TreeNode));      BST-&gt;Right-&gt;Data = x;      BST-&gt;Right-&gt;Right = BST-&gt;Right-&gt;Left = NULL;      return BST-&gt;Right      }      else      BST = BST-&gt;Right    }    else if(x &lt; BST-&gt;Data)    {      if(!BST-&gt;Left)      {      BST-&gt;Left = malloc(sizeof(struct TreeNode));      BST-&gt;Left-&gt;Data = x;      BST-&gt;Left-&gt;Right = BST-&gt;Left-&gt;Left = NULL;      return BST-&gt;Right      }      else      BST = BST-&gt;Left;    }    else     return BST;  }  BST = malloc(sizeof(struct TreeNode));  BST-&gt;Data = x;  BST-&gt;Left = Bst-&gt;Right = NULL;  return BST;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4删除"><a href="#3-4删除" class="headerlink" title="3.4删除"></a>3.4删除</h4><p><strong>①思路</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要保证删除节点后的二叉树依旧是搜索二叉树，所以对于不同的节点，删除操作是不同的</div><blockquote><p><strong>叶节点</strong>：<strong>直接删除</strong>即可</p></blockquote><blockquote><p><strong>节点的度为1</strong>：将<strong>待删除节点</strong>替换为<strong>子节点</strong></p></blockquote><blockquote><p><strong>节点的度为2</strong>：将其<strong>右子树最小元素</strong>或者<strong>左子树最大元素</strong>代替之</p></blockquote><p><strong>②代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">BinTree Delete(ElementType x,BinTree BST){  Position Tmp;  if(!BST)    print("未找到该元素")；  else if(x &lt; BST-&gt;Data)    BST-&gt;Left = Delete(x,BST-&gt;Left);  else if(x &gt; BST-&gt;Data)    BST-&gt;Right = Delete(x,BST-&gt;Right);  else    /*当有两个孩子    if(BST-&gt;Left &amp;&amp; BST-&gt;Right)    {      /*找到其右子树最小元素替代之      Tmp = FindMin(BST-&gt;Right);      BST-&gt;Data = Tmp-&gt;Data;      /*删除其右子树最小元素      BST-&gt;Right = Delete(BST-&gt;Data,BST-&gt;Right);    }    /*有一个或者没有孩子    else    {      Tmp = BST      if(!BST-&gt;Left)        BST = BST-&gt;Right      else if(!BST-&gt;Right)        BST = BST-&gt;Left;      free(Tmp)    }  return BST;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-AVL树"><a href="#4-AVL树" class="headerlink" title="4.AVL树"></a>4.AVL树</h3><h4 id="4-1引言"><a href="#4-1引言" class="headerlink" title="4.1引言"></a>4.1引言</h4><p><strong>①树的退化</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 多次插入和删除，可能导致树退化为链表，很多操作将从O(logn)变为O(n)</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_8.png" alt="树的退化"></p><p><strong>②定义</strong></p><blockquote><p><strong>平衡二叉树</strong>：<strong>空树</strong>或者<strong>任意节点</strong>左右子树<strong>高度差</strong>绝对值<strong>不超过1</strong></p></blockquote><blockquote><p><strong>AVL树</strong>：既是<strong>平衡二叉树</strong>，又是<strong>二叉搜索树</strong></p></blockquote><blockquote><p><strong>平衡因子</strong>：节点<strong>左子树的高度</strong>减去<strong>右子树的高度</strong>，<strong>空节点</strong>的平衡因子为<code>0</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 节点的高度为从距离该节点最远的叶节点到该节点所经过的边的数量</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 树越平衡，同等个数节点的高度就越小，操作的时间复杂度就越小，所以AVL树的数据操作性能很优秀</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当节点的平衡因子绝对值超过1，则该节点失衡</div><p><strong>③树的平衡</strong></p><blockquote><p>从<strong>底部向顶部</strong>调整<strong>失衡节点</strong>，因为<strong>顶部的失衡</strong>主要由<strong>底部的失衡累计</strong>而来</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上就是如何调整平衡因子绝对值为2的节点，且依旧保持搜索二叉树的性质，可分为以下四种情况</div><h4 id="4-2AVL树旋转"><a href="#4-2AVL树旋转" class="headerlink" title="4.2AVL树旋转"></a>4.2AVL树旋转</h4><p><strong>①右旋</strong></p><blockquote><p>当<strong>失衡节点</strong>平衡因子<strong>大于1</strong>，且<strong>子节点</strong>平衡因子<strong>大于等于0</strong>，采用<strong>右旋</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若失衡节点的子节点有右节点，则需要将该右节点变为旋转后失衡节点的左节点</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_9.png" alt="右旋"><br><strong>②左旋</strong></p><blockquote><p>当<strong>失衡节点</strong>平衡因子<strong>小于-1</strong>，且<strong>子节点</strong>平衡因子<strong>小于等于0</strong>，采用<strong>左旋</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若失衡节点的子节点有左节点，则需要将该左节点变为旋转后失衡节点的右节点</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 易知左旋和右旋的操作为镜像关系</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_10.png" alt="左旋"><br><strong>③先左旋后右旋</strong></p><blockquote><p>当<strong>失衡节点</strong>平衡因子<strong>大于1</strong>，且<strong>子节点</strong>平衡因子<strong>小于0</strong>，采用<strong>先左旋后右旋</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_11.png" alt="LR旋转"><br><strong>④先右旋后左旋</strong></p><blockquote><p>当<strong>失衡节点</strong>平衡因子<strong>小于-1</strong>，且<strong>子节点</strong>平衡因子<strong>大于0</strong>，采用<strong>先右旋后左旋</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 同理先右旋后左旋和先左旋后右旋也为镜像关系</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_12.png" alt="RL旋转"></p><h4 id="4-3AVL树的实现"><a href="#4-3AVL树的实现" class="headerlink" title="4.3AVL树的实现"></a>4.3AVL树的实现</h4><p><strong>①结构与特性</strong></p><pre class="line-numbers language-none"><code class="language-none">/* AVL 树节点结构体 */TreeNode struct TreeNode {    int val;    int height;    struct TreeNode *left;    struct TreeNode *right;} TreeNode;/* 构造函数 */TreeNode *newTreeNode(int val) {    TreeNode *node;    node = (TreeNode *)malloc(sizeof(TreeNode));    node-&gt;val = val;    node-&gt;height = 0;    node-&gt;left = NULL;    node-&gt;right = NULL;    return node;}/* 获取节点高度 */int height(TreeNode *node) {    // 空节点高度为 -1 ，叶节点高度为 0    if (node != NULL) {        return node-&gt;height;    }    return -1;}/* 更新节点高度 */void updateHeight(TreeNode *node) {    int lh = height(node-&gt;left);    int rh = height(node-&gt;right);    // 节点高度等于最高子树高度 + 1    if (lh &gt; rh) {        node-&gt;height = lh + 1;    } else {        node-&gt;height = rh + 1;    }}/* 获取节点高度 */int height(TreeNode *node) {    // 空节点高度为 -1 ，叶节点高度为 0    if (node != NULL) {        return node-&gt;height;    }    return -1;}/* 更新节点高度 */void updateHeight(TreeNode *node) {    int lh = height(node-&gt;left);    int rh = height(node-&gt;right);    // 节点高度等于最高子树高度 + 1    if (lh &gt; rh) {        node-&gt;height = lh + 1;    } else {        node-&gt;height = rh + 1;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②旋转操作</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 执行旋转操作，使该子树重新恢复平衡 */TreeNode *rotate(TreeNode *node) {    // 获取节点 node 的平衡因子    int bf = balanceFactor(node);    // 左偏树    if (bf &gt; 1) {        if (balanceFactor(node-&gt;left) &gt;= 0) {            // 右旋            return rightRotate(node);        } else {            // 先左旋后右旋            node-&gt;left = leftRotate(node-&gt;left);            return rightRotate(node);        }    }    // 右偏树    if (bf &lt; -1) {        if (balanceFactor(node-&gt;right) &lt;= 0) {            // 左旋            return leftRotate(node);        } else {            // 先右旋后左旋            node-&gt;right = rightRotate(node-&gt;right);            return leftRotate(node);        }    }    // 平衡树，无须旋转，直接返回    return node;}/* 右旋操作 */TreeNode *rightRotate(TreeNode *node) {    TreeNode *child, *grandChild;    child = node-&gt;left;    grandChild = child-&gt;right;    // 以 child 为原点，将 node 向右旋转    child-&gt;right = node;    node-&gt;left = grandChild;    // 更新节点高度    updateHeight(node);    updateHeight(child);    // 返回旋转后子树的根节点    return child;}/* 左旋操作 */TreeNode *leftRotate(TreeNode *node) {    TreeNode *child, *grandChild;    child = node-&gt;right;    grandChild = child-&gt;left;    // 以 child 为原点，将 node 向左旋转    child-&gt;left = node;    node-&gt;right = grandChild;    // 更新节点高度    updateHeight(node);    updateHeight(child);    // 返回旋转后子树的根节点    return child;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③增删查改</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 查找和修改操作和搜索二叉树一致</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 插入和删除操作可能会影响二叉树的平衡性，故在操作后需要从底至顶地执行旋转操作，使所有失衡节点恢复平衡</div><pre class="line-numbers language-none"><code class="language-none">/* 插入节点 */void insert(AVLTree *tree, int val) {    tree-&gt;root = insertHelper(tree-&gt;root, val);}/* 递归插入节点（辅助函数） */TreeNode *insertHelper(TreeNode *node, int val) {    if (node == NULL) {        return newTreeNode(val);    }    /* 1. 查找插入位置，并插入节点 */    if (val &lt; node-&gt;val) {        node-&gt;left = insertHelper(node-&gt;left, val);    } else if (val &gt; node-&gt;val) {        node-&gt;right = insertHelper(node-&gt;right, val);    } else {        // 重复节点不插入，直接返回        return node;    }    // 更新节点高度    updateHeight(node);    /* 2. 执行旋转操作，使该子树重新恢复平衡 */    node = rotate(node);    // 返回子树的根节点    return node;}/* 删除节点 */// 由于引入了 stdio.h ，此处无法使用 remove 关键词void removeItem(AVLTree *tree, int val) {    TreeNode *root = removeHelper(tree-&gt;root, val);}/* 递归删除节点（辅助函数） */TreeNode *removeHelper(TreeNode *node, int val) {    TreeNode *child, *grandChild;    if (node == NULL) {        return NULL;    }    /* 1. 查找节点，并删除之 */    if (val &lt; node-&gt;val) {        node-&gt;left = removeHelper(node-&gt;left, val);    } else if (val &gt; node-&gt;val) {        node-&gt;right = removeHelper(node-&gt;right, val);    } else {        if (node-&gt;left == NULL || node-&gt;right == NULL) {            child = node-&gt;left;            if (node-&gt;right != NULL) {                child = node-&gt;right;            }            // 子节点数量 = 0 ，直接删除 node 并返回            if (child == NULL) {                return NULL;            } else {                // 子节点数量 = 1 ，直接删除 node                node = child;            }        } else {            // 子节点数量 = 2 ，则将中序遍历的下个节点删除，并用该节点替换当前节点            TreeNode *temp = node-&gt;right;            while (temp-&gt;left != NULL) {                temp = temp-&gt;left;            }            int tempVal = temp-&gt;val;            node-&gt;right = removeHelper(node-&gt;right, temp-&gt;val);            node-&gt;val = tempVal;        }    }    // 更新节点高度    updateHeight(node);    /* 2. 执行旋转操作，使该子树重新恢复平衡 */    node = rotate(node);    // 返回子树的根节点    return node;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树形结构（下）</title>
      <link href="/2023/12/10/shu-xing-jie-gou-xia/"/>
      <url>/2023/12/10/shu-xing-jie-gou-xia/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="树形结构（下）"><a href="#树形结构（下）" class="headerlink" title="树形结构（下）"></a>树形结构（下）</h2><h3 id="1-堆"><a href="#1-堆" class="headerlink" title="1.堆"></a>1.堆</h3><h4 id="1-1定义"><a href="#1-1定义" class="headerlink" title="1.1定义"></a>1.1定义</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一种满足特殊条件的完全二叉树，常使用数组实现，便于访问根节点，即堆顶</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 堆常用于实现优先队列，大顶堆相当于元素按从大到小顺序出队的优先队列</div><blockquote><p><strong>大顶堆</strong>：<strong>任意节点</strong>的值<strong>大于</strong>其<strong>子节点</strong>的值</p></blockquote><blockquote><p><strong>小顶堆</strong>：<strong>任意节点</strong>的值<strong>小于</strong>其<strong>子节点</strong>的值</p></blockquote><h4 id="1-2堆的实现"><a href="#1-2堆的实现" class="headerlink" title="1.2堆的实现"></a>1.2堆的实现</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以最大堆为例</div><p><strong>①基本操作</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 获取左子节点索引 */int left(MaxHeap *maxHeap, int i) {    return 2 * i + 1;}/* 获取右子节点索引 */int right(MaxHeap *maxHeap, int i) {    return 2 * i + 2;}/* 获取父节点索引 */int parent(MaxHeap *maxHeap, int i) {    return (i - 1) / 2;}/* 访问堆顶元素 */int peek(MaxHeap *maxHeap) {    return maxHeap-&gt;data[0];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②元素入堆</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(logn)</div><blockquote><p>先将其<strong>添加到堆底</strong>，即<strong>底层最靠右的节点</strong></p></blockquote><blockquote><p>比较其和<strong>父节点的关系</strong>，若<strong>不满足</strong>堆的定义，则<strong>交换两者</strong>位置，直到<strong>满足</strong>或者<strong>到达根节点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 也称为从低至顶堆化</div><pre class="line-numbers language-none"><code class="language-none">/* 元素入堆 */void push(MaxHeap *maxHeap, int val) {    // 默认情况下，不应该添加这么多节点    if (maxHeap-&gt;size == MAX_SIZE) {        printf("heap is full!");        return;    }    // 添加节点    maxHeap-&gt;data[maxHeap-&gt;size] = val;    maxHeap-&gt;size++;    // 从底至顶堆化    siftUp(maxHeap, maxHeap-&gt;size - 1);}/* 从节点 i 开始，从底至顶堆化 */void siftUp(MaxHeap *maxHeap, int i) {    while (true) {        // 获取节点 i 的父节点        int p = parent(maxHeap, i);        // 当“越过根节点”或“节点无须修复”时，结束堆化        if (p &lt; 0 || maxHeap-&gt;data[i] &lt;= maxHeap-&gt;data[p]) {            break;        }        // 交换两节点        swap(maxHeap, i, p);        // 循环向上堆化        i = p;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③元素出堆</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(logn)</div><blockquote><p>交换<strong>堆顶元素</strong>和<strong>堆底元素</strong>，并弹出<strong>堆底元素</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 不直接弹出堆顶元素，否则所有节点的索引都会发生变化</div><blockquote><p>比较<strong>堆顶元素</strong>和其<strong>子节点</strong>，将其和<strong>最大的子节点</strong>交换，直至<strong>遇到叶节点</strong>或者<strong>满足最大堆的条件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 也称为从顶至底堆化</div><pre class="line-numbers language-none"><code class="language-none">/* 元素出堆 */int pop(MaxHeap *maxHeap) {    // 判空处理    if (isEmpty(maxHeap)) {        printf("heap is empty!");        return INT_MAX;    }    // 交换根节点与最右叶节点（即交换首元素与尾元素）    swap(maxHeap, 0, size(maxHeap) - 1);    // 删除节点    int val = maxHeap-&gt;data[maxHeap-&gt;size - 1];    maxHeap-&gt;size--;    // 从顶至底堆化    siftDown(maxHeap, 0);    // 返回堆顶元素    return val;}/* 从节点 i 开始，从顶至底堆化 */void siftDown(MaxHeap *maxHeap, int i) {    while (true) {        // 判断节点 i, l, r 中值最大的节点，记为 max        int l = left(maxHeap, i);        int r = right(maxHeap, i);        int max = i;        if (l &lt; size(maxHeap) &amp;&amp; maxHeap-&gt;data[l] &gt; maxHeap-&gt;data[max]) {            max = l;        }        if (r &lt; size(maxHeap) &amp;&amp; maxHeap-&gt;data[r] &gt; maxHeap-&gt;data[max]) {            max = r;        }        // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出        if (max == i) {            break;        }        // 交换两节点        swap(maxHeap, i, max);        // 循环向下堆化        i = max;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④堆的建立</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为0(n)</div><blockquote><p>将各元素<strong>无序添加</strong>到堆中，以<strong>层序遍历的倒序（即自底向上）</strong>遍历节点，<strong>依次</strong>将所有<strong>非叶节点从顶至底堆化</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 堆化节点后，以该节点为根节点的子树就形成一个合法的子堆，自底向上遍历保证当前节点的子树已经是合法的子堆</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上是利用分治，将整个堆分为根节点和左子堆和右子堆，以此类推，分到最后就是父节点和左右儿子节点的比较</div><pre class="line-numbers language-none"><code class="language-none">/* 构造函数，根据切片建堆 */MaxHeap *newMaxHeap(int nums[], int size) {    // 所有元素入堆    MaxHeap *maxHeap = (MaxHeap *)malloc(sizeof(MaxHeap));    maxHeap-&gt;size = size;    memcpy(maxHeap-&gt;data, nums, size * sizeof(int));    for (int i = parent(maxHeap, size - 1); i &gt;= 0; i--) {        // 堆化除叶节点以外的其他所有节点        siftDown(maxHeap, i);    }    return maxHeap;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3TOPk问题"><a href="#1-3TOPk问题" class="headerlink" title="1.3TOPk问题"></a>1.3TOPk问题</h4><blockquote><p>给定一个<strong>长度为n</strong>的<strong>无序数组</strong><code>nums</code>，请返回数组中<strong>前k大</strong>的元素。</p></blockquote><p><strong>①遍历选择</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(nk)</div><blockquote><p>进行<strong>k轮遍历</strong>，<strong>每轮</strong>从中提取第<code>1、2...k</code>大的元素</p></blockquote><p><strong>②排序</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(nlogn)</div><blockquote><p>先对<strong>数组</strong><code>nums</code>进行<strong>排序</strong>，再返回<strong>最右边的k个元素</strong></p></blockquote><p><strong>③堆排序</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(nlogk)</div><blockquote><p>将数组的<strong>前k个元素</strong>依次<strong>入堆</strong>，并<strong>堆化为小顶堆</strong></p></blockquote><blockquote><p>从<strong>第k+1个元素</strong>开始，若当前元素<strong>大于堆顶元素</strong>，则将<strong>堆顶元素出堆</strong>，并将<strong>当前元素入堆</strong></p></blockquote><h3 id="3-哈夫曼树"><a href="#3-哈夫曼树" class="headerlink" title="3.哈夫曼树"></a>3.哈夫曼树</h3><p><strong>3.1定义</strong>：最优二叉树，即每个<strong>叶子结点</strong>到根节点的带权路径长度之和最小<br><strong>3.2构造</strong><br><strong>①总体思想</strong>：将所有节点按照大小排序（可以用堆的方法），每次把权值最小的两棵二叉树合并，比如说1、2、3、4、5，合并一次变为3（1、2）、3、4、5，然后变为6（3（1、2）、3）、4、5，以此类推<br><strong>②代码实现</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_14.png" alt="哈夫曼树的构造"><br><strong>3.3哈夫曼编码</strong>:为了使得出现频率高的字符编码短些，出现频率低的字符编码长些，可以将哈夫曼树的节点路径看作为1和0，左节点为0，右节点为1，<strong>编码长度就是路径长度</strong>，按照字符出现频率构造哈夫曼树即可<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/sjjg_13.png" alt="哈夫曼编码"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（一）</title>
      <link href="/2023/12/10/hui-bian-yu-yan-yi/"/>
      <url>/2023/12/10/hui-bian-yu-yan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言（一）"><a href="#汇编语言（一）" class="headerlink" title="汇编语言（一）"></a>汇编语言（一）</h1><h2 id="汇编语言启蒙"><a href="#汇编语言启蒙" class="headerlink" title="汇编语言启蒙"></a>汇编语言启蒙</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1汇编语言"><a href="#1-1汇编语言" class="headerlink" title="1.1汇编语言"></a>1.1汇编语言</h4><p><strong>①机器语言</strong></p><blockquote><p><strong>概述</strong>：<strong>机器指令</strong>的集合，<strong>机器指令</strong>是一串<strong>二进制序列</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CPU将机器指令转化为一系列高低电平，以驱动电子器件</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 每一种微处理器都有其机器指令集，对应的机器语言和汇编语言可能是不同的，本文以16位的8086CPU为例</div><p><strong>②汇编语言</strong></p><blockquote><p><strong>汇编指令</strong>：<strong>机器指令</strong>便于记忆的格式，有对应的<strong>机器码</strong></p></blockquote><blockquote><p><strong>伪指令</strong>：<strong>没有</strong>对应的<strong>机器码</strong>，由<strong>编译器执行</strong>，计算机并<strong>不执行</strong></p></blockquote><blockquote><p><strong>符号</strong>：由<strong>编译器识别</strong>，<strong>没有</strong>对应的<strong>机器码</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 汇编语言可以看作是机器语言的抽象，同理高级语言可以看作是汇编语言的抽象</div><h4 id="1-2指令与数据"><a href="#1-2指令与数据" class="headerlink" title="1.2指令与数据"></a>1.2指令与数据</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 两者本质上都是一串二进制数据，也并没有特殊的格式区别它们，取决于CPU如何解释它们</div><p><strong>①进制</strong></p><blockquote><p><strong>二进制</strong>：以<code>B</code><strong>结尾</strong>，或者以<code>0B</code><strong>开头</strong></p></blockquote><blockquote><p><strong>八进制</strong>：以<code>O</code>/<code>Q</code><strong>结尾</strong>，或者以<code>0</code><strong>开头</strong></p></blockquote><blockquote><p><strong>十进制</strong>：<strong>缺省情况</strong>是十进制，以<code>D</code><strong>结尾</strong></p></blockquote><blockquote><p><strong>十六进制</strong>：以<code>H</code><strong>结尾</strong>，或者以<code>0x</code><strong>开头</strong></p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 十六进制的数据，在汇编源程序中不能以字母开头，需要在前面加0，如A000H需要改为0A000H</div><p><strong>②ASCLL编码</strong></p><blockquote><p>用<strong>单引号</strong><code>''</code>包围，表示其<strong>按照字符</strong>给出，<strong>编译器</strong>将其转化为对应的<code>ASCLL</code><strong>编码</strong><br><code>'unIX'</code>等价于<code>75H,6EH,49H,58H</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 小写字母的ASCLL码比对应大写字母的ASCLL码大20H</div><p><strong>③逻辑位操作</strong></p><blockquote><p><code>and</code>：按位进行<strong>与</strong>运算</p></blockquote><blockquote><p><code>or</code>：按位进行<strong>或</strong>运算</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以通过该逻辑运算将对应的位设为1/0</div><pre class="line-numbers language-none"><code class="language-none">and al,10111111 ;将第6位设为0or al,01000000 ;将第6位设为1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过改变位改变字母大小写，大写字母的ASCLL码第5位为0，小写字母对应位置为1，这样不需要判断大小写</div><p><strong>③移位操作</strong></p><blockquote><p><code>shl</code>：<strong>左</strong>移位</p></blockquote><blockquote><p><code>shr</code>：<strong>右</strong>移位</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这条指令将移出的位存储在CF标志中，并用0填充缺失的位</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 只能操作内存单元或者寄存器，不能操作字面量</div><h4 id="1-3相关硬件概念"><a href="#1-3相关硬件概念" class="headerlink" title="1.3相关硬件概念"></a>1.3相关硬件概念</h4><p><strong>①主板和接口卡</strong></p><blockquote><p><strong>主板</strong>：一些<strong>主要器件</strong>的集成，如<strong>CPU</strong>、<strong>存储器</strong>、<strong>外围芯片组</strong>和<strong>扩展插槽</strong>等，通过<strong>总线</strong>相连</p></blockquote><blockquote><p><strong>接口卡</strong>：插在<strong>扩展插槽</strong>上，连接一些<strong>外部设备</strong>，CPU通过<strong>控制接口卡</strong>控制<strong>外部设备</strong></p></blockquote><p><strong>②CPU</strong></p><blockquote><p><strong>运算器</strong>：信息<strong>处理</strong></p></blockquote><blockquote><p><strong>控制器</strong>：<strong>控制</strong>各种器件工作</p></blockquote><blockquote><p><strong>寄存器</strong>：信息<strong>存储</strong>，<strong>容量较小</strong>，<strong>数量有限</strong>，主要都是<strong>和CPU密切相关的信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 8086的寄存器为16位，通用寄存器可以分为两个8位的寄存器，如ax可以分为ah和al</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过改变寄存器内容实现对CPU的控制</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当指令操作al导致溢出时，溢出的位不会存储到ah中，因为它将al当作一个独立的寄存器</div><p><strong>③总线</strong></p><blockquote><p><strong>概述</strong>：CPU和<strong>其他部件</strong>交流的通道，物理上是一根根<strong>导线的集合</strong>，可分为以下三类</p></blockquote><blockquote><p><strong>地址总线</strong>：指定<strong>存储单元</strong>的<strong>地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 地址总线的宽度（根数）为N，则其能对2^N个单元寻址</div><blockquote><p><strong>数据总线</strong>：传输<strong>数据</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 数据总线的宽度（根数）为N，则一次能传输N位的数据</div><blockquote><p><strong>控制总线</strong>：传输<strong>控制指令</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 数据总线的宽度（根数）为N，则有N种控制指令</div><p><strong>④存储器</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 依据读写属性分类</div><blockquote><p><strong>随机存储器</strong>：<strong>可读可写</strong>，但是必须<strong>带电存储</strong>，<strong>关机</strong>后存储<strong>内容消失</strong>，通常用于存放<strong>程序和数据</strong></p></blockquote><blockquote><p><strong>只读存储器</strong>：只能<strong>读取</strong>，存储内容<strong>不会丢失</strong>，通常用于存放<strong>系统软件</strong>和<strong>BIOS</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> BIOS是主板和各类接口卡中的软件，可通过它对该硬件进行最基本的输入和输出</div><p><strong>⑤端口</strong></p><blockquote><p><strong>概述</strong>：<strong>外设</strong>中可以由CPU读写的<strong>寄存器</strong>，每个端口都有一个<strong>对应的地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 端口只能用in和out指令进行读写，且需要用特定的寄存器访问端口</div><hr><h3 id="2-内存与地址"><a href="#2-内存与地址" class="headerlink" title="2.内存与地址"></a>2.内存与地址</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①基本概念</strong></p><blockquote><p><strong>16位结构</strong>：<strong>运算器</strong>一次能处理<strong>最长数据</strong>、<strong>寄存器</strong>的<strong>长度</strong>以及<strong>寄存器和运算器</strong>的<strong>通路</strong>均为<code>16</code>位</p></blockquote><blockquote><p><strong>存储单元</strong>：存储器被划分为<strong>若干个存储单元</strong>，长度为<strong>一个字节</strong></p></blockquote><blockquote><p><strong>逻辑存储器</strong>：CPU将<strong>多个存储器</strong>看作为一个<strong>整体</strong>，即<strong>逻辑存储器</strong>，每个存储器占<strong>一段地址空间</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 逻辑寄存器对应的地址称为逻辑地址</div><blockquote><p><strong>物理地址</strong>：一个单元<strong>真实唯一</strong>的地址，也是CPU通过<strong>地址总线</strong>发出的地址</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 物理地址的详细计算方法和具体的CPU有关，其中最重要的就是它是多少位结构</div><p><strong>②地址加法器</strong></p><blockquote><p><strong>概述</strong>：计算<strong>物理地址</strong>，<code>物理地址 = 段地址*16+偏移地址</code>，也可以表示为<code>段地址:偏移地址</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 地址加法器将地址分为了多个段，每个段的大小位2^16位，即64KB</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若直接从8086CPU内部发出地址信号，只能达到16位（64KB）的寻址能力，地址加法器将其扩大到20位（4M）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 同一个物理地址可以使用不同的段地址和偏移地址表示</div><h4 id="2-2寻址"><a href="#2-2寻址" class="headerlink" title="2.2寻址"></a>2.2寻址</h4><p><strong>①段地址</strong></p><blockquote><p><strong>概述</strong>：<strong>缺省</strong>时，cpu会<strong>根据情况</strong>自动读取<strong>段寄存器</strong>中的值作为<strong>段地址</strong>，可以添加<strong>段前缀</strong>显式表明段地址</p></blockquote><blockquote><p><strong>段前缀</strong>：<code>段前缀:[偏移地址]</code>，段前缀通常是<strong>段寄存器名</strong>，如<code>mov ax,ds:[bx]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 8086有四个段寄存器，CS、DS、ES和SS，其中CS和SS有对应的特殊用途，其余可供自由使用</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 8086不支持使用立即数直接修改段寄存器，需要使用通用寄存器作为中介</div><pre class="line-numbers language-none"><code class="language-none">mov DS,xxxxH ;错误 mov ax，xxxxHmov ds,ax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②偏移地址</strong></p><blockquote><p><strong>概述</strong>：通过<code>[]</code>给出，其中可以放置<strong>立即数</strong>和<strong>寻址寄存器</strong>，也可以<strong>混合使用</strong></p></blockquote><blockquote><p><strong>立即数</strong>：直接<strong>包含在机器指令中</strong>的数据，执行前位于cpu的<strong>指令缓冲器</strong>中</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如100、'a'等，类似于C中的字面值</div><blockquote><p><strong>寻址寄存器</strong>：8086CPU提供了<code>bx</code>，<code>bp</code>，<code>si</code>，<code>di</code>四个寄存器</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 其中bx和bp不能同时出现，si和di也不能同时出现</div><blockquote><p><strong>混合使用</strong>：如<code>[bx+si+8]</code>、<code>[bp+di]</code>、<code>[bx+9]</code>，也可以写成<code>[bx].8[si]</code>、<code>[bx].9</code>、<code>[bx]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若含有bp，则段地址默认为ss段寄存器中的数据，其余默认为ds段寄存器</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 用段寄存器指定段，用偏移地址访问段</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 汇编语言中偏移地址是以存储单元为单位计算的，并没有像C语言那么智能</div><h4 id="2-3内存访问"><a href="#2-3内存访问" class="headerlink" title="2.3内存访问"></a>2.3内存访问</h4><p><strong>①<code>mov</code>指令</strong>：</p><blockquote><p><code>mov [container],[data]</code>：将<strong>数据</strong>送入一个<strong>容器</strong>中</p></blockquote><blockquote><p><strong>容器</strong>：类似于<strong>C的左值</strong>，可以是<strong>寄存器名</strong>，<strong>内存单元地址</strong></p></blockquote><blockquote><p><strong>数据</strong>：类似于<strong>C的右值</strong>，可以是<strong>字面量</strong>、<strong>寄存器名</strong>以及<strong>内存单元地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> mov ax,bx类似于C中ax = bx</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> mov ax,[0]指令在一些编译器中的意义等同于mov ax,0，为了防止歧义需要添加段前缀，或者同段寄存器使用中介</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 在赋值的时候，需要保证两边的内存大小是一样的</div><blockquote><p>若需要将<strong>小内存</strong>数据传入到<strong>大内存</strong>中（如累加，需要大内存作为容器<strong>防止溢出</strong>），可以用一个<strong>大内存容器</strong>作为<strong>中介</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">mov dx,bl ;错误mov al,blmov ah,0add dx,ax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②数据长度信息</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 访问内存不仅仅需要知道其起始地址，还需要知道操作的内存长度</div><blockquote><p><strong>寄存器名</strong>：如<code>mov ax,xxx</code>或者<code>mov xxx,ax</code>则表示<strong>处理的数据长度为一个字</strong>，因为<code>ax</code>寄存器长度为<strong>一个字</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 同理mov al,xxx或者mov xxx,al表示进行字节操作</div><blockquote><p><strong>显示指明</strong>：<code>word ptr</code>指明访问的内存为<strong>字单元</strong>，<code>byte ptr</code>则是<strong>字节单元</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">mov word ptr ds:[0],1 ;修改的是ds:[0]和ds:[1]mov byte ptr ds:[0],1 ;修改的是ds;[0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一个字需要两个内存单位，字的低位字节存放在低地址单元中，高位字节存放再高地址单元中</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> push、pop只执行字操作</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在没有寄存器参与的内存单元访问指令中，必须要显示指明操作内存长度</div><h4 id="2-4指令的访问"><a href="#2-4指令的访问" class="headerlink" title="2.4指令的访问"></a>2.4指令的访问</h4><p><strong>①相关寄存器</strong></p><blockquote><p><strong><code>CS</code>段寄存器</strong>：用于提供<strong>当前要实施指令</strong>的<strong>段地址</strong></p></blockquote><blockquote><p><strong><code>IP</code>寄存器</strong>：搭配<code>CS</code><strong>段寄存器</strong>使用，8086CPU将<code>CS:IP</code>作为<strong>当前执行</strong>的指令的<strong>物理地址</strong></p></blockquote><p><strong>②过程概述</strong></p><blockquote><p><code>CS</code>和<code>IP</code>寄存器的值送入<strong>地址加法器</strong>中，获得指令的<strong>物理地址</strong></p></blockquote><blockquote><p><strong>地址加法器</strong>将物理地址送入<strong>控制输入输出电路</strong></p></blockquote><blockquote><p><strong>控制输入输出电路</strong>将物理地址送入<strong>地址总线</strong></p></blockquote><blockquote><p><strong>数据总线</strong>将对应物理地址<strong>对应的指令</strong>送入CPU</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如图，一条指令占据多个内存单元，数据总线输入的是整条指令，而不仅仅是对应物理地址对应的内存单元的数据</div><blockquote><p><strong>控制输入输出电路</strong>将对应指令送入<strong>指令缓冲器</strong></p></blockquote><blockquote><p><code>IP</code>的值自动增加，指向<strong>下一条指令</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若刚刚读入的指令长度为N个字节，则IP增加3</div><blockquote><p><strong>执行</strong>指令缓冲器中的指令，并重复上述过程执行<strong>下一条指令</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> CS:IP对应内存位置的数据即为指令，CPU根据这个区分指令和数据</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以修改CS和IP寄存器的值，指向我们的代码段，用于执行该段代码</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> mov指令可以修改大部分寄存器的地址，但是不能修改CS和IP的地址，需要用跳转修改</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_1.png" alt="初始状态"></p><hr><h3 id="3-汇编程序"><a href="#3-汇编程序" class="headerlink" title="3.汇编程序"></a>3.汇编程序</h3><h4 id="3-1汇编源程序"><a href="#3-1汇编源程序" class="headerlink" title="3.1汇编源程序"></a>3.1汇编源程序</h4><p><strong>①框架</strong></p><blockquote><p><strong>概述</strong>：由<strong>汇编指令</strong>、<strong>标号</strong>和<strong>伪指令</strong>构成，其中<strong>汇编指令</strong>转换为<strong>机器指令</strong>执行，其余都变成了<strong>描述信息</strong></p></blockquote><blockquote><p><strong>程序返回</strong>：结尾处<code>mov ax,4c00H</code>和<code>int 21H</code>将<strong>CPU的控制权</strong>还给使他运行的程序</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 汇编语言的源文件后缀为.asm</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_5.png" alt="指令和伪指令"></p><p><strong>②常用伪指令</strong></p><blockquote><p><code>assume [段寄存器名]:[段名]</code>：将某个段和某个<strong>段寄存器</strong>联系到一起</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 段和段寄存器的关联将决定这个段的作用，如代码段和CS联系到一起，栈段和SS联系到一起</div><blockquote><p><code>[段名] segment</code>：说明一个段<strong>开始</strong></p></blockquote><blockquote><p><code>[段名] ends</code>：说明一个段<strong>结束</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一个汇编程序由多个段组成，段名最后会被处理为一个段地址</div><blockquote><p><code>end</code>：一个汇编程序的<strong>结束标记</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不要搞混end和ends</div><p><strong>③常用汇编指令</strong></p><blockquote><p><code>add/sub</code> ：<strong>加减法</strong>，<code>sub ax,bx</code>类似于C中<code>ax = ax - bx</code></p></blockquote><blockquote><p><code>inc/dec</code>：<strong>递增/减</strong>，<code>inc ax</code>类似于C中<code>ax = ax+1</code></p></blockquote><blockquote><p><code>mul/div</code>：<strong>乘除法</strong>指令</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 乘除法可分为8位和16位，且被除数/被乘数需要实现放在特定寄存器中</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 根据被除数的范围选取除法的类别，16位寄存器能表示的值的上限为65535</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 使用内存单元时，需要使用word ptr和byte ptr指明内存单元的长度</div><h4 id="3-2源文件的编译"><a href="#3-2源文件的编译" class="headerlink" title="3.2源文件的编译"></a>3.2源文件的编译</h4><p><strong>①运行编译器</strong></p><blockquote><p>本篇采用微软的<code>masm</code>编译器</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_6.png" alt="masm编译器"></p><p><strong>②导入源文件</strong></p><blockquote><p>如果源文件在<strong>编译器工作路径下</strong>，输入<strong>文件名</strong>即可，否则需要指明<strong>完整路径</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 编译后将在指定路径（在对应冒号后输入路径即可）生成可执行文件（.obj文件），缺省情况下当前路径</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 编译过程中还会提示你生成一些中间文件，如列表文件（.lst）和交叉引用文件（.crf），可忽略（直接enter）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果源程序不是.asm文件，则需要输入全名</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_7.png" alt="导入源文件"></p><h4 id="3-3链接目标文件"><a href="#3-3链接目标文件" class="headerlink" title="3.3链接目标文件"></a>3.3链接目标文件</h4><p><strong>①运行链接器</strong></p><blockquote><p>本篇采用微软的<code>Overlay Linker</code></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_8.png" alt="Overlay Linker链接器"></p><p><strong>②导入目标文件</strong></p><blockquote><p>路径和文件名的规则<strong>同编译器</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 链接过程中还会提示你生成一些中间文件，如映像文件（.map），可忽略（直接enter）</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_9.png" alt="导入目标文件"></p><p><strong>③链接库文件</strong></p><blockquote><p>如果程序中调用了<strong>库文件中的子程序</strong>，则需要链接对应的库</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_10.png" alt="链接库文件"></p><h4 id="3-4简化的编译和链接"><a href="#3-4简化的编译和链接" class="headerlink" title="3.4简化的编译和链接"></a>3.4简化的编译和链接</h4><blockquote><p>将跳过一些<strong>非必要步骤</strong>，即生成<strong>中间文件</strong>和<strong>链接库</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_11.png" alt="简化的编译"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_12.png" alt="简化的链接"></p><h4 id="3-5跟踪程序执行过程"><a href="#3-5跟踪程序执行过程" class="headerlink" title="3.5跟踪程序执行过程"></a>3.5跟踪程序执行过程</h4><blockquote><p>本篇采用微软的<code>debug</code>程序</p></blockquote><p><strong>①导入可执行文件</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_14.png" alt="简化的链接"></p><p><strong>②可执行文件的加载过程</strong></p><blockquote><p><code>DOS</code>系统中可执行文件的加载过程，其中<code>SA</code>存放在<code>ds</code>寄存器中，<code>DOS</code>系统使用<code>PSP</code>用来与程序通信</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_15.png" alt="可执行文件的内存情况"></p><p><strong>③查看寄存器状态</strong></p><blockquote><p>输入<code>-r</code>查看寄存器</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_13.png" alt="简化的链接"></p><p><strong>④查看程序内容</strong></p><blockquote><p>输入<code>-u</code>查看程序内容</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_16.png" alt="查看程序内容"></p><p><strong>⑤单步执行程序</strong></p><blockquote><p>输入<code>-t</code>单步执行指令</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当执行到int 21时，需要使用-p执行</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_17.png" alt="单步执行程序"></p><p><strong>②对源程序进行编译链接</strong></p><blockquote><p>编译产生<strong>目标文件</strong><br>链接源文件产生<strong>可执行文件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可执行文件包括两部分，一部分为程序和数据，另一部分为相关描述信息（程序有多大，占用多大内存）</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其中伪指令在编译时均转化为相关描述信息</div><p><strong>③执行程序</strong></p><blockquote><p>每个<strong>操作系统</strong>都有类似于<strong>命令解释器</strong>的程序用于执行程序，<strong>命令解释器</strong>会先找到对应程序并将其<strong>载入内存</strong>，随后设置<code>CS:IP</code>指向<strong>程序的入口</strong>，命令解释器<strong>停止运行</strong>，并运行对应程序，最后对应程序运行<strong>结束</strong>，<strong>返回</strong>到命令解解释程序</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 8086 </tag>
            
            <tag> 《汇编语言》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（三）</title>
      <link href="/2023/12/10/hui-bian-yu-yan-san/"/>
      <url>/2023/12/10/hui-bian-yu-yan-san/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言（三）"><a href="#汇编语言（三）" class="headerlink" title="汇编语言（三）"></a>汇编语言（三）</h1><h2 id="汇编语言进阶"><a href="#汇编语言进阶" class="headerlink" title="汇编语言进阶"></a>汇编语言进阶</h2><h3 id="1-状态寄存器"><a href="#1-状态寄存器" class="headerlink" title="1.状态寄存器"></a>1.状态寄存器</h3><h4 id="1-1引言"><a href="#1-1引言" class="headerlink" title="1.1引言"></a>1.1引言</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CPU内部的一种特殊的寄存器，其中每一位都用于记录特定的信息，主要介绍8086的标志寄存器</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 每个指令是否影响标志寄存器，以及影响哪些部分，都是不同的</div><blockquote><p><strong>相关指令</strong>的<strong>执行结果</strong><br>为CPU执行<strong>相关指令</strong>提供<strong>行为依据</strong><br>控制CPU的相关<strong>工作方式</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_24.png" alt="8086的标志寄存器"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_26.png" alt="debug中的8086标志寄存器"></p><h4 id="1-2标志"><a href="#1-2标志" class="headerlink" title="1.2标志"></a>1.2标志</h4><p><strong>①ZF标志</strong></p><blockquote><p>记录<strong>相关指令</strong>的计算结果是否为<code>0</code>，如果为<code>0</code>，则该位为<code>1</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要是add之类的运算指令以及逻辑运算指令</div><p><strong>②PF标志</strong></p><blockquote><p>记录<strong>相关指令</strong>执行后，其结果<code>bit</code>位中<code>1</code>的个数是否为<strong>偶数</strong>，若为偶数，则为<code>1</code></p></blockquote><p><strong>③SF标志</strong></p><blockquote><p>记录<strong>相关指令</strong>执行后，其结果是否为<strong>负</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 这个标志的前提是进行有符号运算</div><blockquote><p>计算机常用<strong>补码</strong>描述<strong>有符号数</strong>，如<code>10000001B</code>可以看作是<strong>无符号数</strong><code>129</code>，也可以看作<strong>有符号数</strong><code>-127</code></p></blockquote><p><strong>④CF标志</strong></p><blockquote><p>记录了<strong>无符号运算</strong>时运算结果的<strong>最高有效位</strong>像<strong>更高位</strong>的<strong>进位值/借位值</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CF的含义取决于其被什么指令设置，如果为加法指令，则表示进位值，如果为减法指令，则表示借位值</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_25.png" alt="有效位"></p><p><strong>⑤OF标志</strong></p><blockquote><p>记录<strong>有符号运算</strong>的结果是否发生了<strong>溢出</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意，只要执行了对应的指令，相关标志位就会发生改变，无论是有符号运算还是无符号运算，只是某些标志位只在某种特定情况下有意义罢了</div><blockquote><p>如执行<code>0F0H+88H</code>，<code>CF</code>会变为<code>1</code>，因为如果这是一个<strong>无符号运算</strong>，会产生<strong>进位</strong>，<code>OF</code>也会变为<code>1</code>，因为如果这是一个<strong>有符号运算</strong>，会发生<strong>溢出</strong></p></blockquote><h4 id="1-3相关指令"><a href="#1-3相关指令" class="headerlink" title="1.3相关指令"></a>1.3相关指令</h4><p><strong>①<code>adc</code>指令</strong></p><blockquote><p><strong>格式</strong>：<code>adc ax,bx</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 带进位加法指令,adc ax,bx相当于ax+bx+CF</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以利用adc指令实现更大数据的加法运算</div><blockquote><p>计算<code>1EF0001000H+2010001EF0H</code>，将<strong>最高16位</strong>放在<code>ax</code>中，<strong>次高16位</strong>放在<code>bx</code>中，<strong>低16位</strong>放在<code>cx</code>中，更大的数据同理</p></blockquote><pre class="line-numbers language-none"><code class="language-none">mov ax,001EHmov bx,0F000Hmov cx,1000Hadd cx,1EF0Hadc bx,1000Hadc ax,0020H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②<code>sbb</code>指令</strong></p><blockquote><p><strong>格式</strong>：<code>sbb ax,bx</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 带进位减法指令，sbb ax,bx相当于ax-bx-CF</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 同上，可以利用sbb实现更大数据的减法运算</div><p><strong>③<code>cmp</code>指令</strong></p><blockquote><p><strong>格式</strong>：<code>cmp ax,bx</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 比较指令，功能相当于减法指令，但是不保存结果，只影响标志寄存器</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过标志寄存器状态判断参数大小关系</div><blockquote><p><code>ZF</code>：判断两者是否<strong>相等</strong></p></blockquote><blockquote><p><strong>无符号数</strong><br><code>CF</code>：若为<code>1</code>，则<code>ax &lt; bx</code>，反之则<code>ax ≥ bx</code></p></blockquote><blockquote><p><strong>有符号数</strong><br><code>SF</code>：若为1，则逻辑上<code>ax &lt; bx</code>，反之逻辑上<code>ax ≥ bx</code><br><code>OF</code>：判断是否溢出，若<strong>溢出</strong>，则真实大小关系和逻辑大小关系<strong>相反</strong>，反之则一致</p></blockquote><p><strong>④基于比较结果的条件转移</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 检测相关标志，从而转移到标号处，可以配合cmp指令使用，以下列举无符号数的相关指令</div><blockquote><p><code>je 标号</code>：<strong>相等</strong>则转移</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ZF标志为1</div><blockquote><p><code>jne 标号</code>：<strong>不等</strong>则转移</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ZF标志为0</div><blockquote><p><code>jb 标号</code>：<strong>低于</strong>则转移</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CF标志为1</div><blockquote><p><code>jnb 标号</code>：<strong>不低于</strong>则转移</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CF标志为0</div><blockquote><p><code>ja 标号</code>：<strong>高于</strong>则转移</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CF标志为0且ZF标志为0</div><blockquote><p><code>jna 标号</code>：<strong>不高于</strong>则转移</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CF标志为1且ZF标志为1</div><p><strong>⑤串传送指令</strong></p><blockquote><p><strong>DF标志</strong>：控制<strong>串处理过程</strong>中相关寄存器（<code>si</code>和<code>di</code>）<strong>移动方向</strong>，若为<code>0</code>，则<strong>增加</strong>，反之则减少</p></blockquote><blockquote><p><strong>串传送指令</strong><br><code>movsb</code>：将<code>ds:[si]</code>中数据移动到<code>es:[di]</code>，并根据DF标志移动<code>si</code>和<code>di</code>，每次操作<strong>1个内存单位</strong><br><code>movsw</code>：同上，但是每次操作<strong>2个内存单位</strong></p></blockquote><blockquote><p><strong>相关辅助指令</strong><br><code>rep 串传送指令</code>：根据<code>cx</code>的值，<strong>重复执行</strong>其后的串传送指令<br><code>cld</code>：将<strong>DF标志</strong>设为<code>0</code><br><code>std</code>：将<strong>DF标志</strong>设为<code>1</code></p></blockquote><p><strong>⑥访问标志寄存器</strong></p><blockquote><p><code>pushf</code>：将<strong>整个标志寄存器</strong>的值压栈<br><code>popf</code>：从栈中弹出数据，送入<strong>标志寄存器</strong></p></blockquote><hr><h3 id="2-中断"><a href="#2-中断" class="headerlink" title="2.中断"></a>2.中断</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①定义</strong></p><blockquote><p>当CPU接收到<strong>中断信息</strong>后，<strong>执行完</strong>当前正在执行的指令后，<strong>不再向下执行</strong>，转去处理中断信息</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 中断的优先级不一定是最高的，比如在修改栈顶地址过程中发生中断，他是不会响应中断的</div><p><strong>②内中断</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以8086CPU为例</div><blockquote><p><strong>除法错误</strong>，中断类型码为<code>0</code><br><strong>单步执行</strong>，中断类型码为<code>1</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当TF标志为1，则产生单步中断</div><blockquote><p><strong>执行<code>into</code>指令</strong>，中断类型码为<code>4</code><br><strong>执行<code>int</code>指令</strong>，指令格式为<code>int n</code>，其中<code>n</code>为中断类型码</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 利用int指令主动引发中断</div><p><strong>③外中断</strong></p><blockquote><p><strong>可屏蔽外中断</strong>：<strong>可以不响应</strong>的中断，</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 是否相应外中断由IF标志决定，可以通过指令设置其状态</div><blockquote><p><strong>不可屏蔽外中断</strong>：执行完当前指令，<strong>立即响应</strong></p></blockquote><h4 id="2-2中断处理程序"><a href="#2-2中断处理程序" class="headerlink" title="2.2中断处理程序"></a>2.2中断处理程序</h4><p><strong>①中断向量表</strong></p><blockquote><p>提供<strong>中断类型码</strong>与其对应<strong>中断处理程序入口地址</strong>的关系，一个表项占<strong>两个内存单元</strong>，<strong>高地址字</strong>存放<strong>段地址</strong>，<strong>低地址字</strong>存放<strong>偏移地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 中断向量表保存在内存特定位置，对于8086CPU，放在内存0000:0000至0000:03FF</div><p><strong>②中断过程</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以8086CPU为例，由CPU自动执行</div><blockquote><p>从<strong>中断信息</strong>中获取<strong>中断类型码</strong><br><strong>标志寄存器</strong>的值<strong>入栈</strong>，并将标志寄存器的<strong>TF标志</strong>和<strong>IF标志</strong>设为<code>0</code><br><code>CS</code>和<code>IP</code>的值<strong>入栈</strong><br>根据<strong>终端类型码</strong>将<code>CS:IP</code>指向<strong>中断程序入口地址</strong></p></blockquote><p><strong>③中断程序常规步骤</strong></p><blockquote><p>保存<strong>用到的寄存器</strong><code>-&gt;</code>处理中断<code>-&gt;</code><strong>恢复</strong>用到的寄存器<code>-&gt;</code>用<code>iret</code>指令返回</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> iret指令相当于pop IP、pop CS和popf</div><p><strong>④BIOS</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 系统板的ROM中存放的程序（基本输入输出系统），主要包括对硬件系统的检测和初始化程序，以及各种中断例程</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一个中断例程通常包含多个子程序，根据相关寄存器决定执行哪个子程序以及相关效果</div><blockquote><p>如以下常用的<strong>中断例程</strong>，设置<code>ax</code>表示使用<strong>程序返回</strong>功能</p></blockquote><pre class="line-numbers language-none"><code class="language-none">mov ax,4c00hint 21h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_27.png" alt="BIOS安装过程"></p><h4 id="2-3自定义中断处理程序"><a href="#2-3自定义中断处理程序" class="headerlink" title="2.3自定义中断处理程序"></a>2.3自定义中断处理程序</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以8086下除法溢出为例，编写程序安装自定义中断程序</div><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart: mov ax,cs       mov ds,ax         ;设置ds:si指向中断程序源地址       mov si,offset do0        mov ax,0       mov es,ax         ;设置es:di指向中断程序最终目标地址       mov di,200h       mov cx,offset do0end-offset do0 ;设置串传输的长度       cld ;设置传输方向       rep movsb       ;设置中断向量表       mov ax,0       mov es,ax       mov word ptr es:[0*4],200h       mov word ptr es:[0*4+2],0       mov ax,4c00h       int 21hdo0：  jmp short do0start       db "overflow"do0start: mov ax,cs          mov ds,ax   ;将ds:si指向字符串          mov si,202h          mov ax,0b800h          mov es,ax         ;设置es:di指向显存空间的中间位置          mov di,12*160+36*2          mov cx,9s:        mov al,[si]          mov es:[di],al          inc si          add di,2          loop s          mov ax 4c00h          int 21hdo0end: nopcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>①申请空间</strong></p><blockquote><p>由于CPU<strong>随时</strong>都有可能收到<strong>中断信息</strong>，所以中断处理程序必须<strong>一直存储在某段内存空间中</strong>，所以需要申请一段<strong>不会被别的程序使用</strong>的空间</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在这里为了简便，直接使用了0000:0200至0000:02FF这段空间，因为这段空间是8086中断向量表空余空间，不会被使用</div><p><strong>②安装</strong></p><blockquote><p><strong>安装中断处理程序</strong>主要分为两步，即将<strong>编写的程序复制到申请的空间中</strong>，并将对应<strong>中断向量表项设置为申请空间起始地址</strong></p></blockquote><p><strong>③编写中断程序</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在中断程序中使用寄存器，需要先将其中内容保存字栈中</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 本例中直接退出程序，如果中断过后还需要返回程序，则需要将mov ax 4c00h和int 21h替换为iret指令</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 中断处理程序用到的数据(如overflow)需要在中断处理程序中申请，并记得设置程序的执行起点</div><h3 id="3-子程序"><a href="#3-子程序" class="headerlink" title="3.子程序"></a>3.子程序</h3><h4 id="3-1引言"><a href="#3-1引言" class="headerlink" title="3.1引言"></a>3.1引言</h4><p><strong>①带长度信息的标号</strong></p><blockquote><p><strong>标号</strong>实质上就是<strong>对应位置的起始地址</strong>，一些标号<strong>不带长度信息（如<code>a</code>）</strong>，一些标号<strong>带长度信息（如<code>b</code>）</strong>，格式上表现为<strong>后面</strong>是否跟一个<strong>冒号</strong><code>:</code>，以及对应<strong>描述大小的伪指令</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">assume ds:datadata segmenta: dw 1,2,3,4,5,6,7,8b  dw 1,2,3,4,5,6,7,8c  dw a,bdata ends<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 带有长度的标号相当于一个对应长度的内存单元</div><pre class="line-numbers language-none"><code class="language-none">mov a,2 ;错误，没有指定长度信息mov word ptr a,2mov b,2 ;相当于mov word ptr cs:[16],2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>②<code>assume</code>详解</strong></p><blockquote><p><code>assume</code>将<strong>对应段寄存器</strong>和<strong>对应段</strong>联系在一起，表现为位于<strong>对应段</strong>的<strong>标号</strong>自动取<strong>对应段寄存器</strong>中的内容作为<strong>段地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以下三条指令是等价的，因为标号b在data段中，会默认取ds寄存器中内容为段地址</div><pre class="line-numbers language-none"><code class="language-none">mov ax,b[bx+si+3]mov ax,ds:0[bx+si+3]mov ax,0[bx+si+3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若想使用标号访问数据，需要使用使用伪指令assume将标号所在段和一个段寄存器联系起来，否则编译器无法确定标号的段地址处于哪个寄存器中，但是并没有直接将对应寄存器的值修改为关联地址</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 后面有:的地址标号，只能在代码段中使用</div><h4 id="3-2直接定址表"><a href="#3-2直接定址表" class="headerlink" title="3.2直接定址表"></a>3.2直接定址表</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一种映射关系，如0~15和十六进制的0~F，本质上是一种以空间换时间的做法</div><blockquote><p>以下为利用<strong>直接定址表</strong>求对应<code>sin</code>值的<strong>子程序</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">showsin: jmp short show         ;存放各个标号的地址         table dw ag0,ag30,ag60,ag90,ag120,ag150,ag180         ;各个角度对应的sin值的字符串         ag0  db '0',0         ag30 db '0.5',0         ag60 db '0.866',0         ag90 db '1',0         ag120 db '0.866',0         ag150 db '0.5',0         ag180 ad '0',0show:    push bx         push es         push si         mov bx,0b800h         mov es,bx         ;用ax传递的角度除以30作为相对于table的偏移量，取得对应字符串的偏移地址，放在bx中         mov ah,0         mov bl,30         div bl         mov bl,al         mov bh,0         add bx,bx         mov bx,table[bx]         ;显示对应字符串         mov si,160*12+40*2shows:   mov ah,cs:[bx]         cmp ah,0         je showret         mov es:[si],ah         inc bx         add si,2         jmp short showsshowret: pop si         pop es         pop bx         ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3可选效果的程序"><a href="#3-3可选效果的程序" class="headerlink" title="3.3可选效果的程序"></a>3.3可选效果的程序</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 利用直接定址表实现程序不同功能</div><blockquote><p>一个子程序<code>setscreen</code>，当<code>ah</code>为<strong>不同的值</strong>时，实现4种<strong>不同的功能</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">setscreen: jmp short set           table dw sub1,sub2,sub3,sub4set:       push bx           cmp ah,3 ;判断异常情况，即是否超出了功能号范围           ja sret           mov bl,ah           mov bh,0           add bx,bx ;计算ah功能号对应位置           call word ptr table[bx]sret:      pop bx           ret;清空屏幕：将显存中当前屏幕中字符全部设为空格符sub1:      push bx           push cx           push es           mov bx,0b800h           mov es,bx           mov bx,0           mov cx,2000sub1s:     mov byte ptr es:[bx],' '           add bx,2           loop sub1s           pop es           pop cx           pop bx           ret;设置前景色：将显存中当前屏幕处于奇地址属性字节的0、1、2位设置为al对应值sub2:      push bx           push cx           push es           mov bx,0b800h           mov es,bx           mov bx,1           mov cx,2000sub2s:     and byte ptr es:[bx],11111000b           or es:[bx],al           add bx,2           loop sub2s           pop es           pop cx           pop bx           ret;设置背景色：将显存中当前屏幕处于奇地址属性字节的4、5、6位设置为al对应值 sub3:     push bx           push cx           push es           mov cl,4           shl al,cl           mov bx,0b800h           mov es,bx           mov bx,1           mov cx,2000sub3s:     and byte ptr es:[bx],10001111b           or es:[bx],al           add bx,2           loop sub2s           pop es           pop cx           pop bx           ret  ;向上滚动一行：依次将n+1行的内容复制到第n行，最后一行为空sub4:      push cx           push si           push di           push es           push ds           mov si,0b800h           mov es,si           mov ds,si           mov si,160 ;将ds:si指向n+1行           mov di,0 ;将es:di指向n行           cld           mov cx,24 ;共复制24行sub4s:     push cx           mov cx,160           rep movsb  ;复制           pop cx           loop sub4s           mov cx,80           mov si,0sub4s1:    mov byte ptr [160*24+si],' '           add si,2           loop sub4s1           pop ds           pop es           pop di           pop si           pop cx           ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《汇编语言》 </tag>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法范式（上）</title>
      <link href="/2023/12/10/suan-fa-fan-shi-shang/"/>
      <url>/2023/12/10/suan-fa-fan-shi-shang/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="算法范式（上）"><a href="#算法范式（上）" class="headerlink" title="算法范式（上）"></a>算法范式（上）</h2><h3 id="1-分治"><a href="#1-分治" class="headerlink" title="1.分治"></a>1.分治</h3><h4 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h4><blockquote><p><strong>分</strong>：<strong>递归</strong>地将<strong>原问题</strong>分解为<strong>两个或多个子问题</strong>，达到<strong>最小问题</strong>时终止</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 分解得到的子问题需要是独立的</div><blockquote><p><strong>治</strong>：从<strong>易知解</strong>的<strong>最小问题</strong>从底至顶地<strong>合并各个子问题</strong>，从而构建出<strong>原问题的解</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 分治通常基于递归实现</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 递归不仅能优化时间复杂度，还有利于并行计算</div><h4 id="1-2二分查找"><a href="#1-2二分查找" class="headerlink" title="1.2二分查找"></a>1.2二分查找</h4><p><strong>①递归实现思路</strong></p><blockquote><p>由于是<strong>基于搜索区间</strong>进行分治，所以函数的<strong>主要参数</strong>为<strong>区间开始索引</strong>和<strong>区间结束索引</strong>，<strong>每次递归</strong>根据<strong>中点值和<code>target</code>关系</strong>修改这<strong>两个值</strong>即可</p></blockquote><p><strong>②代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 二分查找：问题 f(i, j) */int dfs(int nums[], int target, int i, int j) {    // 若区间为空，代表无目标元素，则返回 -1    if (i &gt; j) {        return -1;    }    // 计算中点索引 m    int m = (i + j) / 2;    if (nums[m] &lt; target) {        // 递归子问题 f(m+1, j)        return dfs(nums, target, m + 1, j);    } else if (nums[m] &gt; target) {        // 递归子问题 f(i, m-1)        return dfs(nums, target, i, m - 1);    } else {        // 找到目标元素，返回其索引        return m;    }}/* 二分查找 */int binarySearch(int nums[], int target, int numsSize) {    int n = numsSize;    // 求解问题 f(0, n-1)    return dfs(nums, target, 0, n - 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3构建树问题"><a href="#1-3构建树问题" class="headerlink" title="1.3构建树问题"></a>1.3构建树问题</h4><p><strong>①概述</strong></p><blockquote><p>根据一个树的<strong>前序遍历</strong><code>preorder</code>和<strong>中序遍历</strong><code>inorder</code>构建<strong>二叉树</strong>，假设二叉树中<strong>没有重复节点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 树的前序遍历和中序遍历都可以被划分为对应的三部分，且对应的子树同样也可以被同样划分</div><blockquote><p><strong>前序遍历</strong>：可<strong>按序</strong>分为<code>根节点:左子树:右子树</code></p></blockquote><blockquote><p><strong>中序遍历</strong>：可<strong>按序</strong>分为<code>左子树:根节点:右子树</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 根据前序遍历得到的根节点划分中序遍历，总而得到左子树和右子树</div><p><strong>②思路</strong></p><blockquote><p>根据<strong>前序遍历的根节点</strong>划分<strong>中序遍历</strong>得到<strong>左子树</strong>和<strong>右子树</strong>，连接<strong>根节点</strong>、<strong>左子树根节点</strong>和<strong>右子树根节点</strong>，随后再<strong>同样操作左子树和右子树</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要分治参数为根节点索引、左子树根节点索引和右子树根节点索引</div><p><strong>②代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 构建二叉树：分治 */TreeNode *dfs(int *preorder, int *inorderMap, int i, int l, int r, int size) {    // 子树区间为空时终止    if (r - l &lt; 0)        return NULL;    // 初始化根节点    TreeNode *root = (TreeNode *)malloc(sizeof(TreeNode));    root-&gt;val = preorder[i];    root-&gt;left = NULL;    root-&gt;right = NULL;    // 查询 m ，从而划分左右子树    int m = inorderMap[preorder[i]];    // 子问题：构建左子树    root-&gt;left = dfs(preorder, inorderMap, i + 1, l, m - 1, size);    // 子问题：构建右子树    root-&gt;right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r, size);    // 返回根节点    return root;}/* 构建二叉树 */TreeNode *buildTree(int *preorder, int preorderSize, int *inorder, int inorderSize) {    // 初始化哈希表，存储 inorder 元素到索引的映射    int *inorderMap = (int *)malloc(sizeof(int) * MAX_SIZE);    for (int i = 0; i &lt; inorderSize; i++) {        inorderMap[inorder[i]] = i;    }    TreeNode *root = dfs(preorder, inorderMap, 0, 0, inorderSize - 1, inorderSize);    free(inorderMap);    return root;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4汉诺塔问题"><a href="#1-4汉诺塔问题" class="headerlink" title="1.4汉诺塔问题"></a>1.4汉诺塔问题</h4><p><strong>①概述</strong></p><blockquote><p><strong>问题</strong>：给定<strong>三根柱子<code>A</code>、<code>B</code>、<code>C</code><strong>，其中<code>A</code>上套有</strong>n个圆盘</strong>，<strong>从上到下</strong>按照<strong>从小到大</strong>的顺序排列，将这<strong>n个圆盘</strong>移动到<code>C</code>上</p></blockquote><blockquote><p><strong>规则</strong><br><strong>圆盘</strong>只能从<strong>一个柱子顶部</strong>拿出，从另<strong>一个柱子顶部</strong>放入<br><strong>每次</strong>只能移动<strong>一个</strong>圆盘<br><strong>小圆盘</strong>必须时刻<strong>位于大圆盘之上</strong></p></blockquote><p><strong>②思路</strong></p><blockquote><p><strong>单圆盘</strong>：<strong>直接</strong>将其从<code>A</code><strong>移动</strong>到<code>C</code>即可</p></blockquote><blockquote><p><strong>两圆盘</strong>：将<strong>小圆盘</strong>从<code>A</code>移动到<code>B</code>，将<strong>大圆盘</strong>从<code>A</code><strong>移动</strong>到<code>C</code>，再将<strong>小圆盘</strong>从<code>B</code>移动到<code>C</code>即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这里B为缓冲柱，C为目标柱</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上是将其转化为两个单圆盘问题</div><blockquote><p><strong>三圆盘</strong>：先<strong>只</strong>考虑<strong>上面两个圆盘</strong>，将<code>B</code>作为<strong>目标柱</strong>，<code>C</code>作为<strong>缓冲柱</strong>，将<strong>上面两个圆盘</strong>移到<code>B</code>上，将<strong>最大圆盘</strong>从<code>A</code>移到<code>C</code>，随后令<code>C</code>为<strong>目标柱</strong>、<code>A</code>为<strong>缓冲柱</strong>，将<strong>两个圆盘</strong>从<code>B</code>移动至<code>C</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上是将其转化为一个两圆盘问题和一个单圆盘问题</div><blockquote><p><strong>n个圆盘</strong>：将<strong>n-1个圆盘</strong>借助<code>C</code>移动到<code>B</code>，将<strong>剩余一个圆盘</strong>移动到<code>C</code>，将剩余<strong>n-1个圆盘</strong>借助<code>A</code>从<code>B</code>移动到<code>C</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上是将其转化为一个n-1圆盘问题和一个单圆盘问题</div><p><strong>③代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(2^n)，空间复杂度为O(n)</div><pre class="line-numbers language-none"><code class="language-none">/* 移动一个圆盘 */void move(int *src, int *srcSize, int *tar, int *tarSize) {    // 从 src 顶部拿出一个圆盘    int pan = src[*srcSize - 1];    src[*srcSize - 1] = 0;    (*srcSize)--;    // 将圆盘放入 tar 顶部    tar[*tarSize] = pan;    (*tarSize)++;}/* 求解汉诺塔：问题 f(i) */void dfs(int i, int *src, int *srcSize, int *buf, int *bufSize, int *tar, int *tarSize) {    // 若 src 只剩下一个圆盘，则直接将其移到 tar    if (i == 1) {        move(src, srcSize, tar, tarSize);        return;    }    // 子问题 f(i-1) ：将 src 顶部 i-1 个圆盘借助 tar 移到 buf    dfs(i - 1, src, srcSize, tar, tarSize, buf, bufSize);    // 子问题 f(1) ：将 src 剩余一个圆盘移到 tar    move(src, srcSize, tar, tarSize);    // 子问题 f(i-1) ：将 buf 顶部 i-1 个圆盘借助 src 移到 tar    dfs(i - 1, buf, bufSize, src, srcSize, tar, tarSize);}/* 求解汉诺塔 */void solveHanota(int *A, int *ASize, int *B, int *BSize, int *C, int *CSize) {    // 将 A 顶部 n 个圆盘借助 B 移到 C    dfs(*ASize, A, ASize, B, BSize, C, CSize);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-贪心"><a href="#2-贪心" class="headerlink" title="2.贪心"></a>2.贪心</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①概述</strong></p><blockquote><p>在问题的<strong>每个决策阶段</strong>，都选择<strong>当前</strong>看起来<strong>最优的选择</strong>，也称为<strong>贪心策略</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通常用来寻找最优解和近似最优解</div><p><strong>②算法特性</strong></p><blockquote><p><strong>贪心选择性质</strong>：只有当<strong>局部最优选择始终</strong>可以导致<strong>全局最优解</strong>时，才能<strong>保证得到最优解</strong></p></blockquote><blockquote><p><strong>最优子结构</strong>：<strong>原问题的最优解</strong>包含<strong>子问题的最优解</strong></p></blockquote><h4 id="2-2零钱兑换问题"><a href="#2-2零钱兑换问题" class="headerlink" title="2.2零钱兑换问题"></a>2.2零钱兑换问题</h4><p><strong>①概述</strong></p><blockquote><p>给定<strong>n种硬币</strong>，<strong>第i种硬币</strong>的<strong>面值</strong>为<code>coins[i-1]</code>，<strong>目标金额</strong>为<code>amt</code>，每种硬币<strong>可以重复选取</strong>，问能<strong>凑出目标金额</strong>的<strong>最少硬币个数</strong></p></blockquote><p><strong>②贪心策略</strong></p><blockquote><p><strong>每次决策</strong>，选择<strong>不大于且最接近剩余面值</strong>的硬币</p></blockquote><p><strong>③代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 零钱兑换：贪心 */int coinChangeGreedy(int *coins, int size, int amt) {    // 假设 coins 列表有序    int i = size - 1;    int count = 0;    // 循环进行贪心选择，直到无剩余金额    while (amt &gt; 0) {        // 找到小于且最接近剩余金额的硬币        while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {            i--;        }        // 选择 coins[i]        amt -= coins[i];        count++;    }    // 若未找到可行方案，则返回 -1    return amt == 0 ? count : -1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3分数背包问题"><a href="#2-3分数背包问题" class="headerlink" title="2.3分数背包问题"></a>2.3分数背包问题</h4><p><strong>①概述</strong></p><blockquote><p>给定<strong>n个物品</strong>，<strong>第i个物品</strong>对应的<strong>重量</strong>为<code>wgt[i-1]</code>，<strong>价值</strong>为<code>val[i-1]</code>，有一个<strong>容量</strong>为<code>cap</code>的<strong>背包</strong>，每个物品<strong>不能重复选取</strong>，<strong>可以选取物品的一部分</strong>，<strong>价值</strong>根据选择的<strong>重量比例</strong>计算，问在<strong>不超过背包容量</strong>下能放入物品的<strong>最大价值</strong></p></blockquote><p><strong>②贪心策略</strong></p><blockquote><p>将<strong>物品</strong>按照<strong>单位价值</strong>排序，每次<strong>优先</strong>选取<strong>单位价值最高</strong>的物品，若<strong>剩余背包容量不足</strong>，则使用当前物品的<strong>一部分</strong>填满背包</p></blockquote><p><strong>③代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 物品 */typedef struct {    int w; // 物品重量    int v; // 物品价值} Item;/* 分数背包：贪心 */float fractionalKnapsack(int wgt[], int val[], int itemCount, int cap) {    // 创建物品列表，包含两个属性：重量、价值    Item *items = malloc(sizeof(Item) * itemCount);    for (int i = 0; i &lt; itemCount; i++) {        items[i] = (Item){.w = wgt[i], .v = val[i]};    }    // 按照单位价值 item.v / item.w 从高到低进行排序    qsort(items, (size_t)itemCount, sizeof(Item), sortByValueDensity);    // 循环贪心选择    float res = 0.0;    for (int i = 0; i &lt; itemCount; i++) {        if (items[i].w &lt;= cap) {            // 若剩余容量充足，则将当前物品整个装进背包            res += items[i].v;            cap -= items[i].w;        } else {            // 若剩余容量不足，则将当前物品的一部分装进背包            res += (float)cap / items[i].w * items[i].v;            cap = 0;            break;        }    }    free(items);    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4最大容量问题"><a href="#2-4最大容量问题" class="headerlink" title="2.4最大容量问题"></a>2.4最大容量问题</h4><p><strong>①概述</strong></p><blockquote><p>输入一个<strong>数组</strong><code>ht</code>，<strong>每个元素</strong>相当于一个<strong>挡板</strong>，数组中<strong>任意两个挡板</strong>可以形成<strong>一个容器</strong>，<strong>容器高度</strong>由<strong>最短的挡板</strong>决定，<strong>容器宽度</strong>为<strong>两挡板索引之差</strong>，选择两挡板使得<strong>容器容量最大</strong></p></blockquote><p><strong>②贪心策略</strong></p><blockquote><p>选取<strong>挡板i</strong>和<strong>挡板j</strong>位于<strong>数组两端</strong>，记为<code>[i,j]</code>，并计算<strong>当前容量</strong>，记为<strong>最大容量</strong><code>max</code>，每次决策<strong>将短板向内收缩1</strong>，计算容量，如果<strong>大于最大容量即更新</strong>，直至<strong>两者相遇</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若长板向短板靠近，宽度一定减小，高度也只会不变或者减小，而短板向长板靠近，宽度虽然减少，但高度可能变大</div><p><strong>③代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 最大容量：贪心 */int maxCapacity(int ht[], int htLength) {    // 初始化 i, j 分列数组两端    int i = 0;    int j = htLength - 1;    // 初始最大容量为 0    int res = 0;    // 循环贪心选择，直至两板相遇    while (i &lt; j) {        // 更新最大容量        int capacity = myMin(ht[i], ht[j]) * (j - i);        res = myMax(res, capacity);        // 向内移动短板        if (ht[i] &lt; ht[j]) {            i++;        } else {            j--;        }    }    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5最大切分乘积问题"><a href="#2-5最大切分乘积问题" class="headerlink" title="2.5最大切分乘积问题"></a>2.5最大切分乘积问题</h4><p><strong>①概述</strong></p><blockquote><p>给定一个<strong>正整数n</strong>，将其切分为<strong>至少两个正整数</strong>，求切分后<strong>所有整数的乘积</strong>最大是多少</p></blockquote><p><strong>②贪心策略</strong></p><blockquote><p>如果切分方案中有<strong>大于4的因子</strong>，应该<strong>被继续切分</strong>，且<strong>不应该</strong>存在<strong>因子1</strong>，所以最后应该都<strong>切分为一堆2和3</strong>，而<strong>3x3</strong>大于<strong>2x2x2</strong>，所以<strong>切分到最后</strong>应该是<strong>一堆3</strong>和<strong>少于两个的2</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 先考虑简单的情况，将n切分为2和n-2，只要n大于4，n(n-2)大于n</div><p><strong>③代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 最大切分乘积：贪心 */int maxProductCutting(int n) {    // 当 n &lt;= 3 时，必须切分出一个 1    if (n &lt;= 3) {        return 1 * (n - 1);    }    // 贪心地切分出 3 ，a 为 3 的个数，b 为余数    int a = n / 3;    int b = n % 3;    if (b == 1) {        // 当余数为 1 时，将一对 1 * 3 转化为 2 * 2        return pow(3, a - 1) * 2 * 2;    }    if (b == 2) {        // 当余数为 2 时，不做处理        return pow(3, a) * 2;    }    // 当余数为 0 时，不做处理    return pow(3, a);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-回溯"><a href="#3-回溯" class="headerlink" title="3.回溯"></a>3.回溯</h3><h4 id="3-1引言"><a href="#3-1引言" class="headerlink" title="3.1引言"></a>3.1引言</h4><p><strong>①概述</strong></p><blockquote><p>从<strong>某一状态</strong>出发，根据<strong>选择</strong>不断<strong>向前推进</strong>搜索所有可能的<strong>解决方案</strong>，遇到<strong>正确的解</strong>则<strong>记录</strong>，直到<strong>找到解</strong>或者<strong>尝试了所有可能</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 状态表示问题在某一时刻的情况，包括已经做出的选择</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上还是穷举法，只是向前推进的方式可能不同</div><p><strong>②回退</strong></p><blockquote><p>遍历到<strong>某个状态</strong>，<strong>无法前进</strong>或者<strong>无法得到满足条件的解</strong>时，<strong>撤销</strong>上一个选择，回到<strong>之前的状态</strong>，并尝试<strong>其他可能</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 回退相当于推进的逆操作，不仅仅需要函数返回，还需要恢复状态</div><p><strong>③剪枝</strong></p><blockquote><p>当遍历到<strong>某个状态</strong>，不满足<strong>约束条件</strong>，则<strong>直接回退</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 去除了不满足约束条件的搜索分治，提高了搜索效率</div><p><strong>④代码框架</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 回溯算法框架 */void backtrack(State *state, Choice *choices, int numChoices, State *res, int numRes) {    // 判断是否为解    if (isSolution(state)) {        // 记录解        recordSolution(state, res, numRes);        // 停止继续搜索        return;    }    // 遍历所有选择    for (int i = 0; i &lt; numChoices; i++) {        // 剪枝：判断选择是否合法        if (isValid(state, &amp;choices[i])) {            // 尝试：做出选择，更新状态            makeChoice(state, &amp;choices[i]);            backtrack(state, choices, numChoices, res, numRes);            // 回退：撤销选择，恢复到之前的状态            undoChoice(state, &amp;choices[i]);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2全排列问题"><a href="#3-2全排列问题" class="headerlink" title="3.2全排列问题"></a>3.2全排列问题</h4><p><strong>①概述</strong></p><blockquote><p>输入一个<strong>整数数组</strong><code>nums[1A,1B,2]</code>，其中<strong>可能包含重复元素</strong>，返回<strong>所有不重复的排列</strong></p></blockquote><p><strong>②思路</strong></p><blockquote><p><strong>选择</strong>：每次<strong>添加的元素</strong></p></blockquote><blockquote><p><strong>状态</strong>：目前<strong>已经选择了哪些元素</strong></p></blockquote><blockquote><p><strong>剪枝</strong>：每个元素<strong>只能被选择一次</strong>，且<strong>相等元素是等价的</strong>，<strong>每个选择</strong>中，<strong>相同元素</strong>只能<strong>被选择一次</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个初始分支引入一数组selected，其中selected[i]表示该元素是否被选择，选择时先遍历该数组，跳过已选择元素</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每一轮选择引入一哈希表duplicated，记录该轮中已经尝试过的元素，并将重复元素剪枝</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意duplicated和selected剪枝的生效范围，duplicated是每次选择，selected是从每个初始子分支开始到结束</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_22.png" alt="全排列问题"><br><strong>③代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(nn!)，空间复杂度为O(n^2)</div><pre class="line-numbers language-none"><code class="language-none">/* 回溯算法：全排列 II */void backtrack(int *state, int stateSize, int *choices, int choicesSize, bool *selected, int **res, int *resSize) {    // 当状态长度等于元素数量时，记录解    if (stateSize == choicesSize) {        res[*resSize] = (int *)malloc(choicesSize * sizeof(int));        for (int i = 0; i &lt; choicesSize; i++) {            res[*resSize][i] = state[i];        }        (*resSize)++;        return;    }    // 遍历所有选择    bool duplicated[MAX_SIZE] = {false};    for (int i = 0; i &lt; choicesSize; i++) {        int choice = choices[i];        // 剪枝：不允许重复选择元素 且 不允许重复选择相等元素        if (!selected[i] &amp;&amp; !duplicated[choice]) {            // 尝试：做出选择，更新状态            duplicated[choice] = true; // 记录选择过的元素值            selected[i] = true;            state[stateSize] = choice;            // 进行下一轮选择            backtrack(state, stateSize + 1, choices, choicesSize, selected, res, resSize);            // 回退：撤销选择，恢复到之前的状态            selected[i] = false;        }    }}/* 全排列 II */int **permutationsII(int *nums, int numsSize, int *returnSize) {    int *state = (int *)malloc(numsSize * sizeof(int));    bool *selected = (bool *)malloc(numsSize * sizeof(bool));    for (int i = 0; i &lt; numsSize; i++) {        selected[i] = false;    }    int **res = (int **)malloc(MAX_SIZE * sizeof(int *));    *returnSize = 0;    backtrack(state, 0, nums, numsSize, selected, res, returnSize);    free(state);    free(selected);    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3子集和问题"><a href="#3-3子集和问题" class="headerlink" title="3.3子集和问题"></a>3.3子集和问题</h4><p><strong>①概述</strong></p><blockquote><p>给定一个<strong>正整数集合</strong><code>nums</code>和一个<strong>目标正整数</strong><code>target</code>，从<code>nums</code>找到<strong>所有可能的集合</strong>，使得<strong>组合中元素的和</strong>为<code>target</code>，<strong>每个元素</strong>可以被<strong>多次选择</strong>，但是<strong>集合不能重复</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 集合是不区分顺序的</div><p><strong>②思路</strong></p><blockquote><p><strong>选择</strong>：每次<strong>添加的元素</strong></p></blockquote><blockquote><p><strong>状态</strong>：集合中已经<strong>包含了哪些元素</strong></p></blockquote><blockquote><p><strong>剪枝</strong>：<strong>相等元素是等价的</strong>；<strong>相同元素的集合</strong>也是<strong>等价</strong>的；当<strong>元素总和</strong>大于<code>target</code>时，<strong>剪枝</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在全排列的基础上，不使用selected并去除相同集合即可</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当做出选择xi后，设定下一轮选择从索引开始，就可以保证子集唯一，因为其一定与其他分支不相交</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_24.png" alt="子集和问题"><br><strong>②代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 回溯算法：子集和 II */void backtrack(int target, int *choices, int choicesSize, int start) {    // 子集和等于 target 时，记录解    if (target == 0) {        for (int i = 0; i &lt; stateSize; i++) {            res[resSize][i] = state[i];        }        resColSizes[resSize++] = stateSize;        return;    }    // 遍历所有选择    // 剪枝二：从 start 开始遍历，避免生成重复子集    // 剪枝三：从 start 开始遍历，避免重复选择同一元素    for (int i = start; i &lt; choicesSize; i++) {        // 剪枝一：若子集和超过 target ，则直接跳过        if (target - choices[i] &lt; 0) {            continue;        }        // 剪枝四：如果该元素与左边元素相等，说明该搜索分支重复，直接跳过        if (i &gt; start &amp;&amp; choices[i] == choices[i - 1]) {            continue;        }        // 尝试：做出选择，更新 target, start        state[stateSize] = choices[i];        stateSize++;        // 进行下一轮选择        backtrack(target - choices[i], choices, choicesSize, i + 1);        // 回退：撤销选择，恢复到之前的状态        stateSize--;    }}/* 求解子集和 II */void subsetSumII(int *nums, int numsSize, int target) {    // 对 nums 进行排序    qsort(nums, numsSize, sizeof(int), cmp);    // 开始回溯    backtrack(target, nums, numsSize, 0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4N皇后问题"><a href="#3-4N皇后问题" class="headerlink" title="3.4N皇后问题"></a>3.4N皇后问题</h4><p><strong>①概述</strong></p><blockquote><p><strong>皇后棋子</strong>可以攻击<strong>同一行</strong>、<strong>同一列</strong>以及<strong>同一对角线</strong>的棋子，给定<code>n</code>个<strong>皇后</strong>以及<code>nxn</code>的<strong>棋盘</strong>，寻找<strong>所有</strong>可以使得<strong>皇后之间无法攻击</strong>的摆放方案</p></blockquote><p><strong>②思路</strong></p><blockquote><p><strong>选择</strong>：<strong>皇后</strong>的<strong>摆放位置</strong></p></blockquote><blockquote><p><strong>状态</strong>：棋盘上<strong>皇后个数</strong>以及<strong>各自摆放位置</strong></p></blockquote><blockquote><p><strong>剪枝</strong>：<strong>逐行放置</strong>皇后<strong>避免出现在同一行</strong>，<strong>在此基础上</strong>避免皇后出现在<strong>同一行</strong>和<strong>同一对角线</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个初始分支，使用长度为n的数组cols以及长度为2n-2长度的数组diag1和diag2记录每一列以及对角线是否有皇后</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 对角线分为主对角线和从对角线，分别对应diag1和diag2</div><blockquote><p>位于<strong>同一主对角线</strong>的元素，其<strong>横坐标减纵坐标的值</strong>相同，位于<strong>同一从对角线</strong>的元素，其<strong>横坐标加纵坐标的值</strong>相同，其中<strong>横纵坐标取值范围</strong>为<code>0~n-1</code>，所以<strong>横纵坐标之差/和</strong>的<strong>取值范围</strong>为<code>0~2n-2</code><strong>，每个值</strong>对应<strong>一条对角线</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/SF_23.png" alt="N皇后问题"><br><strong>③代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 回溯算法：N 皇后 */void backtrack(int row, int n, char state[MAX_SIZE][MAX_SIZE], char ***res, int *resSize, bool cols[MAX_SIZE],               bool diags1[2 * MAX_SIZE - 1], bool diags2[2 * MAX_SIZE - 1]) {    // 当放置完所有行时，记录解    if (row == n) {        res[*resSize] = (char **)malloc(sizeof(char *) * n);        for (int i = 0; i &lt; n; ++i) {            res[*resSize][i] = (char *)malloc(sizeof(char) * (n + 1));            strcpy(res[*resSize][i], state[i]);        }        (*resSize)++;        return;    }    // 遍历所有列    for (int col = 0; col &lt; n; col++) {        // 计算该格子对应的主对角线和副对角线        int diag1 = row - col + n - 1;        int diag2 = row + col;        // 剪枝：不允许该格子所在列、主对角线、副对角线存在皇后        if (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) {            // 尝试：将皇后放置在该格子            state[row][col] = 'Q';            cols[col] = diags1[diag1] = diags2[diag2] = true;            // 放置下一行            backtrack(row + 1, n, state, res, resSize, cols, diags1, diags2);            // 回退：将该格子恢复为空位            state[row][col] = '#';            cols[col] = diags1[diag1] = diags2[diag2] = false;        }    }}/* 求解 N 皇后 */char ***nQueens(int n, int *returnSize) {    char state[MAX_SIZE][MAX_SIZE];    // 初始化 n*n 大小的棋盘，其中 'Q' 代表皇后，'#' 代表空位    for (int i = 0; i &lt; n; ++i) {        for (int j = 0; j &lt; n; ++j) {            state[i][j] = '#';        }        state[i][n] = '\0';    }    bool cols[MAX_SIZE] = {false};           // 记录列是否有皇后    bool diags1[2 * MAX_SIZE - 1] = {false}; // 记录主对角线是否有皇后    bool diags2[2 * MAX_SIZE - 1] = {false}; // 记录副对角线是否有皇后    char ***res = (char ***)malloc(sizeof(char **) * MAX_SIZE);    *returnSize = 0;    backtrack(0, n, state, res, returnSize, cols, diags1, diags2);    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-动态规划"><a href="#4-动态规划" class="headerlink" title="4.动态规划"></a>4.动态规划</h3><h4 id="4-1引言"><a href="#4-1引言" class="headerlink" title="4.1引言"></a>4.1引言</h4><p><strong>①概述</strong></p><blockquote><p>将问题<strong>分解</strong>为<strong>一系列子问题</strong>，并<strong>通过dp表存储子问题的解</strong>避免<strong>重复计算</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 常用于解决最优化问题</div><p><strong>②DP问题特性</strong></p><blockquote><p><strong>重叠子问题</strong>：<strong>原问题</strong>可以分解为<strong>类似的子问题</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 与分治不同，动态规划的子问题是相互依赖的</div><blockquote><p><strong>最优子结构</strong>：<strong>原问题的最优解</strong>是从<strong>子问题的最优解</strong>构建得来的</p></blockquote><blockquote><p><strong>无后效性</strong>：问题的<strong>未来发展</strong>只与<strong>当前状态</strong>有关，与<strong>过去所经历过</strong>的所有状态<strong>无关</strong></p></blockquote><p><strong>③求解步骤</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 动态规划实质上就是根据状态转移方程在状态转移过程中填充dp表</div><blockquote><p><strong>定义状态</strong>：<strong>描述</strong>与问题<strong>有关的决策变量</strong>，足以<strong>推导出下一个状态</strong></p></blockquote><blockquote><p><strong>描述决策</strong>：<strong>一个状态</strong>如何变成<strong>另一个状态</strong></p></blockquote><blockquote><p><strong>推导状态转移方程</strong>：<strong>原问题</strong>和<strong>子问题</strong>的<strong>数值关系</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 根据原问题对应状态和子问题对应状态的关系推导</div><blockquote><p><strong>构建dp表</strong>：<strong>dp表</strong>即<strong>状态</strong>和<strong>对应子问题的解</strong>之间的<strong>映射</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> dp表的大小取决于状态的多少</div><blockquote><p><strong>确定边界条件</strong>：<strong>状态</strong>中各个<strong>变量的范围</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 根据边界条件初始化dp表</div><h4 id="4-2爬楼梯问题"><a href="#4-2爬楼梯问题" class="headerlink" title="4.2爬楼梯问题"></a>4.2爬楼梯问题</h4><p><strong>①概述</strong></p><blockquote><p>有一个<strong>n阶</strong>的<strong>楼梯</strong>，<strong>每步</strong>可以上<strong>1阶</strong>或者<strong>2阶</strong>，<strong>每一阶楼梯</strong>都有一个<strong>非负整数</strong>，表示在<strong>该台阶</strong>要付出的<strong>代价</strong><code>cost[i]</code>，计算<strong>最少要付出多少代价</strong>才能到达<strong>顶部</strong></p></blockquote><p><strong>②思路</strong></p><blockquote><p>假设<strong>爬到第i阶</strong>需要<strong>付出的代</strong>价为<code>dp[i]</code>，由于<strong>第i阶</strong>只能从<strong>第i-1阶</strong>和<strong>第i-2阶</strong>到达，所以<code>dp[i]=min(dp[i-1]+dp[i-2])+cost[i]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 本质上就是斐波那契数列的变种</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果使用递归的方法求解，时间复杂度为指数级，主要是由于子问题被计算了很多次造成的</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用dp数组保存子问题的结果，在需要的时候读取即可</div><p><strong>③代码实现</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 由于dp[i]只和dp[i-1]和dp[i-2]有关，所以我们无需存储所有子问题的解，使用两个变量滚动前进即可</div><pre class="line-numbers language-none"><code class="language-none">/* 爬楼梯最小代价：动态规划 */int minCostClimbingStairsDP(int cost[], int costSize) {    int n = costSize - 1;    if (n == 1 || n == 2)        return cost[n];    // 初始化 dp 表，用于存储子问题的解    int *dp = calloc(n + 1, sizeof(int));    // 初始状态：预设最小子问题的解    dp[1] = cost[1];    dp[2] = cost[2];    // 状态转移：从较小子问题逐步求解较大子问题    for (int i = 3; i &lt;= n; i++) {        dp[i] = myMin(dp[i - 1], dp[i - 2]) + cost[i];    }    int res = dp[n];    // 释放内存    free(dp);    return res;}/* 爬楼梯最小代价：空间优化后的动态规划 */int minCostClimbingStairsDPComp(int cost[], int costSize) {    int n = costSize - 1;    if (n == 1 || n == 2)        return cost[n];    int a = cost[1], b = cost[2];    for (int i = 3; i &lt;= n; i++) {        int tmp = b;        b = myMin(a, tmp) + cost[i];        a = tmp;    }    return b;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3最小路径和"><a href="#4-3最小路径和" class="headerlink" title="4.3最小路径和"></a>4.3最小路径和</h4><p><strong>①概述</strong></p><blockquote><p>给定一个<code>nxm</code>的<strong>网格</strong><code>grid</code>，<strong>每个单元格</strong>都有一个<strong>非负整数</strong>，表示<strong>该单元格的代价</strong>，每次只能<strong>向下</strong>或者<strong>向右</strong>移动一格，求<strong>左上角</strong>到<strong>右下角</strong>的<strong>最小路径和</strong></p></blockquote><p><strong>②思路</strong></p><blockquote><p><strong>定义状态</strong>：所在<strong>格子的坐标</strong><code>[i,j]</code></p></blockquote><blockquote><p><strong>描述决策</strong>：<strong>向下</strong>或者<strong>向右</strong>移动一格，即<code>i+1</code>或者<code>j+1</code></p></blockquote><blockquote><p><strong>状态转移方程</strong>：<code>dp[i，j]=min(dp[i-1,j],dp[i,j-1])+grid[i,j]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> dp[i,j]只能通过dp[i-1,j]或者dp[i,j-1]得到</div><blockquote><p><strong>根据边界条件初始化dp表</strong>：<strong>dp表</strong>为<code>nxm</code>的<strong>矩阵</strong>，<strong>第一列</strong>和<strong>第一行</strong>对应<strong>dp值</strong>均为<strong>所在单元格代价</strong></p></blockquote><p><strong>③代码实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(nm)，空间复杂度为O(nm)，dp表为一个nxm的矩阵</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 由于每个格子只与其左边和上边的格子有关，因此我们可以只用一个单行数组来实现dp表</div><pre class="line-numbers language-none"><code class="language-none">/* 最小路径和：动态规划 */int minPathSumDP(int grid[MAX_SIZE][MAX_SIZE], int n, int m) {    // 初始化 dp 表    int **dp = malloc(n * sizeof(int *));    for (int i = 0; i &lt; n; i++) {        dp[i] = calloc(m, sizeof(int));    }    dp[0][0] = grid[0][0];    // 状态转移：首行    for (int j = 1; j &lt; m; j++) {        dp[0][j] = dp[0][j - 1] + grid[0][j];    }    // 状态转移：首列    for (int i = 1; i &lt; n; i++) {        dp[i][0] = dp[i - 1][0] + grid[i][0];    }    // 状态转移：其余行列    for (int i = 1; i &lt; n; i++) {        for (int j = 1; j &lt; m; j++) {            dp[i][j] = myMin(dp[i][j - 1], dp[i - 1][j]) + grid[i][j];        }    }    int res = dp[n - 1][m - 1];    // 释放内存    for (int i = 0; i &lt; n; i++) {        free(dp[i]);    }    return res;}/* 最小路径和：空间优化后的动态规划 */int minPathSumDPComp(int grid[MAX_SIZE][MAX_SIZE], int n, int m) {    // 初始化 dp 表    int *dp = calloc(m, sizeof(int));    // 状态转移：首行    dp[0] = grid[0][0];    for (int j = 1; j &lt; m; j++) {        dp[j] = dp[j - 1] + grid[0][j];    }    // 状态转移：其余行    for (int i = 1; i &lt; n; i++) {        // 状态转移：首列        dp[0] = dp[0] + grid[i][0];        // 状态转移：其余列        for (int j = 1; j &lt; m; j++) {            dp[j] = myMin(dp[j - 1], dp[j]) + grid[i][j];        }    }    int res = dp[m - 1];    // 释放内存    free(dp);    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-40-1背包问题"><a href="#4-40-1背包问题" class="headerlink" title="4.40-1背包问题"></a>4.40-1背包问题</h4><p><strong>①概述</strong></p><blockquote><p>给定<strong>n个物品</strong>，<strong>第i个物品</strong>对应的<strong>重量</strong>为<code>wgt[i-1]</code>，<strong>价值</strong>为<code>val[i-1]</code>，有一个<strong>容量</strong>为<code>cap</code>的<strong>背包</strong>，每个物品<strong>不能重复选取</strong>，问在<strong>不超过背包容量</strong>下能放入物品的<strong>最大价值</strong></p></blockquote><p><strong>②思路</strong></p><blockquote><p><strong>定义状态</strong>：<strong>当前选择的物品i</strong>、<strong>剩余的背包容量c</strong></p></blockquote><blockquote><p><strong>描述决策</strong>：<strong>是否</strong>将当前物品<strong>放入背包</strong></p></blockquote><blockquote><p><strong>状态转移方程</strong>：<code>dp[i,c]=max(dp[i-1,c],dp[i-1,c-wgt[i-1]]+val[i-1])</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果当前物品重量超过背包剩余容量，则不能选取</div><blockquote><p><strong>根据边界条件初始化dp表</strong>：<strong>dp表</strong>为<code>(n+1)x(cap+1)</code>的<strong>矩阵</strong>，<strong>第一列</strong>和<strong>第一行</strong>对应<strong>dp值</strong>均为<strong>0</strong><br><strong>③代码实现</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间复杂度为O(nxcap)，空间复杂度为O(nxcap)</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 由于每个状态都只与其上一行的状态有关，所以可以将(n+1)x(cap+1)的矩阵替换为cap+1的数组存储结果</div><pre class="line-numbers language-none"><code class="language-none">/* 0-1 背包：动态规划 */int knapsackDP(int wgt[], int val[], int cap, int wgtSize) {    int n = wgtSize;    // 初始化 dp 表    int **dp = malloc((n + 1) * sizeof(int *));    for (int i = 0; i &lt;= n; i++) {        dp[i] = calloc(cap + 1, sizeof(int));    }    // 状态转移    for (int i = 1; i &lt;= n; i++) {        for (int c = 1; c &lt;= cap; c++) {            if (wgt[i - 1] &gt; c) {                // 若超过背包容量，则不选物品 i                dp[i][c] = dp[i - 1][c];            } else {                // 不选和选物品 i 这两种方案的较大值                dp[i][c] = myMax(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]);            }        }    }    int res = dp[n][cap];    // 释放内存    for (int i = 0; i &lt;= n; i++) {        free(dp[i]);    }    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-5零钱兑换问题"><a href="#4-5零钱兑换问题" class="headerlink" title="4.5零钱兑换问题"></a>4.5零钱兑换问题</h4><p><strong>①概述</strong></p><blockquote><p>给定<strong>n种硬币</strong>，<strong>第i种硬币</strong>的<strong>面值</strong>为<code>coins[i-1]</code>，<strong>目标金额</strong>为<code>amt</code>，每种硬币<strong>可以重复选取</strong>，问能<strong>凑出目标金额</strong>的<strong>最少硬币个数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 本质上就是不限制选择次数的0-1背包问题，也称为完全背包问题</div><p><strong>②思路</strong></p><blockquote><p><strong>定义状态</strong>：当前<strong>要选择的硬币</strong>，<strong>目前的总面额</strong></p></blockquote><blockquote><p><strong>描述决策</strong>：<strong>是否添加</strong>一枚<strong>当前面值的硬币i</strong></p></blockquote><blockquote><p><strong>状态转移方程</strong>：<code>dp[i,a]=min(dp[i-1,a],dp[i,a-coins[i-1]]+1)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 凑出atm面值只有两种情况，即已经凑出atm面值不选择多余的硬币，以及还差coins[i-1]并选择一枚i硬币</div><blockquote><p><strong>根据边界条件初始化dp表</strong>：<strong>dp表</strong>为<code>(n+1)x(amt+1)</code>的<strong>矩阵</strong>，<strong>第一列</strong>均为<code>0</code>，<strong>第一行</strong>除了<code>dp[0,0]</code>均为<code>max</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> max表示凑不出来</div><p><strong>③代码实现</strong></p><pre class="line-numbers language-none"><code class="language-none">/* 零钱兑换：动态规划 */int coinChangeDP(int coins[], int amt, int coinsSize) {    int n = coinsSize;    int MAX = amt + 1;    // 初始化 dp 表    int **dp = malloc((n + 1) * sizeof(int *));    for (int i = 0; i &lt;= n; i++) {        dp[i] = calloc(amt + 1, sizeof(int));    }    // 状态转移：首行首列    for (int a = 1; a &lt;= amt; a++) {        dp[0][a] = MAX;    }    // 状态转移：其余行列    for (int i = 1; i &lt;= n; i++) {        for (int a = 1; a &lt;= amt; a++) {            if (coins[i - 1] &gt; a) {                // 若超过目标金额，则不选硬币 i                dp[i][a] = dp[i - 1][a];            } else {                // 不选和选硬币 i 这两种方案的较小值                dp[i][a] = myMin(dp[i - 1][a], dp[i][a - coins[i - 1]] + 1);            }        }    }    int res = dp[n][amt] != MAX ? dp[n][amt] : -1;    // 释放内存    for (int i = 0; i &lt;= n; i++) {        free(dp[i]);    }    free(dp);    return res;}/* 零钱兑换：空间优化后的动态规划 */int coinChangeDPComp(int coins[], int amt, int coinsSize) {    int n = coinsSize;    int MAX = amt + 1;    // 初始化 dp 表    int *dp = calloc(amt + 1, sizeof(int));    dp[0] = 0;    // 状态转移    for (int i = 1; i &lt;= n; i++) {        for (int a = 1; a &lt;= amt; a++) {            if (coins[i - 1] &gt; a) {                // 若超过目标金额，则不选硬币 i                dp[a] = dp[a];            } else {                // 不选和选硬币 i 这两种方案的较小值                dp[a] = myMin(dp[a], dp[a - coins[i - 1]] + 1);            }        }    }    int res = dp[amt] != MAX ? dp[amt] : -1;    // 释放内存    free(dp);    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-6编辑距离问题"><a href="#4-6编辑距离问题" class="headerlink" title="4.6编辑距离问题"></a>4.6编辑距离问题</h4><p><strong>①概述</strong></p><blockquote><p>输入<strong>两个字符串</strong><code>s</code>和<code>t</code>，通过<strong>插入一个字符</strong>、<strong>删除一个字符</strong>或者<strong>替换一个字符</strong>，将<code>s</code><strong>转换</strong>为<code>t</code></p></blockquote><p><strong>②思路</strong></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言（二）</title>
      <link href="/2023/12/10/hui-bian-yu-yan-er/"/>
      <url>/2023/12/10/hui-bian-yu-yan-er/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言（二）"><a href="#汇编语言（二）" class="headerlink" title="汇编语言（二）"></a>汇编语言（二）</h1><h2 id="汇编语言基础"><a href="#汇编语言基础" class="headerlink" title="汇编语言基础"></a>汇编语言基础</h2><h3 id="1-程序分段"><a href="#1-程序分段" class="headerlink" title="1.程序分段"></a>1.程序分段</h3><blockquote><p>主要可分为<strong>数据段、栈段和程序段</strong></p></blockquote><h4 id="1-1内存申请"><a href="#1-1内存申请" class="headerlink" title="1.1内存申请"></a>1.1内存申请</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 定义了多少数据，就相当于申请了对应长度的内存空间</div><p><strong>①相关指令</strong></p><blockquote><p><code>db</code>：定义<strong>字节型数据</strong><br><code>db 数据1,数据2,...,数据N</code></p></blockquote><blockquote><p><code>dw</code>：定义<strong>字型数据</strong><br><code>dw 数据1,数据2,...,数据N</code></p></blockquote><blockquote><p><code>dd</code>：定义<strong>双字数据</strong><br><code>dd 数据1,数据2,...,数据N</code></p></blockquote><blockquote><p><code>dup</code>：配合<code>db</code>、<code>dw</code>、<code>dd</code>进行<strong>重复数据的定义</strong><br><code>dd 重复次数 dup (重复数据列表)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> dd 3 dup (0,1,2)相当于dd 0,1,2,0,1,2,0,1,2</div><p><strong>②实例</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 由于dw指令在程序开头，故这些数据的地址从CS:0开始</div><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h    mov bx,0    mov ax,0    mov cx,8  s: add ax.cs:[bx]    add bx,2    loop s    mov ax,400ch    int 21h  code ends  end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③程序跟踪</strong></p><blockquote><p>使用<code>-u</code>查看程序内容，这些内容实际上是<code>dw</code><strong>定义的数据</strong>，但是被<code>debug</code>程序<strong>强行翻译为指令</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_18.png" alt="查看程序"></p><blockquote><p>使用<code>-r</code>查看<strong>前十六个字节</strong>的详细内容</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_19.png" alt="查看"></p><h4 id="1-2设置程序入口"><a href="#1-2设置程序入口" class="headerlink" title="1.2设置程序入口"></a>1.2设置程序入口</h4><p><strong>①<code>start</code>伪指令</strong>：将<code>CS:IP</code>指向对应地址</p><blockquote><p>上述程序<strong>不能正常运行</strong>，因为程序入口是<strong>数据强行翻译的指令</strong></p></blockquote><p><strong>②实例</strong></p><blockquote><p><code>end start</code>伪指令不仅仅描述<strong>程序的结束</strong>，也描述了<strong>程序的入口</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hstart: mov bx,0    mov ax,0    mov cx,8 s: add ax.cs:[bx]    add bx,2    loop s    mov ax,400ch    int 21h  code ends  end start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3栈机制"><a href="#1-3栈机制" class="headerlink" title="1.3栈机制"></a>1.3栈机制</h4><p><strong>①引言</strong></p><blockquote><p><strong>概述</strong>：可以把<strong>一段内存</strong>当作<strong>栈</strong>来使用<br><code>push 容器</code>：将容器中数据放入<strong>栈顶</strong><br><code>pop 容器</code>：将栈顶数据弹出并<strong>存入容器</strong>中</p></blockquote><blockquote><p><strong>相关寄存器</strong><br>段寄存器<code>SS</code>和寄存器<code>SP</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> SS:SP指向栈顶的物理地址</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 指定了SS，也就相当于指定了一段内存作为栈，一个栈段最大为64KB</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_2.png" alt="CPU的栈机制"><br><strong>②push和pop的详细过程</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_3.png" alt="push"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_4.png" alt="pop"></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 执行pop后，原来的栈顶元素并不会消失，直到被新push的元素覆盖</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 当栈满时push元素以及当栈空时pop元素，都会发生越界问题，需要自己注意</div><p><strong>③实例</strong></p><blockquote><p><strong>概述</strong>：将一段内存中数据<strong>反序排列</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgcodesg segment;定义16个字型数据，其中0为字节型数据，将这段空间当作栈来使用dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0;设置栈顶指针，注意栈是从高地址向低地址增长start: mov ax,cs    mov ss,ax    mov sp,30h    mov bx,0    mov cx,8;将对应元素放入栈中s:  push cs:[bx]    add bx,2    loop s;重置循环相关寄存器    mov bx,0    mov cs,8;将栈中元素依次放入原来的位置，但是顺序颠倒s0: pop cs:[bx]    add bx,2    loop s0    mov ax,4c00h    int 21hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 栈的地址空间需要自己申请，并将ss:sp指向对应位置</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 栈从高地址向低地址增长</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 使用栈时要注意出栈、入栈顺序</div><h4 id="1-4使用多个段"><a href="#1-4使用多个段" class="headerlink" title="1.4使用多个段"></a>1.4使用多个段</h4><p><strong>①意义</strong></p><blockquote><p>将<strong>不同的类型数据</strong>放入<strong>不同的段</strong>中<br>使用<strong>更大的内存空间</strong></p></blockquote><p><strong>②实例</strong></p><pre class="line-numbers language-none"><code class="language-none">assume cs:code,ds:data,ss:stackdata segment;定义8个字型数据dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdata endsstack segment;申请栈空间dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0stack endscode segment;设置栈顶指针，注意栈是从高地址向低地址增长start: mov ax,stack ;注意段寄存器名换为段名    mov ss,ax    mov sp,20h ;为什么变为20h？;ds指向data段    mov ax,data    mov ds,ax    mov bx,0    mov cx,8;将对应元素放入栈中s:  push [bx]    add bx,2    loop s;重置循环相关寄存器    mov bx,0    mov cs,8;将栈中元素依次放入原来的位置，但是顺序颠倒s0: pop [bx]    add bx,2    loop s0    mov ax,4c00h    int 21hcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 定义段，还需要申请一定大小的的内存</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> assume指令只是将段寄存器和对应段的名称联系到一起，并没有设定段寄存器的值，因为assume本质上还是一个伪指令，伪指令并不能控制cpu，还是需要修改ds、ss的值以访问对应段</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 段名本质上是一个字面值，不能直接将其存入段寄存器中</div><pre class="line-numbers language-none"><code class="language-none">mov ax,datamov ds,ax;而不是mov ds,data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2-转移"><a href="#2-转移" class="headerlink" title="2.转移"></a>2.转移</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①转移指令</strong></p><blockquote><p>可以修改<code>IP</code>寄存器或者<strong>同时</strong>修改<code>CS</code>和<code>IP</code>寄存器的指令</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 转移指令可以控制CPU执行某一处代码</div><p><strong>②分类</strong></p><blockquote><p><strong>段内转移</strong>：只修改<code>IP</code><br><strong>段间转移</strong>：同时修改<code>CS</code>和<code>IP</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 段内转移也可分为短转移和近转移</div><blockquote><p><strong>短转移</strong>：<code>IP</code>修改范围为<code>-128~127</code><br><strong>近转移</strong>：<code>IP</code>修改范围为<code>-32768~32767</code></p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 注意这个范围限制，如果超出了对应的范围，会出错</div><p><strong>③<code>offset</code>操作符</strong></p><blockquote><p>取得<strong>标号</strong>的<strong>偏移地址</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgcodesg segmentstart: mov ax,offset start ;相当于mov ax，0，代码段的偏移地址从0开始s:     mov ax,offset s ;相当于mov ax，3，因为前一条指令占两个字节<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> seg会取得标号的段地址</div><h4 id="2-2跳转指令"><a href="#2-2跳转指令" class="headerlink" title="2.2跳转指令"></a>2.2跳转指令</h4><p><strong>①格式</strong></p><blockquote><p><strong>标号转移</strong><br><code>jmp short 标号</code>：<strong>段内短转移</strong><br><code>jmp near ptr 标号</code>：<strong>段内近转移</strong><br><code>jmp far ptr 标号</code>：<strong>段间转移</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 标号实际上标识了一个地址</div><blockquote><p><strong>地址转移</strong><br><code>jmp 段地址：偏移地址</code>：将<code>CS:IP</code>修改为对应的地址<br><code>jmp 寄存器名</code>：将<code>IP</code>的值改为<strong>寄存器中数据</strong><br><code>jmp word ptr 内存单元地址</code>：从对应地址处读取<strong>一个字</strong>，用于修改<code>IP</code><br><code>jmp dword ptr 内存单元地址</code>从对应地址处读取<strong>两个字</strong>，<strong>高地址</strong>的字用于修改<code>CS</code>，<strong>低地址</strong>的字用于修改<code>IP</code></p></blockquote><blockquote><p><strong>条件转移</strong><br><code>jcxz 标号</code>：如果<code>cx</code><strong>寄存器</strong>的值为0，则跳转到<strong>标号</strong>处，只能<strong>段内短转移</strong></p></blockquote><p><strong>②段内转移原理</strong></p><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgcodesg segmentstart: mov ax,0       jmp short s       add ax,1s:     inc axcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在<code>debug</code>中将上述程序其翻译为<strong>机器指令</strong>，可知<code>jmp short s</code>对应<strong>机器指令</strong>为<code>EB03</code></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_21.png" alt="对应机器指令"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_22.png" alt="转移原理"></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 段内转移对应机器指令并不包含目的地址信息，段内短转移是对IP进行八位位移，段内近转移是对IP进行十六位位移</div><p><strong>③段间转移原理</strong></p><pre class="line-numbers language-none"><code class="language-none">assume cs:codesgcodesg segmentstart: mov ax,0       mov bx,0       jmp far ptr s       db 256 dup (0)s:     add ax,1       inc axcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>对应<strong>机器指令</strong>如下，<code>jmp far ptr s</code>对应机器指令为<code>EA0B01BD0B</code></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_23.png" alt="对应机器指令"></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 段间转移对应机器指令包含目的地址信息，BD0B为对应段地址0BBDH，0B01为对应偏移地址010BH</div><h4 id="2-3循环指令"><a href="#2-3循环指令" class="headerlink" title="2.3循环指令"></a>2.3循环指令</h4><p><strong>①格式</strong>：<code>loop 标号</code></p><blockquote><p>当cpu执行到<code>loop</code>指令时，首先将<strong>循环寄存器</strong><code>cx</code>中的值<strong>减一</strong>，若cx中的值<strong>不为零</strong>，则<strong>返回标号处</strong>执行程序，反之向下执行</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 循环指令本质上是一个短转移</div><p><strong>②实例</strong></p><blockquote><p>以下汇编程序计算了<code>2^12</code>的值</p></blockquote><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segment    mov ax,2    mov cx,11s:  add ax.ax    loop s    mov ax,4c00h    int 21hcode endsend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③多重循环</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因为只有一个循环寄存器，若要多重循环，则每次开始内层循环时，将外层循环的cx中的数值保存起来，在执行外层的循环时，再恢复外层循环的cx数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以用栈、寄存器和某块特定内存（数据域中申请）存储数据</div><pre class="line-numbers language-none"><code class="language-none">assume cs:codesg,ds:datasg,ss:stacksgdatasg segmentdb 'ibm             'db 'dec             'db 'dos             'db 'vax             'datasg endsstacksg segmentdw 0,0,0,0,0,0,0,0 ;定义一个栈段，容量为16字节stacksg endscodesg segmentstart:mov ax,stacksg ;将栈寄存器指向定义的栈段    mov ss,ax    mov sp,16    mov ax datasg ;找到对应的数据段    mov ds,ax    mov bx,0    mov cx,4s0: push cx ;保存外层循环的值    mov si,0    mov cx,3 ;将cx设置为内层循环的次数s:  mov al,[bx+si]    and al,11011111b ;将对应字母转化为大写    mov [bx+si],al    inc si ;si每次加1，进行精定位    loop s    add bx,16 ;bx每次加16，进行粗定位，移动到下一行    pop cx        loop s0    mov ax,4c00H    int 21Hcodesg endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/HB_20.png" alt="图解"></p><h4 id="2-4栈跳转"><a href="#2-4栈跳转" class="headerlink" title="2.4栈跳转"></a>2.4栈跳转</h4><p><strong>①相关指令</strong></p><blockquote><p><code>ret</code>：使用<strong>栈中的数据</strong>修改<code>IP</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相当于pop IP</div><blockquote><p><code>retf</code>：使用<strong>栈中的数据</strong>修改<code>CS</code>和<code>IP</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相当于pop IP和pop CS</div><blockquote><p><code>call 标号</code>：将当前<code>IP</code><strong>压入栈</strong>中，并<strong>转移到标号处</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相当于push IP和jmp near ptr 标号</div><blockquote><p><code>call 16位寄存器</code>：将当前<code>IP</code><strong>压入栈</strong>中，并将<code>IP</code>设置为<strong>对应寄存器值</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相当于push IP和jmp 16位寄存器</div><blockquote><p><code>call word ptr 内存单元地址</code>：将当前<code>IP</code><strong>压入栈</strong>中，并将<code>IP</code>设置为<strong>对应内存单元数据</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相当于push IP和jmp word ptr 内存单元地址</div><blockquote><p><code>call dword ptr 内存单元地址</code>：将当前<code>CS</code>和<code>IP</code><strong>压入栈</strong>中，并将<code>CS</code>和<code>IP</code>设置为<strong>对应内存单元数据</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 相当于push CS、push IP和jmp dword ptr 内存单元地址</div><p><strong>②<code>call</code>和<code>ret</code>的配合使用</strong></p><pre class="line-numbers language-none"><code class="language-none">assume cs:codecode segmentstart: mov ax,1       mov cx,3       call s       mov bx,ax       mov ax,4c00h       int 21s:     add ax,ax       loop s       retcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>程序过程概述</strong></p></blockquote><blockquote><p><strong>（1）</strong>当CPU读取<code>call s</code>指令后，<code>IP</code>指向了<strong>其后面</strong>的指令<code>mov bx,ax</code>，随后执行<code>call s</code>指令，将<strong>当前的<code>IP</code>值</strong>（<code>mov bx,ax</code>的偏移地址）<strong>压栈</strong>，并将<code>IP</code>指向标号<code>s</code><br><strong>（2）</strong>执行标号<code>s</code>处的循环，即<code>2^3</code><br><strong>（3）</strong>CPU读取<code>ret</code>指令，<code>IP</code>指向<code>ret</code>指令后的内存单元，CPU执行<code>ret</code>指令，此时<code>IP</code>指向<code>mov bx,ax</code>，随后执行至完成</p></blockquote><h3 id="3-模块化"><a href="#3-模块化" class="headerlink" title="3.模块化"></a>3.模块化</h3><h4 id="3-1模板"><a href="#3-1模板" class="headerlink" title="3.1模板"></a>3.1模板</h4><pre class="line-numbers language-none"><code class="language-none">assume cd:codecode segmentmain:    ... ;主程序内容    mov ax,4c00h    int 21hsub1:    ... ;子程序1内容    sub2:    ... ;子程序2内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2实例"><a href="#3-2实例" class="headerlink" title="3.2实例"></a>3.2实例</h4><blockquote><p>计算<strong>一组数据</strong>的三次方，并保存在<strong>其后</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">assume cs:codedata segment    dw 1,2,3,4,5,6,7,8    dd 0,0,0,0,0,0,0,0data endscode segementstart: mov ax,data       mov ds,ax       mov si,0       mov di,16       mov cx,8s:     mov bx,[si]       call cube       mov [di],ax       mov [di].2,dx       add si,2       add di,4       loop s       mov ax,4c00h       int 21hcube:  mov ax,bx       mul bx       mul bx       retcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3批量数据传递"><a href="#3-3批量数据传递" class="headerlink" title="3.3批量数据传递"></a>3.3批量数据传递</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 利用循环以及寄存器</div><blockquote><p>将一段数据全部转化为<strong>大写</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">assume cs:codedata segment    db 'conversation'data endscode segmentstart: mov ax,data       mov ds,ax       mov si,0       mov cx,12       call capital       mov ax,4c00h       int 21hcapital: and byte ptr [si],11011111b         inc si         loop capital         retcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4寄存器冲突"><a href="#3-4寄存器冲突" class="headerlink" title="3.4寄存器冲突"></a>3.4寄存器冲突</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 子程序和主程序寄存器冲突，在子程序开始之前将所有用到的寄存器中的内容保存起来，在子程序返回前在恢复</div><pre class="line-numbers language-none"><code class="language-none">assume cs:codedata segment    db 'word',0    db 'unix',0    db 'wind',0    db 'good',0data endscode segmentstart: mov ax,data       mov ds,ax       mov bx,0       mov cx,4s:     mov si,bx       call capital       add bx,5       loop scapital: push cx         push sichange:  mov cl,[si]         mov ch,0         jcxz ok         and byte ptr [si],11011111b         inc si         jmp short changeok:      pop si         pop cx         retcode endsend start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《汇编语言》 </tag>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法范式（下）</title>
      <link href="/2023/12/10/suan-fa-fan-shi-xia/"/>
      <url>/2023/12/10/suan-fa-fan-shi-xia/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 《hello 算法》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cmake应用（一）</title>
      <link href="/2023/12/10/cmake-ying-yong-yi/"/>
      <url>/2023/12/10/cmake-ying-yong-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h1><h2 id="Cmake应用（一）"><a href="#Cmake应用（一）" class="headerlink" title="Cmake应用（一）"></a>Cmake应用（一）</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1Cmke概述"><a href="#1-1Cmke概述" class="headerlink" title="1.1Cmke概述"></a>1.1<code>Cmke</code>概述</h4><blockquote><p>一个<strong>跨平台</strong>的<strong>项目构建工具</strong>，根据<code>CMakeLists.txt</code><strong>文件</strong>自动生成（<code>cmake</code>命令）<strong>本地化</strong>的<code>makefile</code>，最后只需要<code>make</code>命令即可获得<strong>目标文件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用Cmke本质上就是在项目文件夹中编写CMakeLists.txt</div><h4 id="1-2基本指令"><a href="#1-2基本指令" class="headerlink" title="1.2基本指令"></a>1.2基本指令</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CMake支持大写、小写、混合大小写的命令</div><p><strong>①注释</strong></p><blockquote><p><strong>单行注释</strong>：以<code>#</code>开头，以<strong>换行符</strong>结束<br><strong>多行注释</strong>：以<code>#[[</code>开头，以<code>]]</code>结尾</p></blockquote><p><strong>②<code>cmake_minimum_required</code></strong></p><blockquote><p>指定<code>Cmake</code>的<strong>最低版本</strong><br><strong>格式</strong>：<code>cmake_minimum_required(VERSION 3.0.0)</code></p></blockquote><p><strong>③<code>project</code></strong></p><blockquote><p>指定<strong>工程信息</strong>，包括<strong>名字</strong>、<strong>版本</strong>、<strong>描述</strong>、<strong>web主页地址</strong>和<strong>支持的语言</strong>等</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只有项目的名字是必须的，其余都可忽略，缺省情况下支持所有CMake支持的语言</div><blockquote><p><strong>格式</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none"># PROJECT 指令的语法是：project(&lt;PROJECT-NAME&gt; [&lt;language-name&gt;...])project(&lt;PROJECT-NAME&gt;       [VERSION &lt;major&gt;[.&lt;minor&gt;[.&lt;patch&gt;[.&lt;tweak&gt;]]]]       [DESCRIPTION &lt;project-description-string&gt;]       [HOMEPAGE_URL &lt;url-string&gt;]       [LANGUAGES &lt;language-name&gt;...])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④<code>add_executable</code></strong></p><blockquote><p>生成<strong>可执行文件</strong>，需要指定<strong>可执行文件名</strong>和<strong>源文件</strong><br><strong>格式</strong>：<code>add_executable(可执行文件名 源文件名称)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 源文件名可以是一个也可以是多个，如有多个可用空格或;间隔</div><p><strong>⑤<code>message</code></strong></p><blockquote><p><strong>显示一条信息</strong><br><strong>格式</strong>：<code>message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] "message to display" ...)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> CMake警告和错误消息的文本显示使用的是一种简单的标记语言，文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。</div><blockquote><p><strong>状态</strong><br><code>(无)</code> ：<strong>重要</strong>消息<br><code>STATUS</code> ：<strong>非重要</strong>消息<br><code>WARNING</code>：<strong>警告</strong><br><code>AUTHOR_WARNING</code>：<strong>警告(dev)</strong><br><code>SEND_ERROR</code>：<strong>错误</strong>， <strong>继续执行</strong>，但是会<strong>跳过生成的步骤</strong><br><code>FATAL_ERROR</code>：<strong>错误</strong>， <strong>终止所有处理过程</strong></p></blockquote><p><strong>⑥<code>add_definitions</code></strong></p><blockquote><p>定义宏<br>格式：<code>add_definitions(-D宏名称)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在对应程序中定义宏，而不是在CMakeLists中定义宏</div><h4 id="1-3例子"><a href="#1-3例子" class="headerlink" title="1.3例子"></a>1.3例子</h4><p><strong>①概述</strong></p><blockquote><p>有四个<strong>源文件</strong><code>main.cc</code>、<code>a.cc</code>、<code>b.cc</code>、<code>c.cc</code>，以及一个<strong>头文件</strong><code>head.h</code>，其中<code>main.cc</code><strong>调用</strong>了另外三个源文件，<code>head.h</code>中包含了对应<strong>声明</strong></p></blockquote><p><strong>②CmakeLists文件编写</strong></p><pre class="line-numbers language-none"><code class="language-none">#CMake最低版本为3.15cmake_minimum_required(VERSION 3.15)#项目名称为exampleproject(example)#将main.cc a.cc b.cc c.cc编译为可执行文件mainadd_executable(main main.cc a.cc b.cc c.cc)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③生成可执行文件</strong></p><blockquote><p>在<strong>终端</strong>执行<code>cmake CmakeLists所在路径</code>命令，会在<strong>当前路径</strong>生成<code>makefile</code>等文件，再执行<code>make</code>命令即可</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常在项目文件文件夹中建造一个build文件夹，在该路径下执行上述命令，将相关文件和源文件分开</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在使用Cmke指令时，需要保证其后接路径下不能有相关文件</div><hr><h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h3><h4 id="2-1创建与使用"><a href="#2-1创建与使用" class="headerlink" title="2.1创建与使用"></a>2.1创建与使用</h4><p><strong>①<code>set</code></strong></p><blockquote><p><strong>定义/修改变量</strong>，参数分别为<strong>变量名</strong>、<strong>变量的值（可以是多个）</strong>以及一些<strong>自定义选项（非必须）</strong><br><strong>格式</strong>：<code>SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 缺省情况下，Cmake中的变量都是字符串（ITEM）或者字符串列表（LIST）</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过set进行变量的拼接</div><blockquote><p><code>set(变量名1 ${变量名1} ${变量名2} ...)</code></p></blockquote><p><strong>②变量的使用</strong></p><blockquote><p><code>${变量名}</code>：将<strong>变量名</strong>转化为<strong>对应的值</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">set(SRC_LIST main.cc a.cc b.cc c.cc)add_executable(main  ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> Cmake中，给变量赋值时，空格会被当作分隔符，如果想要使得变量中包含空格，则需要用双引号包围</div><blockquote><p>以下程序输出<code>abc</code>和<code>a b c</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">set(WORD1 a b c)        #WORD1是一个字符串列表set(WORD2 "a b c")      #WORD2是一个字符串message(STATUS ${WORD1}) message(STATUS ${WORD2}) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2变量操作"><a href="#2-2变量操作" class="headerlink" title="2.2变量操作"></a>2.2变量操作</h4><p><strong>①<code>list</code></strong></p><blockquote><p>根据<strong>操作码</strong>对<strong>列表</strong>进行<strong>不同的操作</strong></p></blockquote><p><strong>②追加</strong></p><blockquote><p><strong>格式</strong>：<code>list (APPEND &lt;list&gt; [&lt;value&gt; ...])</code><br><code>&lt;list&gt;</code>：当前操作的<strong>列表</strong><br><code>&lt;element&gt;</code>：可以是<strong>字面值</strong>，也可以是<strong>变量的值</strong></p></blockquote><p><strong>③移除</strong></p><blockquote><p><strong>格式</strong>：<code>list (REMOVE_ITEM &lt;list&gt; &lt;value&gt; [&lt;value&gt; ...])</code></p></blockquote><p><strong>④读取</strong></p><blockquote><p><strong>格式</strong>：<code>list(GET &lt;list&gt; &lt;element index&gt; [&lt;element index&gt; ...] &lt;output variable&gt;)</code><br><code>&lt;element index&gt;</code>：列表元素的<strong>索引</strong>，从<code>0</code>开始，若为<strong>负数</strong>，则表示<strong>倒数</strong>第几个元素</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其他操作可查询官网</div><h4 id="2-3预定义宏"><a href="#2-3预定义宏" class="headerlink" title="2.3预定义宏"></a>2.3预定义宏</h4><p><strong>①<code>CMAKE_CXX_STANDARD</code></strong></p><blockquote><p><strong>C++标准</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#增加-std=c++11set(CMAKE_CXX_STANDARD 11)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>②<code>EXECUTABLE_OUTPUT_PATH</code></strong></p><blockquote><p><strong>可执行文件输出路径</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#定义一个变量用于存储一个绝对路径set(HOME /home/robin/Linux/Sort)#将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如果路径不存在，则会自动创建</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 最好使用绝对路径，如果使用相对路径，则./代表的是makefile所在路径</div><p><strong>③<code>PROJECT_SOURCE_DIR</code></strong></p><blockquote><p><strong>Cmke指令后接的路径</strong></p></blockquote><p><strong>④<code>CMAKE_CURRENT_SOURCE_DIR</code></strong></p><blockquote><p><code>CmakeLists</code><strong>文件所在路径</strong></p></blockquote><h3 id="3-结构化"><a href="#3-结构化" class="headerlink" title="3.结构化"></a>3.结构化</h3><h4 id="3-1文件搜索"><a href="#3-1文件搜索" class="headerlink" title="3.1文件搜索"></a>3.1文件搜索</h4><p><strong>①<code>aux_source_directory</code></strong></p><blockquote><p>查找<strong>某个路径</strong>下的<strong>所有源文件</strong>，并将源文件列表<strong>存储到对应变量中</strong><br><strong>格式</strong>：<code>aux_source_directory(&lt; dir &gt; &lt; variable &gt;)</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none"># 搜索当前目录下的源文件aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR} SRC_LIST)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>②<code>file</code></strong></p><blockquote><p>查找<strong>某个路径</strong>下的所有<strong>指定格式</strong>的文件<br><strong>格式</strong>：<code>file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> GLOB表示只搜索当前路径，GLOB_RECURSE还会递归搜索当前路径下的所有子目录</div><pre class="line-numbers language-none"><code class="language-none">#搜索对应路径下的源文件file(GLOB MAIN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)#搜索对应路径下的头文件file(GLOB MAIN_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2头文件路径"><a href="#3-2头文件路径" class="headerlink" title="3.2头文件路径"></a>3.2头文件路径</h4><p><strong>①引言</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通常，大型项目将源文件、头文件等分开放，如下所示</div><pre class="line-numbers language-none"><code class="language-none">$ tree.├── build├── CMakeLists.txt├── include│&nbsp;&nbsp; └── head.h└── src    ├── main.cc    ├── a.cc    ├── b.cc    └── c.cc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②<code>include_directories</code></strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 由于#include " "指令只在当前目录下寻找头文件，以上情况需要添加头文件路径</div><blockquote><p><strong>格式</strong>：<code>include_directories (headpath)</code>，<code>headpath</code>为<strong>头文件路径</strong></p></blockquote><h4 id="2-3改进后的CmakeLists"><a href="#2-3改进后的CmakeLists" class="headerlink" title="2.3改进后的CmakeLists"></a>2.3改进后的CmakeLists</h4><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.15)project(example)#添加C++11标准set(CMAKE_CXX_STANDARD 11)#设置头文件路径include_directories(${PROJECT_SOURCE_DIR}/include)#搜索所有源文件file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)#生成可运行文件add_executable(main  ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-动态库和静态库"><a href="#4-动态库和静态库" class="headerlink" title="4.动态库和静态库"></a>4.动态库和静态库</h3><h4 id="4-1引言"><a href="#4-1引言" class="headerlink" title="4.1引言"></a>4.1引言</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 库文件本质上是源文件的二进制格式</div><p><strong>①静态库</strong></p><blockquote><p><strong>优点</strong>：<strong>打包到应用程序中</strong>，加载速度快，移植方便<br><strong>缺点</strong>：内存中可能出现<strong>多份静态库</strong>（多个链接该库的程序一起运行），且如果<strong>静态库更新</strong>，则项目需要<strong>重新编译</strong></p></blockquote><p><strong>②动态库</strong></p><blockquote><p><strong>优点</strong>：<strong>多个进程共享</strong>，只有<strong>在调用时才被载入内存</strong>，动态库更新<strong>无需重新编译程序</strong><br><strong>缺点</strong>：加载<strong>速度比静态库慢（可忽略）</strong>，发布程序需要<strong>提供依赖的动态库</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 动态库有可执行权限，而静态库没有</div><p><strong>③文件架构</strong></p><pre class="line-numbers language-none"><code class="language-none">.├── build├── lib├── CMakeLists.txt├── include           # 头文件目录│&nbsp;&nbsp; └── head.h├── main.cc           # 用于测试的源文件└── src               # 源文件目录    ├── a.cc    ├── b.cc    └── c.cc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-2制作库"><a href="#4-2制作库" class="headerlink" title="4.2制作库"></a>4.2制作库</h4><p><strong>①<code>add_library</code></strong></p><blockquote><p>将对应<strong>源文件</strong>制作为<strong>静态库/动态库</strong><br><strong>格式</strong>：<code>add_library(库名称 STATIC/SHARED 源文件1 [源文件2] ...)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中计算机中的库名由三部分组成lib+库名+后缀，命令中只需要指定库名即可，其余计算机自动填充</div><p><strong>②指定输出路径</strong></p><blockquote><p>通过指定<strong>系统变量</strong><code>LIBRARY_OUTPUT_PATH</code><br><strong>例子</strong>：<code>set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不指定则生成到当前路径中</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其中，动态库的生成路径还可以通过改变EXECUTABLE_OUTPUT_PATH，因为动态库是一个可执行文件</div><p><strong>③对应CmakeLists文件</strong></p><blockquote><p>将<code>src</code><strong>文件夹</strong>中文件构建为<strong>库文件</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.15)project(example)include_directories(${PROJECT_SOURCE_DIR}/include)file(GLOB SRC_LIST "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")# 设置动态库/静态库生成路径set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)# 生成动态库，将SHARED修改为STATIC即可生成静态库#add_library(abc SHARED ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3使用库文件"><a href="#4-3使用库文件" class="headerlink" title="4.3使用库文件"></a>4.3使用库文件</h4><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 库文件的生成和库文件的使用是两个项目</div><p><strong>①<code>link_libraries</code></strong></p><blockquote><p><strong>链接静态库</strong><br><strong>格式</strong>：<code>link_libraries(&lt;static lib&gt; [&lt;static lib&gt;...])</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中static lib可以写全名，也可以只写中间部分</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 由于静态库是可执行文件的一部分，故需要在可执行文件生成前链接</div><p><strong>②<code>target_link_libraries</code></strong></p><blockquote><p><strong>链接动态库</strong><br><strong>格式</strong>：如下所示，<code>target</code>为<strong>链接动态库的文件</strong>，<code>PRIVATE|PUBLIC|INTERFACE</code>为动态库的<strong>访问权限</strong>，<strong>缺省</strong>为<code>PUBLIC</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> `target`可能是可执行文件、源文件或者动态库文件</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 由于动态库不是可执行文件的一部分，故需要在可执行文件生成后链接</div><pre class="line-numbers language-none"><code class="language-none">target_link_libraries(    &lt;target&gt;     &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...     [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 动态库链接具有传递性，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法（PUBLIC情况下）</div><blockquote><p><strong>访问权限</strong><br><code>PUBLIC</code>：在<code>PUBLIC</code>后面的库会被<strong>链接</strong>到前面的<code>target</code>中，并且里面的符号也会被导出<br><code>PRIVATE</code>：在<code>PRIVATE</code>后面的库<strong>仅被链接到前面的<code>target</code>中</strong>，<strong>不会传递</strong><br><code>INTERFACE</code>：在<code>INTERFACE</code>后面引入的库<strong>不会被链接到前面的target中</strong>，只会导出<strong>符号</strong>，并<strong>不知道库的信息</strong>，同样也<strong>不会传递</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 动态库和静态库也可以相互链接，相互之间不会影响各自特性</div><p><strong>③<code>link_directories</code></strong></p><blockquote><p><strong>指定库的路径</strong><br><strong>格式</strong>：<code>link_directories(lib_path)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如果使用非系统提供的库文件，则需要指明库文件路径，便于编译器找到</div><h4 id="4-4例子"><a href="#4-4例子" class="headerlink" title="4.4例子"></a>4.4例子</h4><p><strong>①文件架构</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用库文件还需要包含相关头文件（包含库文件使用的函数声明）</div><pre class="line-numbers language-none"><code class="language-none">.├── build├── CMakeLists.txt├── include│&nbsp;&nbsp; └── head.h              #库文件对应的头文件├── lib│&nbsp;&nbsp; └── libabc.a（.so）     # 制作出的静态库（动态库）的名字└── src    └── main.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②静态库版本</strong></p><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.15)project(example)# 搜索指定目录下源文件file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)# 包含头文件路径include_directories(${PROJECT_SOURCE_DIR}/include)# 包含静态库路径link_directories(${PROJECT_SOURCE_DIR}/lib)# 链接静态库link_libraries(abc)add_executable(main ${SRC_LIST})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③动态库版本</strong></p><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.15)project(example)file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp)# 指定源文件或者动态库对应的头文件路径include_directories(${PROJECT_SOURCE_DIR}/include)# 指定要链接的动态库的路径link_directories(${PROJECT_SOURCE_DIR}/lib)# 添加并生成一个可执行程序add_executable(main ${SRC_LIST})# 指定要链接的动态库，其中libpthread.so为系统提供的线程库target_link_libraries(main pthread abc)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 工具链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码工具 </tag>
            
            <tag> Cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM体系结构</title>
      <link href="/2023/12/10/arm-ti-xi-jia-gou/"/>
      <url>/2023/12/10/arm-ti-xi-jia-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="ARM体系结构"><a href="#ARM体系结构" class="headerlink" title="ARM体系结构"></a>ARM体系结构</h1><h2 id="ARM体系结构（一）"><a href="#ARM体系结构（一）" class="headerlink" title="ARM体系结构（一）"></a>ARM体系结构（一）</h2><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要介绍的是运行在AArch64状态的ARMv8结构</div><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1ARM体系结构"><a href="#1-1ARM体系结构" class="headerlink" title="1.1ARM体系结构"></a>1.1ARM体系结构</h4><p><strong>①定义</strong></p><blockquote><p><strong>概述</strong>：一种<strong>硬件规范</strong>，约定<strong>芯片内部体系结构</strong>以及<strong>指令集的格式规范</strong>，并<strong>不关心</strong>具体的<strong>硬件实现</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ARM授权体系结构或者处理IP，前者可自行设计与之兼容的处理器，后者为一个设计方案</div><p><strong>②分类</strong></p><blockquote><p><strong>A系列</strong>：面向<strong>性能密集型系统</strong>的应用处理器内核</p></blockquote><blockquote><p><strong>R系列</strong>：面向<strong>实时应用</strong>的高性能内核</p></blockquote><blockquote><p><strong>M系列</strong>：面向各种<strong>嵌入式</strong>用的<strong>微控制器内核</strong></p></blockquote><p><strong>③基本概念</strong></p><blockquote><p><strong>执行状态</strong>：运行时的<strong>环境</strong>，可分为<code>AArch64</code>和<code>AArch32</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要区别在于寄存器的位宽、支持的指令集、异常模型和内存模型等</div><blockquote><p><strong>指令集</strong>：不同的<strong>执行状态</strong>可执行不同的<strong>指令集</strong>，<code>AArch64</code>状态有<code>A64</code>指令集，<code>AArch32</code>状态有<code>A32</code>和<code>T32</code>指令集</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> A64、A32、T32分别提供64位指令、32位指令、32位和16位指令支持</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> A64和A32是不兼容的，且A64的指令宽度是32位</div><blockquote><p><strong>异常等级</strong>：当前运行的<strong>特权等级</strong>，可分为<code>EL0</code>、<code>EL1</code>、<code>EL2</code>、<code>EL3</code>，其中<code>EL0</code>为<strong>用户特权</strong>，<code>EL1</code>为<strong>系统特权</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> EL2运行虚拟化扩展的虚拟机监控器，EL3运行安全世界的安全监控器</div><h4 id="1-2寄存器"><a href="#1-2寄存器" class="headerlink" title="1.2寄存器"></a>1.2寄存器</h4><p><strong>①通用寄存器</strong></p><blockquote><p><strong>概述</strong>：<code>AArch64</code>支持<strong>31</strong>个通用寄存器<code>X0~X30</code>，可以用<code>Wn</code>表示<strong>n号</strong>通用寄存器<strong>低32位数据</strong></p></blockquote><p><strong>②特殊寄存器</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 仅介绍一些常用的特殊寄存器，其余可自行查询手册</div><blockquote><p><strong>PC指针寄存器</strong>：指向<strong>当前运行指令</strong>的<strong>下一条指令</strong>的地址</p></blockquote><blockquote><p><strong>SP寄存器</strong>：每个<strong>特权等级</strong>对应一个<strong>专门的SP寄存器</strong><code>SP_ELn</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 异常等级高于EL0时，不仅可以访问自己的SP寄存器，还可以访问SP_EL0寄存器，可以将其作为一个临时寄存器</div><blockquote><p><strong>PSTATE寄存器</strong>：用于保存<strong>处理器当前状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如条件标志、执行状态、异常掩码和访问权限</div><blockquote><p><strong>SPSR寄存器</strong>：当出现<strong>中断</strong>时，会将<strong>PSTATE寄存器</strong>中内容保存到<strong>SPSR寄存器</strong>中，<strong>中断返回时</strong>再<strong>写回</strong></p></blockquote><p><strong>③系统寄存器</strong></p><blockquote><p><strong>概述</strong>：通过<strong>访问和设置</strong>系统寄存器完成<strong>处理器功能的配置</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如系统控制、调试、性能监控、定时器等</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不同的异常登记可以访问不同的系统寄存器，大部分系统寄存器在EL0状态无法访问</div><h4 id="1-3实验环境搭建"><a href="#1-3实验环境搭建" class="headerlink" title="1.3实验环境搭建"></a>1.3实验环境搭建</h4><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 体系结构 </tag>
            
            <tag> ARM </tag>
            
            <tag> 精简指令集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp学习笔记（一）</title>
      <link href="/2023/12/10/cpp-xue-xi-bi-ji-yi/"/>
      <url>/2023/12/10/cpp-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Cpp学习笔记"><a href="#Cpp学习笔记" class="headerlink" title="Cpp学习笔记"></a>Cpp学习笔记</h1><h2 id="Cpp学习笔记（一）"><a href="#Cpp学习笔记（一）" class="headerlink" title="Cpp学习笔记（一）"></a>Cpp学习笔记（一）</h2><h3 id="1-Cpp基础编程"><a href="#1-Cpp基础编程" class="headerlink" title="1.Cpp基础编程"></a>1.Cpp基础编程</h3><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> Cpp基础部分和C语言大部分一致，只介绍不同的部分</div><h4 id="1-1命名空间"><a href="#1-1命名空间" class="headerlink" title="1.1命名空间"></a>1.1命名空间</h4><p><strong>①定义</strong></p><blockquote><p><strong>概述</strong>：<strong>每个库</strong>都有其<strong>命名空间</strong>，可以<strong>避免</strong>程序发生<strong>命名冲突</strong>，需要<strong>曝光</strong>或者<strong>解析</strong>才能使用</p></blockquote><p><strong>②曝光</strong></p><blockquote><p><code>using namespace [命名空间];</code>：<strong>曝光</strong>命名空间，通常会采用<code>using namespace std;</code>曝光<strong>标准库</strong>命名空间</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 曝光一命名空间后，若遇到属于该命名空间的对象，如之后的cout和cin，则默认其属于该命名空间</div><blockquote><p>如之后常用的<code>cout</code>和<code>cin</code>，为<strong>标准库</strong>定义的对象，若<strong>标准库没有曝光</strong>，则需要写为<code>std::cout</code>和<code>std::cin</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ::为作用域运算符</div><p><strong>③解析</strong></p><blockquote><p><code>命名空间::变量名</code>：<strong>解析</strong>变量名，指明其<strong>所属命名空间</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当发生命名冲突时，需要解析才能继续执行</div><h4 id="1-2输入输出"><a href="#1-2输入输出" class="headerlink" title="1.2输入输出"></a>1.2输入输出</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要包含iostream头文件，注意标准库头文件不带后缀</div><p><strong>①输出</strong></p><blockquote><p><strong>格式</strong>：<code>[输出对象]&lt;&lt;内容1&lt;&lt;内容2...&lt;&lt;endl;</code>，常用的<strong>输出对象</strong>为<code>cout</code></p></blockquote><blockquote><p><code>cout</code>：<code>iostream</code>类的一个实例，表示<strong>标准输出</strong>，通常连接到<strong>显示屏</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 标准库还定义了两个输出对象cerr和clog，分别为标准错误和标准日志，通常连接到显示屏</div><blockquote><p><code>&lt;&lt;</code>：<strong>输出流运算符</strong>，<strong>左侧</strong>必须是一个<code>ostream</code><strong>对象</strong>，<strong>右侧</strong>是<strong>输出的值</strong>，<strong>计算结果</strong>为<code>ostream</code><strong>对象</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如cout&lt;&lt;内容1的计算结果为cout，这也是可以连续输出到cout的原因</div><blockquote><p><code>endl</code>：输出一个<strong>换行符</strong>，并<strong>清空输出缓冲区</strong></p></blockquote><p><strong>②输入</strong></p><blockquote><p><strong>格式</strong>：<code>[输入对象]&gt;&gt;容器1...&gt;&gt;容器N;</code>，常用的<strong>输入对象</strong>为<code>cin</code>，输入<strong>文件结束符</strong>表示<strong>输入终止</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在Unix系统中，文件结束符可采用ctrl+D输入，windows系统中则是ctrl+z，再输入enter</div><blockquote><p><code>cin</code>：同<code>cout</code>，表示<strong>标准输入</strong>，通常连接到<strong>键盘</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 输入对象还可以是一打开的文件</div><blockquote><p><code>&gt;&gt;</code>：<strong>输入流运算符</strong>，和<code>&lt;&lt;</code>类似，将<strong>标准输入设备的数据</strong>保存到<strong>右边的容器</strong>中</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 同理cin&gt;&gt;容器的返回值也是cin，当读入有效数据，cin状态为真，若遇到文件结束符或无效数据，状态为假</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以采用cin&gt;&gt;tmp作为判断条件，结合条件语句和循环语句使用</div><blockquote><p>如<code>while(cin&gt;&gt;tmp)</code>可以读取<strong>多个数据</strong>，直到<strong>终止</strong>或者<strong>读取数据不合理</strong></p></blockquote><h4 id="1-3引用和指针"><a href="#1-3引用和指针" class="headerlink" title="1.3引用和指针"></a>1.3引用和指针</h4><p><strong>①引用</strong></p><blockquote><p><strong>格式</strong>：<code>[数据类型]&amp; [引用名] = [指向对象]</code>，如<code>int&amp; my_ref = a_int</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 引用相当于指向对象的别名，对引用的任何操作都相当于直接操作指向对象</div><blockquote><p><code>int* my_p = &amp;my_ref</code>是将<strong>指针</strong>指向<code>a_int</code>，<code>const</code>修饰也类似</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 引用必须被初始化（指向一个对象），且不能修改</div><p><strong>②指针</strong></p><blockquote><p><strong>格式</strong>：<code>[数据类型]&amp; [指针名] = &amp;[指向对象]</code>，如<code>int* my_p = &amp;a_int</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 传递指针和引用可以降低复制大型对象的负担</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 对于函数中定义的非静态数据，不能返回其引用和指针</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 指针如果不使用可以初始化为空指针（NULL或0），使用前需要检查其是否为空指针</div><blockquote><p>其中<code>NULL</code>是一个<code>宏</code>，定义如下</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>__cplusplus<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token number">0</span>              </span><span class="token comment">// C++中使用0作为NULL的值</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">define</span> <span class="token macro-name">NULL</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span>    </span><span class="token comment">// C中使用((void *)0)作为NULL的值</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4函数特性"><a href="#1-4函数特性" class="headerlink" title="1.4函数特性"></a>1.4函数特性</h4><p><strong>①默认参数</strong></p><blockquote><p><strong>概述</strong>：<strong>与C语言不同</strong>，C++可以给函数设置<strong>缺省情况</strong>下的<strong>默认参数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只能在函数定义或者函数声明默认值，但是不能在两个地方都声明，通常放在函数声明处</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果为某一参数设定默认值，则该参数右侧所有参数都需要有默认值</div><p><strong>②inline函数</strong></p><blockquote><p><strong>概述</strong>：在<strong>函数定义之前</strong>添加<code>inline</code>关键字即可，通常是一些<strong>简单的函数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对于`inline`函数，编译器在每个函数调用节点上将其展开为函数代码副本（类似于C语言宏函数）</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 内联函数的定义通常放在头文件中（和普通的函数不同，inline函数可以定义多次）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> inline函数只是对编译器的一种的请求，编译器不一定会按照inline函数定义处理</div><p><strong>③函数重载</strong></p><blockquote><p><strong>概述</strong>：<strong>参数列表</strong>或<strong>常量性不同</strong>但是<strong>名称相同</strong>的一系列函数，<strong>编译器</strong>根据<strong>调用时</strong>提供的<strong>参数</strong>判断调用哪一个</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若传入的参数被const修饰，则调用const版本</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不能仅仅依靠返回类型的不同实现函数重载，因为编译器无法根据返回类型判断你想调用那个函数</div><h4 id="1-5动态内存分配"><a href="#1-5动态内存分配" class="headerlink" title="1.5动态内存分配"></a>1.5动态内存分配</h4><p><strong>①引言</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 变量的创建方式，其生命周期不同，以string类为例</div><blockquote><p><code>string s1(1,2)</code>：为<strong>动态变量</strong>，当<strong>作用域结束</strong>后，系统会<strong>自动调用其析构函数</strong>清理</p></blockquote><blockquote><p><code>static string s1(1,2)</code>：其<strong>作用域结束</strong>后，不会被清理，直到<strong>程序结束</strong>，系统才会调用其<strong>析构函数</strong></p></blockquote><blockquote><p><code>string* s = new string</code>：这个变量处于<strong>堆</strong>中，需要<strong>及时delete</strong>掉</p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 若没有及时释放，当其作用域结束，s指向的区域还存在，但是s本身被释放掉了，就没有机会释放对应内存了</div><p><strong>②<code>new</code></strong></p><blockquote><p><strong>格式</strong>：<code>[数据类型]* [指针名] = new [数据类型]</code>/<code>[数据类型]* [指针名] = new [数据类型] [元素数量]</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 分别用于申请一个对象/一个数组的内存，后者会多分配四个字节用于保存数组的大小</div><blockquote><p><strong>工作原理</strong>：调用<code>malloc</code><strong>申请内存</strong>，随后<strong>返回指针</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若数据类型为类，需要调用对应类型的缺省构造函数对内存进行初始化</div><blockquote><p><strong>初始化</strong>：<code>[数据类型]* [指针名] = new [数据类型](初始化参数列表)</code>，</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若为内置类型，则直接使用参数进行每个对象进行赋值，若为类，则调用对应的构造函数对每个对象进行初始化</div><blockquote><p>如<code>int* pc = new int(10);</code>和<code>String* pc = new String("hello");</code></p></blockquote><p><strong>③<code>delete</code></strong></p><blockquote><p><strong>格式</strong>：<code>delete [申请的指针]</code>/<code>delete [] [申请的指针]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 分别用于释放一个对象/一个数组的内存</div><blockquote><p><strong>工作原理</strong>：<strong>释放申请的指针</strong>，若其<strong>指向类</strong>，<strong>在此之前</strong>还需要调用<strong>一次/多次</strong>对应类型的<strong>析构函数</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> delete[]会取出new[]保存的数组大小，并调用对应次数的析构函数</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> new[]需要和delete[]配套使用，否则可能会造成内存泄漏</div><hr><h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①概述</strong></p><blockquote><p>变量指明一个可供程序操控的存储空间，其数据类型决定该内存空间的大小、布局方式以及能参与什么类型的运算等特性</p></blockquote><p>类型说明符 变量名<br>对象指具有某种数据类型的存储空间</p><p>初始化：对象在创建时获得一个特定的值<br>初始化和赋值需要严格区分，赋值是将旧值擦去，用一新值替代</p><p>初始化方法</p><p>int a = 0;<br>int a = {0};<br>int a{0}<br>int a(0)<br>当使用{}进行初始化时，若初始化过程中存在信息丢失的风险，则编译器会报错，如int a{1.1}</p><p>缺省初始化，内置类型，定义在函数体内部的变量不会被初始化，其值为一不确定值，函数体外被初始化为0，减一初始化每一个内置类型的变量</p><p>类对象的初始化由其定义者定义</p><p>声明使得名字为程序所知，一个文件如果想使用别处定义的名字，必须包含对应的声明，类型和名字<br>定义创建了与名字相关联的实体，申请存储空间，赋初始值<br>extern使得一个定义变为声明<br>函数体内部，初始化一个由extern关键字标记的变量会引发错误</p><p>只能定义在同一个文件中<br>编译阶段检查类型</p><p>用户自定义类一般以大写字母开头My_class<br>my_value</p><p>作用域<br>函数之外全局作用域<br>::使用全局变量</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《C++primer》 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp学习笔记（三）</title>
      <link href="/2023/12/10/cpp-xue-xi-bi-ji-san/"/>
      <url>/2023/12/10/cpp-xue-xi-bi-ji-san/</url>
      
        <content type="html"><![CDATA[<h1 id="Cpp学习笔记"><a href="#Cpp学习笔记" class="headerlink" title="Cpp学习笔记"></a>Cpp学习笔记</h1><h2 id="Cpp学习笔记（三）"><a href="#Cpp学习笔记（三）" class="headerlink" title="Cpp学习笔记（三）"></a>Cpp学习笔记（三）</h2><h3 id="1-泛型编程"><a href="#1-泛型编程" class="headerlink" title="1.泛型编程"></a>1.泛型编程</h3><h4 id="1-1引言"><a href="#1-1引言" class="headerlink" title="1.1引言"></a>1.1引言</h4><blockquote><p><strong>概述</strong>：构建一个可以处理<strong>多种容器</strong>以及<strong>多种数据类型</strong>的函数</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 以下为一非泛型查找函数，只能处理整型数组，将其改造为一个泛型算法</div><p><strong>①改造前</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> value<span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> ix <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>ix <span class="token operator">&lt;</span> size<span class="token punctuation">;</span><span class="token operator">++</span>ix<span class="token punctuation">)</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>ix<span class="token punctuation">]</span> <span class="token operator">==</span> value<span class="token punctuation">)</span>          <span class="token keyword">return</span> <span class="token operator">&amp;</span>array<span class="token punctuation">[</span>ix<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②改造后</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">IteratorType</span><span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token class-name">ElemType</span><span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token class-name">Func</span><span class="token operator">&gt;</span>IteratorType<span class="token function">find</span><span class="token punctuation">(</span>IteratorType first<span class="token punctuation">,</span>IteratorType last<span class="token punctuation">,</span><span class="token keyword">const</span> ElemType <span class="token operator">&amp;</span>value<span class="token punctuation">,</span>Func comp<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>first <span class="token operator">!=</span> last<span class="token punctuation">;</span><span class="token operator">++</span>first<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">comp</span><span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//也可以写成</span>    <span class="token keyword">return</span> first<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> last<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//只写与泛型指针相关部分</span>  vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator it<span class="token punctuation">;</span>  it <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>vec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>vec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token function">equal_to</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2函数模板"><a href="#1-2函数模板" class="headerlink" title="1.2函数模板"></a>1.2函数模板</h4><blockquote><p><strong>格式</strong>：在<strong>函数前</strong>添加<code>template</code><strong>参数列表</strong>，将<strong>形参列表</strong>需要<strong>泛化的部分</strong>替换为<strong>占位符</strong>即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 函数被调用时，编译器根据传入的参数类型将占位符绑定为对应类型，并产生一个对应的函数实例</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 函数模板使得函数可以处理不同数据类型的数据，且模板函数可以重载</div><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//函数定义</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">void</span>  <span class="token function">display_message</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>msg<span class="token punctuation">,</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>vec<span class="token punctuation">)</span><span class="token punctuation">{</span>  cout<span class="token operator">&lt;&lt;</span>msg<span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    T t <span class="token operator">=</span> vec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>t<span class="token operator">&lt;&lt;</span><span class="token char">''</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3泛型指针"><a href="#1-3泛型指针" class="headerlink" title="1.3泛型指针"></a>1.3泛型指针</h4><p><strong>①引言</strong></p><blockquote><p><strong>概述</strong>：<strong>泛型指针</strong>本质上是一个<strong>某个类的friend类</strong>，对多种<strong>操作符</strong>进行<strong>重载</strong>，<strong>性质和用法</strong>类似于<strong>指针</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如下为一个数列类以及其泛型指针</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用typedef关键字将iterator_to_special_vector改为统一的iterator</div><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//泛型指针相关联的类</span><span class="token keyword">class</span> <span class="token class-name">special_vector</span><span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">//一些成员函数</span>  <span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">iterator_to_special_vector</span><span class="token punctuation">;</span>  <span class="token keyword">typedef</span> iterator_to_special_vector iterator<span class="token punctuation">;</span>  iterator <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span>_begin_pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  iterator <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">iterator</span><span class="token punctuation">(</span>_begin_pos<span class="token operator">+</span>_len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span><span class="token operator">:</span>      <span class="token keyword">int</span> _begin_pos<span class="token punctuation">;</span>      <span class="token keyword">int</span> _len<span class="token punctuation">;</span>      <span class="token keyword">static</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> _elems<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//泛型指针类定义</span><span class="token keyword">class</span> <span class="token class-name">iterator_to_special_vector</span><span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>      <span class="token function">iterator_to_special_vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_index</span><span class="token punctuation">(</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword">const</span> special_vector<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>      <span class="token comment">//...一系列操作符函数的重载</span>  <span class="token keyword">private</span><span class="token operator">:</span>      <span class="token keyword">int</span> _index<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②格式</strong></p><blockquote><p><code>[类名]::iterator [泛型指针名]</code>：定义了一个<strong>对应类</strong>的泛型指针</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个标准容器都有对应的泛型指针类，且都统一为iterator，需要使用[类名]::限定，并定义了取得泛型指针的函数</div><blockquote><p><code>begin()</code>：返回指向该容器对象<strong>第一个元素</strong>的<code>iterator</code>，如<code>my_vec.begin()</code></p></blockquote><blockquote><p><code>end()</code>：返回指向该容器对象<strong>最后一个元素下一个位置</strong>的<code>iterator</code>，如<code>my_vec.end()</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用模板，使得函数既能接收指针，也能接收泛型指针</div><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Iterator_Type</span><span class="token punctuation">,</span><span class="token keyword">typename</span> <span class="token class-name">Elem_Type</span><span class="token operator">&gt;</span>Iterator_Type<span class="token function">find</span><span class="token punctuation">(</span>Iterator_Type first<span class="token punctuation">,</span>Iterator_Type last<span class="token punctuation">,</span><span class="token keyword">const</span> Elem_Type <span class="token operator">&amp;</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>first<span class="token operator">!=</span>last<span class="token punctuation">;</span><span class="token operator">++</span>first<span class="token punctuation">)</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token operator">!=</span>value<span class="token punctuation">)</span>      <span class="token keyword">return</span> first<span class="token punctuation">;</span>    <span class="token keyword">return</span> last<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-4function-object"><a href="#1-4function-object" class="headerlink" title="1.4function object"></a>1.4function object</h4><p><strong>①引言</strong></p><blockquote><p><strong>概述</strong>：本质上是提供<strong>function call操作符</strong><code>()</code><strong>重载函数</strong>的类的<strong>实例对象</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 遇到lt()时，若lt为一function object（还可能为函数名和函数指针），编译器会将lt(val)转换为lt.operator(val)</div><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">less_than</span><span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment">//构造函数</span>  <span class="token function">less_than</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">_val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//基值的读取与修改</span>  <span class="token keyword">int</span> <span class="token function">comp_val</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> _val<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">comp_val</span><span class="token punctuation">(</span><span class="token keyword">int</span> new_val<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>_val <span class="token operator">=</span> new_val<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">//function call操作符重载</span>  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> val_to_com<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> val_to_com <span class="token operator">&lt;</span> _val<span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">int</span> _val<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②适配器</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 修改function object的特性</div><blockquote><p><code>bind1st()</code>：将<code>function object</code>的<strong>第一个参数</strong>绑定为<strong>特定值</strong>，从而将其转化为<strong>一元操作符</strong></p></blockquote><blockquote><p><code>bind2st()</code>：同上，绑定的是<strong>第二个参数</strong></p></blockquote><blockquote><p><code>not1()</code>：接收一个<strong>一元操作符</strong>，生成一个结果<strong>真伪与原版相反</strong>的<code>function object</code></p></blockquote><blockquote><p><code>not2()</code>：同上，但是接收一个<strong>二元操作符</strong></p></blockquote><p><strong>③标准库function object</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 标准库为以下三类运算符定义了function object，需要包含functional头文件</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常将function object传递泛型算法，从而达到类似于函数指针的效果，且节省了函数调用的开销</div><blockquote><p><strong>算数运算符</strong>：<code>plus&lt;type&gt;</code>（<code>+</code>）等</p></blockquote><blockquote><p><strong>关系运算符</strong>：<code>equal_to&lt;type&gt;</code>（<code>=</code>）等</p></blockquote><blockquote><p><strong>逻辑运算符</strong>：<code>logical_and&lt;type&gt;</code>（<code>&amp;&amp;</code>）等</p></blockquote><hr><h3 id="2-标准容器"><a href="#2-标准容器" class="headerlink" title="2.标准容器"></a>2.标准容器</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①定义</strong></p><blockquote><p><strong>概述</strong>：本质上是<strong>标准库</strong>的<strong>模板类</strong>，使用对应容器需要包含<strong>对应头文件</strong></p></blockquote><p><strong>②统一接口</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个容器都有以下接口的实现</div><blockquote><p><code>empty()</code>：判断容器<strong>是否为空</strong>，是则返回<code>ture</code>，反之<code>false</code></p></blockquote><blockquote><p><code>size()</code>：返回容器的<strong>元素个数</strong></p></blockquote><blockquote><p><code>clear()</code>：<strong>清除</strong>容器<strong>所有元素</strong></p></blockquote><blockquote><p><code>insert()/erase()</code>：<strong>插入/删除</strong>元素</p></blockquote><p><strong>③泛型算法</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要包含functional头文件</div><blockquote><p><code>find()/binary_search()</code>：<strong>线性/二分</strong>查找对应元素</p></blockquote><blockquote><p><code>count()</code>：返回与数值相符的<strong>元素数目</strong></p></blockquote><blockquote><p><code>search()</code>：查找<strong>子序列</strong>，返回其<strong>起始位置的泛型指针</strong></p></blockquote><blockquote><p><code>sort()</code>：<strong>排序</strong>，<strong>缺省情况</strong>下为<strong>升序排列</strong>，可以传入<code>function object</code>修改</p></blockquote><blockquote><p><code>copy()</code>：<strong>复制</strong>一个容器内容</p></blockquote><h4 id="2-2动态数组"><a href="#2-2动态数组" class="headerlink" title="2.2动态数组"></a>2.2动态数组</h4><p><strong>①定义</strong></p><blockquote><p><strong>格式</strong>：<code>vector&lt;数据类型&gt; 动态数组名(元素个数)</code>，同<strong>C语言数组</strong>采用<strong>下标</strong>访问即可，从<code>0</code>开始</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不同于数组，动态数组的个数可以为0，也可以不是一个常量</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若数据类型为动态数组，则需要注意写法，符号序列总是按照合法序列最长的解释</div><blockquote><p>如<strong>数据类型</strong>为一<strong>动态数组</strong>，需要<strong>声明</strong>为<code>vector&lt;vector&lt;int&gt; &gt;</code>，不能写为<code>vector&lt;vector&lt;int&gt;&gt;</code></p></blockquote><p><strong>②初始化</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以int类型vector为例</div><blockquote><p><code>vector&lt;int&gt; my_vec</code>：构建一个<strong>空的</strong><code>vector</code></p></blockquote><blockquote><p><code>vector&lt;int&gt; my_vec(10)</code>：<code>vector</code><strong>元素个数</strong>为<code>10</code>，且<strong>所有元素</strong>被<strong>初始化</strong>为<code>0</code></p></blockquote><blockquote><p><code>vector&lt;int&gt; my_vec(10，10)</code>：<code>vector</code><strong>元素个数</strong>为<code>10</code>，且<strong>所有元素</strong>被<strong>初始化</strong>为<code>10</code></p></blockquote><blockquote><p><code>vector&lt;int&gt; my_vec(first，last)</code>：使用<strong>一对泛型指针/指针</strong>给其赋值</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 常常使用数组对其进行复制，如vector<int> my_vec(nums，nums+num_size)</int></div><blockquote><p><code>vector&lt;int&gt; my_vec(my_vec2)</code>/<code>vector&lt;int&gt; my_vec = my_vec2</code>：<strong>复制一份</strong>传入的动态数组</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 同样还可以通过my_vec == my_vec2/my_vec != my_vec2判断两者是否相同</div><p><strong>③常用方法</strong></p><blockquote><p><code>push_back()</code>：在<strong>末端插入</strong>元素</p></blockquote><blockquote><p><code>pop_back()</code>：<strong>删除</strong>末端元素</p></blockquote><h4 id="2-3线性容器"><a href="#2-3线性容器" class="headerlink" title="2.3线性容器"></a>2.3线性容器</h4><p><strong>①栈</strong></p><blockquote><p><strong>定义</strong>：<code>stack&lt;type&gt; [栈名]</code>，创建一个<strong>空栈</strong>，如<code>stack&lt;int&gt; my_stack</code></p></blockquote><blockquote><p><code>pop/push()</code>：元素<strong>出/入栈</strong>，如<code>my_stack.push(1)</code>/<code>int val = my_stack.pop();</code></p></blockquote><blockquote><p><code>top()</code>：<strong>访问</strong>栈顶元素，如<code>int top = my_stack.top();</code></p></blockquote><p><strong>②队列</strong></p><blockquote><p><strong>定义</strong>：<code>queue&lt;type&gt; [栈名]</code>，创建一个<strong>空队列</strong>，如<code>queue&lt;int&gt; my_queue</code></p></blockquote><blockquote><p><code>pop/push()</code>：元素<strong>出/入队</strong>，如<code>my_queue.push(1)</code>/<code>int val = my_queue.pop();</code></p></blockquote><blockquote><p><code>front()</code>：访问<strong>队首元素</strong>，如<code>int front = my_queue.front();</code></p></blockquote><p><strong>③双向队列</strong></p><blockquote><p><strong>定义</strong>：<code>deque&lt;type&gt; [双向队列名]</code>，创建一个<strong>空双向队列</strong>，如<code>deuqe&lt;int&gt; my_deque</code></p></blockquote><blockquote><p><code>push_back/push_front()</code>：将元素<strong>添加</strong>至<strong>队尾/队首</strong>，如<code>my_deque.push_back(1)</code></p></blockquote><blockquote><p><code>pop_back/pop_front()</code>：将<strong>队尾/队首</strong>元素<strong>弹出</strong>，如<code>my_deque.pop_back(1)</code></p></blockquote><blockquote><p><code>front/back()</code>：<strong>访问队首/尾</strong>元素，如<code>int front = my_deque.front();</code></p></blockquote><hr><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 《C++ primer》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cmake应用（二）</title>
      <link href="/2023/12/10/cmake-ying-yong-er/"/>
      <url>/2023/12/10/cmake-ying-yong-er/</url>
      
        <content type="html"><![CDATA[<h1 id="Cmake"><a href="#Cmake" class="headerlink" title="Cmake"></a>Cmake</h1><h2 id="Cmake应用（二）"><a href="#Cmake应用（二）" class="headerlink" title="Cmake应用（二）"></a>Cmake应用（二）</h2><h3 id="1-嵌套Cmake"><a href="#1-嵌套Cmake" class="headerlink" title="1.嵌套Cmake"></a>1.嵌套Cmake</h3><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当项目有多个源代码目录时，给每个源码目录都添加一个CMakeLists.txt文件，便于管理</div><h4 id="1-1引言"><a href="#1-1引言" class="headerlink" title="1.1引言"></a>1.1引言</h4><blockquote><p>进行<strong>模块化测试</strong>，将<code>calc</code>和<code>sort</code>中的源代码打包成<strong>库</strong>，并分别给<strong>对应测试文件</strong>调用</p></blockquote><pre class="line-numbers language-none"><code class="language-none">$ tree.├── build├── calc              #计算库│&nbsp;&nbsp; ├── add.cpp│&nbsp;&nbsp; ├── CMakeLists.txt│&nbsp;&nbsp; ├── div.cpp│&nbsp;&nbsp; ├── mult.cpp│&nbsp;&nbsp; └── sub.cpp├── CMakeLists.txt├── include           #头文件目录│&nbsp;&nbsp; ├── calc.h│&nbsp;&nbsp; └── sort.h├── sort              #排序库│&nbsp;&nbsp; ├── CMakeLists.txt│&nbsp;&nbsp; ├── insert.cpp│&nbsp;&nbsp; └── select.cpp├── test1             #测试计算库│&nbsp;&nbsp; ├── calc.cpp│&nbsp;&nbsp; └── CMakeLists.txt└── test2             #测试排序    ├── CMakeLists.txt    └── sort.cpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2建立联系"><a href="#1-2建立联系" class="headerlink" title="1.2建立联系"></a>1.2建立联系</h4><p><strong>①节点关系</strong></p><blockquote><p><code>CMakeLists</code>文件关系是<strong>树状结构关系</strong>（因为<strong>文件/目录之间的关系</strong>也是树状结构关系）</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 父节点定义的变量也可以在子节点中使用，子节点定义的变量只能在当前节点使用</div><p><strong>②<code>add_subdirectory</code></strong></p><blockquote><p><strong>建立父子节点关系</strong><br><strong>格式</strong>：<code>add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</code></p></blockquote><blockquote><p><code>source_dir</code>：指定<strong>子目录</strong><br><code>binary_dir</code>：指定了<strong>子目录输出文件的路径</strong>，一般<strong>不需要指定</strong><br><code>EXCLUDE_FROM_ALL</code>：当指定该参数时，父目录的<code>CMakeLists.txt</code>不会构建子目录的目标文件，必须在<strong>子目录下显式去构建</strong>，除非<strong>父目录的目标文件依赖于子目录的目标文件</strong></p></blockquote><h4 id="1-3CmakeLists文件"><a href="#1-3CmakeLists文件" class="headerlink" title="1.3CmakeLists文件"></a>1.3CmakeLists文件</h4><p><strong>①根目录</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 根目录主要的功能是定义全局变量和添加子目录</div><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.0)project(test)# 定义变量# 静态库生成的路径set(LIB_PATH ${CMAKE_CURRENT_SOURCE_DIR}/lib)# 测试程序生成的路径set(EXEC_PATH ${CMAKE_CURRENT_SOURCE_DIR}/bin)# 头文件目录set(HEAD_PATH ${CMAKE_CURRENT_SOURCE_DIR}/include)# 静态库的名字set(CALC_LIB calc)set(SORT_LIB sort)# 可执行程序的名字set(APP_NAME_1 test1)set(APP_NAME_2 test2)# 添加子目录add_subdirectory(calc)add_subdirectory(sort)add_subdirectory(test1)add_subdirectory(test2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②calc目录</strong></p><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.0)project(CALCLIB)#搜索当前目录（calc目录）下的所有源文件aux_source_directory(./ SRC)#包含头文件路径，HEAD_PATH是在根节点文件中定义的include_directories(${HEAD_PATH})#设置库的生成的路径，LIB_PATH是在根节点文件中定义的set(LIBRARY_OUTPUT_PATH ${LIB_PATH})#生成静态库，静态库名字CALC_LIB是在根节点文件中定义的add_library(${CALC_LIB} STATIC ${SRC})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③sort目录</strong></p><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.0)project(SORTLIB)aux_source_directory(./ SRC)include_directories(${HEAD_PATH})set(LIBRARY_OUTPUT_PATH ${LIB_PATH})#生成动态库，动态库名字SORT_LIB是在根节点文件中定义的add_library(${SORT_LIB} SHARED ${SRC})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④test1目录</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当程序某个模块中生成库且在对应CmakeLists文件中指定了库的输出路径，其他模块不需要指定其路径</div><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.0)project(CALCTEST)aux_source_directory(./ SRC)#指定头文件路径，HEAD_PATH变量是在根节点文件中定义的include_directories(${HEAD_PATH})link_directories(${LIB_PATH})#指定可执行程序要链接的静态库，CALC_LIB变量是在根节点文件中定义的link_libraries(${CALC_LIB})#指定可执行程序生成的路径，EXEC_PATH变量是在根节点文件中定义的set(EXECUTABLE_OUTPUT_PATH ${EXEC_PATH})#生成可执行程序，APP_NAME_1变量是在根节点文件中定义的add_executable(${APP_NAME_1} ${SRC})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>⑤test2目录</strong></p><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.0)project(SORTTEST)aux_source_directory(./ SRC)include_directories(${HEAD_PATH})set(EXECUTABLE_OUTPUT_PATH ${EXEC_PATH})link_directories(${LIB_PATH})add_executable(${APP_NAME_2} ${SRC})target_link_libraries(${APP_NAME_2} ${SORT_LIB})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>⑥结果</strong></p><blockquote><p>进入到<strong>根节点目录</strong>的<code>build</code><strong>目录</strong>中，执行<code>cmake</code>和<code>make</code>命令，在项目<strong>根目录</strong>的<code>lib</code><strong>目录</strong>中生成了<strong>静态库</strong><code>libcalc.a</code>和<strong>动态库</strong><code>libsort.so</code>，并在项目<strong>根目录</strong>的<code>bin</code><strong>目录</strong>生成了<strong>可执行程序</strong><code>test1</code>和<code>test2</code></p></blockquote><h3 id="2-流程控制"><a href="#2-流程控制" class="headerlink" title="2.流程控制"></a>2.流程控制</h3><h4 id="2-1条件判断"><a href="#2-1条件判断" class="headerlink" title="2.1条件判断"></a>2.1条件判断</h4><p><strong>①<code>if</code>语句</strong></p><pre class="line-numbers language-none"><code class="language-none">if(&lt;condition&gt;)  &lt;commands&gt;elseif(&lt;condition&gt;)  #可选块，可重复  &lt;commands&gt;else()               #可选块  &lt;commands&gt;endif()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②<code>condition</code></strong></p><blockquote><p><code>condition</code>的值为<code>1</code>, <code>ON</code>, <code>YES</code>, <code>TRUE</code>, <code>Y,</code> <strong>非零值</strong>，<strong>非空字符串</strong>时，条件判断返回<code>True</code><br><code>condition</code>的值为<code>0</code>，<code>OFF</code>，<code>NO</code>，<code>FALSE</code>，<code>N</code>，<code>IGNORE</code>，<code>NOTFOUND</code>，<strong>空字符串</strong>时，条件判断返回<code>False</code></p></blockquote><p><strong>③相关操作符</strong></p><blockquote><p><strong>逻辑操作</strong>：<code>NOT</code>（非）、<code>AND</code>（与）、<code>OR</code>（或）</p></blockquote><blockquote><p><strong>数值比较</strong>：<code>LESS</code>（小于）、<code>GREATER</code>（大于）、<code>EQUAL</code>（等于）、<code>LESS_EQUAL</code>（小于等于）、<code>GREATER_EQUAL</code>（大于等于）</p></blockquote><blockquote><p><strong>字符串比较</strong>：<strong>同上</strong>，但是需要加上<code>STR</code><strong>前缀</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> CMake还提供了其他判断语句，如if(EXISTS path-to-file-or-directory)则是判断文件或者目录是否存在</div><h4 id="2-2循环语句"><a href="#2-2循环语句" class="headerlink" title="2.2循环语句"></a>2.2循环语句</h4><p><strong>①while循环</strong></p><blockquote><p>当<code>condition</code>为<code>False</code>时结束</p></blockquote><pre class="line-numbers language-none"><code class="language-none">while(&lt;condition&gt;)    &lt;commands&gt;endwhile()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>②<code>foreach</code>循环1</strong></p><blockquote><p><code>foreach(&lt;loop_var&gt; RANGE &lt;stop&gt;)</code><br><code>loop_var</code>：<strong>存储每次循环取出的值</strong><br><code>RANGE</code>：关键字，表示<strong>要遍历范围</strong><br><code>stop</code>：这是一个正整数，表示<strong>范围的结束值</strong>，即遍历范围为<code>[0,stop]</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.2)project(test)# 循环foreach(item RANGE 10)    message(STATUS "当前遍历的值为: ${item}" )endforeach()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③<code>foreach</code>循环2</strong></p><blockquote><p><code>foreach(&lt;loop_var&gt; RANGE &lt;start&gt; &lt;stop&gt; [&lt;step&gt;])</code><br><code>start</code>：表示范围的<strong>起始值</strong><br><code>stop</code>：表示范围的<strong>结束值</strong><br><code>step</code>：循环的<strong>步长</strong>，<strong>默认为1</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.2)project(test)foreach(item RANGE 10 30 2)    message(STATUS "当前遍历的值为: ${item}" )endforeach()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④<code>foreach</code>循环3</strong></p><blockquote><p><code>foreach(&lt;loop_var&gt; IN [LISTS [&lt;lists&gt;]] [ITEMS [&lt;items&gt;]])</code><br><code>IN</code>：关键字，对应<code>RANGE</code><br><code>LISTS</code>：关键字，对应的是列表<br><code>ITEMS</code>：关键字，对应的也是列表，但是需要通过<code>${}</code><strong>将列表中的值取出</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> LISTS关键字和ITEMS至少要存在一个，也可以同时存在，每个后面可以接多个对象</div><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.2)project(test)# 创建 listset(WORD a b c d)set(NAME ace sabo luffy)# 遍历 listforeach(item IN LISTS WORD ITEMS ${NAME})    message(STATUS "当前遍历的值为: ${item}" )endforeach()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>⑤<code>foreach</code>循环4</strong></p><blockquote><p><code>foreach(&lt;loop_var&gt;... IN ZIP_LISTS &lt;lists&gt;)</code><br><code>ZIP_LISTS</code>：关键字</p></blockquote><blockquote><p><strong><code>&lt;loop_var&gt;...</code></strong><br>如果指定了<strong>多个变量名</strong>，则<strong>变量的数量</strong>应该和<strong>列表数</strong>相等<br>若<strong>只给出一个</strong><code>loop_var</code>，则他会<strong>自动创建出对应数量</strong>的<code>loop_var_0</code>到<code>loop_var_N</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该循环同时对所有列表进行循环，每次循环各个列表对应的值存储在这些变量中</div><pre class="line-numbers language-none"><code class="language-none">cmake_minimum_required(VERSION 3.17)project(test)# 通过list给列表添加数据list(APPEND WORD hello world "hello world")list(APPEND NAME ace sabo luffy zoro sanji)# 遍历列表foreach(item1 item2 IN ZIP_LISTS WORD NAME)    message(STATUS "当前遍历的值为: item1 = ${item1}, item2=${item2}" )endforeach()message("=============================")# 遍历列表foreach(item  IN ZIP_LISTS WORD NAME)    message(STATUS "当前遍历的值为: item1 = ${item_0}, item2=${item_1}" )endforeach()#[[输出结果如下-- 当前遍历的值为: item1 = hello, item2=ace-- 当前遍历的值为: item1 = world, item2=sabo-- 当前遍历的值为: item1 = hello world, item2=luffy-- 当前遍历的值为: item1 = , item2=zoro-- 当前遍历的值为: item1 = , item2=sanji=============================-- 当前遍历的值为: item1 = hello, item2=ace-- 当前遍历的值为: item1 = world, item2=sabo-- 当前遍历的值为: item1 = hello world, item2=luffy-- 当前遍历的值为: item1 = , item2=zoro-- 当前遍历的值为: item1 = , item2=sanji]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 工具链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码工具 </tag>
            
            <tag> Cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记（三）</title>
      <link href="/2023/12/10/c-yu-yan-xue-xi-bi-ji-san/"/>
      <url>/2023/12/10/c-yu-yan-xue-xi-bi-ji-san/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言学习笔记（三）"><a href="#C语言学习笔记（三）" class="headerlink" title="C语言学习笔记（三）"></a>C语言学习笔记（三）</h1><h2 id="C语言进阶"><a href="#C语言进阶" class="headerlink" title="C语言进阶"></a>C语言进阶</h2><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.预处理"></a>1.预处理</h3><h4 id="1-1引言"><a href="#1-1引言" class="headerlink" title="1.1引言"></a>1.1引言</h4><p><strong>①概述</strong></p><blockquote><p>在源代码<strong>编译前</strong>对其进行一些<strong>文本性质</strong>操作</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如删除注释，处理预处理命令</div><p><strong>②预定义符号</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 预处理器定义的符号，都有各自对应的含义</div><blockquote><p><code>__FILE__</code>：进行编译的<strong>源文件名</strong></p></blockquote><blockquote><p><code>__LINE__</code>：文件当前行的<strong>行号</strong></p></blockquote><blockquote><p><code>__DATE__</code>：文件<strong>被编译的日期</strong></p></blockquote><blockquote><p><code>__TIME__</code>：文件<strong>被编译的时间</strong></p></blockquote><blockquote><p><code>__STDC__</code>：若<strong>编译器</strong>遵循<code>ANSI C</code>，返回1</p></blockquote><p><strong>③常用预处理命令</strong></p><blockquote><p><code>#define name stuff</code>：将<strong>其后</strong>的<code>name</code><strong>替换</strong>为<code>stuff</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> name全部大写，与普通变量相区分，若stuff太长，可以将其分为几行，除最后一行每行末尾添加一个反斜杠/</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用宏定义类型，只需要修改宏的值就可改变类型</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> stuff末尾不应该包含分号，否则可能会多出一条空语句</div><blockquote><p><code>#error message</code>：生成<strong>错误信息</strong>，其中<code>message</code>为<strong>错误提示信息</strong></p></blockquote><blockquote><p><code>#line number "strings"</code>：定义<strong>下一行行号</strong><code>number</code>，文件名<code>"strings"</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> "strings"为可选选项，且该命令会修改__LINE__和__FILE__</div><blockquote><p><code>#progma</code>：用于支持<strong>因编译器而异</strong>的特性，如向一个函数插入<strong>内联的汇编代码</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 预处理器会忽略它不认识的#progma指令</div><blockquote><p><code>#undef name</code>：移除<strong>宏定义</strong></p></blockquote><h4 id="1-2宏"><a href="#1-2宏" class="headerlink" title="1.2宏"></a>1.2宏</h4><p><strong>①引言</strong></p><blockquote><p><strong>格式</strong>：<code>#define name(parameter-list) stuff</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> parameter-list为参数列表，参数之间用逗号,相隔，类似于函数的形参，stuff为包含参数列表中参数的表达式</div><p>#name会被预处理器处理为”name”，a##b会被预处理器处理为ab<br><strong>②实例</strong></p><blockquote><p>定义宏<code>#define SQUARE(x) ((x) * (x))</code>，在<strong>代码块</strong>中输入<code>SQUARE(a)</code>，在<strong>预处理阶段</strong>会被替换为<code>((5) * (5))</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 宏中可以出现其他宏定义的符号，但是不能包含自身</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 宏本质上还是简单的替换操作，所以要避免其与正文中的其他操作符发生预料之外的作用</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以像上述一样采用()对每个参数和整体进行隔离</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> name和(parameter-list)之间不能有空格</div><p><strong>③带副作用的宏参数</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当宏参数在宏定义中出现不止一次时，若宏参数具有副作用，可能会带来无法预料的后果</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 副作用指永久性的效果，如x+1和x++，后者会永久改变x的值</div><blockquote><p><strong>以下程序</strong>运行后结果<code>x = 6,y = 10,z = 9</code>，这是因为<code>z = MAX(x++,y++)</code>被替换为<code>z = ((x++)&gt;(y++)?(x++):(y++))</code>，其中<code>y++</code><strong>执行了两次</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#define MAX(a,b) ((a)&gt;(b)?(a):(b))x=5;y=8;z = MAX(x++,y++);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了避免这种情况，可以将宏需要使用的数据存储到临时变量中</div><p><strong>④命令行控制宏</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在命令行编译时添加编译选项对宏进行定义和修改</div><blockquote><p>如<code>cc -DARRAY_SIZE=100 prog.c</code>，则就是将<code>ARRAY_SIZE</code><strong>修改</strong>为<code>100</code></p></blockquote><blockquote><p>其他的选项还有<code>-Uname</code>（<strong>忽略宏</strong><code>name</code>）以及<code>-Dname</code>（<strong>定义宏</strong><code>name</code>）</p></blockquote><p><strong>⑥宏的利与弊</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 宏比较适用于频繁使用的小型简单代码，因为函数的调用和返回也需要开支</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 宏是与类型无关的，有些参数无法传递给函数，比如说传递参数的类型</div><blockquote><p>如<code>#define MALLOC(n,type) ((type*)malloc((n)*sizeof(type)))</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 宏会使得代码变得更长，因为宏的本质就是插入代码副本</div><h4 id="1-3条件编译"><a href="#1-3条件编译" class="headerlink" title="1.3条件编译"></a>1.3条件编译</h4><p><strong>①定义</strong></p><blockquote><p>选择<strong>一部分代码</strong>在编译时是被<strong>正常编译</strong>还是被<strong>忽略</strong></p></blockquote><p><strong>②格式</strong></p><blockquote><p><code>constant-expression</code>：为<strong>常量表达式</strong>，当其为<strong>非零值</strong>时，<code>statement</code>被<strong>正常编译</strong>，反之则被<strong>忽略</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 常常为宏，并和命令行控制宏一同使用</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> elif、else子句出现的次数可以不限，只有当其前面所有常量表达式均为假，且自身常量表达式为真，才被正常编译</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 记住要以#endif结束条件编译</div><pre class="line-numbers language-none"><code class="language-none">#if constant-expression  statement0#elif constant-expression  statement1#else  statement2#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③定义判断</strong></p><blockquote><p><code>#if defined(symbol)</code>、<code>#ifdef symbol</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若symbol被定义则为真</div><blockquote><p><code>#if !defined(symbol)</code>、<code>#ifndef symbol</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若symbol没有被定义则为真</div><h4 id="1-4文件包含"><a href="#1-4文件包含" class="headerlink" title="1.4文件包含"></a>1.4文件包含</h4><p><strong>①格式</strong></p><blockquote><p><code>#include &lt;filename&gt;</code>/<code>#include "filename"</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 前者表示在编译器定义的标准位置寻找相关文件，后者表示优先在源文件所在目录寻找相关文件，没有再去标准位置</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> include的实质就是将对应文件内容复制到对应位置</div><p><strong>②嵌套包含</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 有些头文件中还会包含其他的头文件，可能会导致某些头文件被包含多次</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以使用条件编译避免这种情况</div><blockquote><p>如下，<code>_TOUWENJIAN_H</code>为这个<strong>头文件的代号</strong>，当头文件被<strong>第一次被包含</strong>时，其被<strong>定义</strong>为<code>1</code>，<strong>第二次被包含</strong>时，通过<strong>条件编译</strong>，<strong>忽略</strong>其内容</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#ifndef _TOUWENJIAN_H#define _TOUWENJIAN_H 1    All the stuff that you want in the header file#endif <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 应该避免多重包含，因为上述做法只能忽略重复读入内容，该文件还是会被多次读取</div><h4 id="1-5命令行参数"><a href="#1-5命令行参数" class="headerlink" title="1.5命令行参数"></a>1.5命令行参数</h4><blockquote><p><code>main</code><strong>函数</strong>有<strong>两个形参</strong>用于接收<strong>命令行参数</strong>，<code>int main (int argc,char **argv)</code></p></blockquote><blockquote><p><code>argc</code>：命令行参数的<strong>数目</strong></p></blockquote><blockquote><p><code>argv</code>：本质上是一个<strong>指向字符指针的指针</strong>，将<strong>命令行参数</strong>看作为一个<strong>字符指针数组(以空指针结尾)<strong>，该参数指向该数组的</strong>第一个参数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 命令行第一个参数固定是程序的名称，不需要用户输入</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意命令行参数是字符数组，在C中，没有字符串</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/C_5.png" alt="命令行参数"></p><hr><h3 id="2-I-x2F-O函数"><a href="#2-I-x2F-O函数" class="headerlink" title="2.I/O函数"></a>2.I/O函数</h3><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 包含stdio.h头文件</div><h4 id="2-1基本概念"><a href="#2-1基本概念" class="headerlink" title="2.1基本概念"></a>2.1基本概念</h4><p><strong>①流</strong></p><blockquote><p><strong>定义</strong>：<strong>I/O操作</strong>就是从程序<strong>移进或移出字节</strong>，这个<strong>字节流</strong>称为<strong>流</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 流本质上是一个指向FILE数据结构的指针，每个流都有一个相应的FILE文件与它关联</div><blockquote><p><strong>标准流</strong>：<strong>标准输入</strong><code>stdin</code>，<strong>标准输出</strong><code>stdout</code>和<strong>标准错误</strong><code>stderr</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通常标准输入设备为键盘，标准输出/错误设备为终端或者屏幕</div><blockquote><p><strong>文本流</strong>：零个或者多个<strong>字符</strong>，以<strong>换行符</strong>结束（<strong>UNIX系统</strong>）</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 文本流的结束形式在不同的系统上可能不同，但是库函数会将标准形式（换行符）转化为对应的形式</div><blockquote><p><strong>二进制流</strong>：完全根据<strong>程序编写它们的形式</strong>输入/出</p></blockquote><p><strong>②缓冲区</strong></p><blockquote><p><strong>定义</strong>：<strong>流</strong>并不是<strong>直接</strong>从<strong>输入端</strong>到<strong>输出端</strong>，而是要<strong>经过</strong>一块称为<strong>缓冲区</strong>的<strong>内存区域</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 缺省情况下，I/O函数库为流动态分配一个缓冲区</div><blockquote><p><strong>输出缓冲区</strong>：在<strong>被写满</strong>的时候才会被<strong>写入（刷新）</strong>到<strong>设备</strong>或者<strong>文件</strong>中</p></blockquote><blockquote><p><strong>输入缓冲区</strong>：同理，输入缓冲区<strong>为空时</strong>才会从<strong>设备</strong>或<strong>文件</strong>中<strong>读取数据</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 上述的缓冲为完全缓冲，但是通常情况下，流的缓冲状态由编译器决定，通常是请求输入的同时刷新输出缓冲区</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以使用int fflush(FILE *stream)使输出缓冲区立即刷新</div><p><strong>③标准I/O常量</strong></p><blockquote><p><code>EOF</code>：<strong>提示</strong>到达了<strong>文件末尾</strong>，所选择的实际值<strong>比一个字符要多几位</strong></p></blockquote><blockquote><p><code>FOPEN_MAX</code>：一个程序<strong>最多</strong>能<strong>打开文件的数量</strong>，<strong>至少是8</strong>（包括<strong>三个标准流</strong>）</p></blockquote><blockquote><p><code>FILENAME_MAX</code>：<strong>合法文件名</strong>的<strong>最大长度</strong></p></blockquote><p><strong>④临时文件</strong></p><blockquote><p><strong>定义</strong>：使用一个文件<strong>临时保存数据</strong>，当<strong>程序结束</strong>时，该文件就被<strong>删除</strong></p></blockquote><blockquote><p><code>FILE *tmpfile(void)</code>：创建了一个<strong>临时文件</strong>，以<code>"wb+"</code>模式打开，当<strong>文件被关闭或程序终止</strong>时，文件便被<strong>删除</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若该文件需要需以其他模式打开，或者需要由一个程序打开，由另一个程序读取，都不适用临时文件</div><blockquote><p><code>char *tmpnam(char *name)</code>：给临时文件<strong>命名</strong>，参数需是一个指向<strong>长度至少</strong>为<code>L_tmpnam</code>的<strong>字符数组的指针</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若参数为NULL，函数返回一个静态数组的指针，该数组包含了文件名</div><p><strong>⑤错误报告</strong></p><blockquote><p><code>void perror(char const *message)</code>：若<code>message</code>不为<code>NULL</code>，则该函数<strong>打印出这个字符串</strong>，后面跟<strong>一个分号</strong>和<strong>一个空格</strong>，并打印出<strong>当前errno</strong>以及<strong>对应的信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> errno位错误代码，定义在errno.h头文件中</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 只有当库函数失败时才会刷新errno，故需要在一些可能出错的地方判断错误是否发生，再调用该函数提示错误信息</div><h4 id="2-2流的操控"><a href="#2-2流的操控" class="headerlink" title="2.2流的操控"></a>2.2流的操控</h4><p><strong>①创建流</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 调用fopen函数创建一个流，指定访问的文件/设备以及他们的访问方式，并初始化FILE结构</div><blockquote><p><strong>函数原型</strong>：<code>FILE *fopen(char const *name,char const *mode);</code></p></blockquote><blockquote><p>其中<code>name</code>是<strong>希望打开</strong>的<strong>设备和文件的名字</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 时刻检查fopen的返回值，若为空则表示没有创建成功</div><blockquote><p><code>mode</code>提示<strong>流</strong>的<strong>操作模式</strong>以及<strong>分类</strong></p></blockquote><blockquote><p><strong>文本流</strong>：<code>"r"</code><strong>只读</strong> 、<code>"w"</code><strong>只写</strong>、<code>"a"</code><strong>添加</strong></p></blockquote><blockquote><p><strong>二进制流</strong>：<code>"rb"</code><strong>只读</strong>、<code>"wb"</code><strong>只写</strong>、<code>"ab"</code><strong>添加</strong></p></blockquote><p><strong>②操作模式</strong></p><blockquote><p><strong>读</strong>：访问文件<strong>必须已经存在</strong></p></blockquote><blockquote><p><strong>写</strong>：访问文件<strong>存在</strong>，<strong>原来的内容就会被删除</strong>，若<strong>不存</strong>在，则会<strong>新创建一个</strong></p></blockquote><blockquote><p><strong>添加</strong>：类似于写，但是<strong>不会覆盖内容</strong>，而是在<strong>尾部</strong>写入<strong>新内容</strong></p></blockquote><p><strong>②重新打开一个流</strong></p><blockquote><p><code>FILE *freopen(char const *filename,char const *mode,FILE *stream)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该函数试图关闭stream对应的流，并重新打开它</div><p><strong>④流的位置控制</strong></p><blockquote><p><code>long ftell(FILE *stream)</code>：返回<strong>下一个读写将要开始位置</strong>距离<strong>文件起始位置</strong>的偏移量</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对于二进制流，这个偏移量为字节数，对于文本流，这个值取决于系统（由于行末字符映射）</div><blockquote><p><code>int fseek(FILE *stream,long offset,int from)</code>：改变<strong>下一次读写的起始位置</strong>，由<code>from</code>和<code>offset</code>决定</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> from参数有三种值</div><blockquote><p><code>SEEK_SET</code>：从流的<strong>起始位置</strong>起<code>offset</code>个字节，<code>offset</code>必须是一个<strong>非负值</strong></p></blockquote><blockquote><p><code>SEEK_CUR</code>：从流的<strong>当前位置</strong>起<code>offset</code>个字节，<code>offset</code><strong>可正可负</strong></p></blockquote><blockquote><p><code>SEEK_END</code>：从流的<strong>尾部位置</strong>起<code>offset</code>个字节，<code>offset</code><strong>可正可负</strong>，当其为<strong>正数</strong>时，<strong>写入</strong>将<strong>扩展这个文件</strong>，<strong>读取</strong>将获得一条<strong>到达文件尾的信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 为了其可移植性，from为SEEK_END或者SEEK_CUR时，offset需为0，from为SEEK_SET时，offset需为同一个流中之前调用ftell获得的返回值</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 二进制流中，SEEK_END定位可能不被支持</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 调用fseek之后，行末指示字符将会被清除</div><p><strong>⑤改变缓冲方式</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只有当指定流被打开但是还没有对其进行操作时，才能调用这些函数</div><blockquote><p><code>void setbuf(FILE *stream,char *buf)</code>：为<strong>流</strong>设置了<strong>一个数组</strong>作为其<strong>缓冲区</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若数组指针为空，则关闭流的所有缓冲方式，按照程序规定的方式读取写入（操作系统有自己的缓冲方式）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 该数组长度必须为BUFSIZ，定义在stdio.h中</div><blockquote><p><code>int setvbuf(FILE *stream,char *buf,int mode,size_t size)</code>：其中，<code>mode</code>用于指定<strong>缓冲的类型</strong>，<code>buf</code>用于指向<strong>缓冲区</strong>，<code>size</code>用于指定<strong>缓冲区大小</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> mode的参数类型有三种</div><blockquote><p><code>_IOFBF</code>：<strong>完全缓冲</strong></p></blockquote><blockquote><p><code>_IONBF</code>：<strong>不缓冲</strong></p></blockquote><blockquote><p><code>_IOLBF</code>：<strong>行缓冲</strong>，即每当<strong>换行符被写入缓冲区</strong>时，缓冲区便<strong>刷新</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 缓冲区的大小最好是BUFSIZ的整数倍（与磁盘簇大小相匹配），否则可能会需要一些额外的磁盘操作</div><p><strong>⑥状态判断</strong></p><blockquote><p><code>int feof(FILE *stream)</code>：若流处于<strong>文件尾</strong>，则返回真</p></blockquote><blockquote><p><code>int ferror(FILE *stream)</code>：若流出现<strong>读写错误</strong>，函数返回真</p></blockquote><blockquote><p><code>int clearerr(FILE *stream)</code>：<strong>重置</strong>流的错误状态</p></blockquote><p><strong>⑦关闭流</strong></p><blockquote><p><code>int fclose(FILE *f);</code>：调用<code>fclose</code><strong>关闭对应流</strong>，并<strong>释放</strong><code>FILE</code>文件。如果<strong>执行成功</strong>，返回<strong>零值</strong>，<strong>否则</strong>返回<code>EOF</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如果关闭的是输出流，那么这个函数还会刷新缓冲区</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 及时释放流，防止流对应的文件被访问修改</div><h4 id="2-3I-x2F-O函数"><a href="#2-3I-x2F-O函数" class="headerlink" title="2.3I/O函数"></a>2.3I/O函数</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 依据处理数据的类型将其分为单个字符、文本行和二进制数据三种</div><p><strong>①字符I/O</strong></p><blockquote><p><strong>读取</strong>：<code>int getchar(void)</code>、<code>int getc(FILE *stream)</code>、<code>int fgetc(FILE *stream)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每次从流中读取下一个字符，如果不存在更多的字符，则返回EOF，其中getchar从标准输入读取字符</div><blockquote><p><strong>写入</strong>：<code>int putchar(int character)</code>、<code>int putc(int character,FILE *stream)</code>、<code>int fputc(int character,FILE *stream)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 从流中输出一个字符，其中putchar写入到标准输出中</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在打印前，这些函数会整型参数裁剪为一个无符号字符型</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其中fgetc和fputc是函数，其余是宏</div><blockquote><p><strong>字符回退</strong>：<code>int ungetc(int character,FILE *stream)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将一个字符返回到流中，以便于重新读入，退回到流和写入到流是不同的，前者类似于压栈，后者类似于队列的增长</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果流的位置之后被改变，则退回的字符会被丢弃</div><p><strong>②未格式化行I/O</strong></p><blockquote><p><strong>读取</strong>：<code>char *fgets(char *buffer,int buff_size,FILE *stream)</code>、<code>char *gets(char *buffer)</code></p></blockquote><blockquote><p>从<code>stream</code><strong>流</strong>中<strong>读取字符</strong>并<strong>复制</strong>到<code>buffer</code>中，当读取到<strong>一个换行符</strong>或者<strong>字符数达到</strong><code>buffer_size-1个</code>时就<strong>停止读取</strong></p></blockquote><blockquote><p>在<strong>缓冲区结尾</strong>添加一个<code>nul</code>，使其<strong>成为一个字符串</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> gets函数没有缓冲区长度，所以很可能导致缓冲区溢出，只适用于玩具程序</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若没有读取到字符，即到了文章尾，就返回NULL，否则返回buffer对应的指针</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> gets与fgets类似，是从标准输入中读取，但是gets不会存储换行符</div><blockquote><p><strong>写入</strong>：<code>int fputs(char const *buffer,FILE *stream)</code>、<code>int puts(char const *buffer)</code></p></blockquote><blockquote><p>传递给<code>fputs</code>的缓冲区<strong>必须包含一个字符串</strong>，并将该字符串<strong>逐字符</strong>写入<strong>流</strong>中，如果写入时发生了<strong>错误</strong>，则返回<code>EOF</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> puts与fputs类似，写入到标注输入中，且puts在写入一个字符串后，会再输出一个换行符</div><p><strong>③二进制I/O</strong></p><blockquote><p><strong>读取</strong>：<code>size_t fread(void *buffer,size_t size,size_t count,FILE *stream)</code></p></blockquote><blockquote><p><strong>写入</strong>：<code>size_t fwrite(void *buffer,size_t size,size_t count,FILE *stream)</code></p></blockquote><blockquote><p>其中<code>buffer</code>指向用于<strong>保存数据的内存位置</strong>，<code>size</code>为缓冲区<strong>每个元素的字节数</strong>（使用sizeof计算即可），<code>count</code>为<strong>读取或者写入的元素数</strong>，<code>stream</code>为<strong>指定的流</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 二进制I/O的效率非常高，省去了转换的开销</div><h4 id="2-4格式化读取"><a href="#2-4格式化读取" class="headerlink" title="2.4格式化读取"></a>2.4格式化读取</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 内容较多且重要，故单列出来</div><p><strong>①scanf家族</strong></p><blockquote><p><code>int fscanf(FILE *stream,char const *format,...)</code></p></blockquote><blockquote><p><code>int scanf(char const *format,...)</code></p></blockquote><blockquote><p><code>int sscanf(char const *string,char const *format,...)</code></p></blockquote><blockquote><p>从<strong>某输入源</strong>读入数据，其中<code>fscanf</code>为<code>stream</code><strong>指定的流</strong>，<code>scanf</code>为<strong>标准输入</strong>，<code>sscanf</code>为<code>string</code><strong>指向的字符串</strong></p></blockquote><blockquote><p>当<strong>格式化字符串</strong>到达<strong>末尾</strong>或者读取的输入<strong>不再与格式匹配</strong>时，<strong>输入停止</strong>，返回<strong>转化的输入值的数目</strong>，若<strong>没有读取</strong>输入值，则返回<code>EOF</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中...表示一个可变长度的指针列表，从输入源读取的数据转化后就存储在这些指针指向的位置</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> format为一个字符串，可以控制读取过程</div><p><strong>②format字符串</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> format字符串可能包含三种内容，即空白字符、格式代码和其他字符</div><blockquote><p><strong>空白字符</strong>：<strong>丢弃</strong>输入中的<strong>所有空白字符</strong></p></blockquote><blockquote><p><strong>格式代码</strong>：指定<strong>如何解释</strong>接下来的<strong>输入字符</strong></p></blockquote><blockquote><p><strong>其他字符</strong>：当出现<strong>其他字符</strong>时，<strong>下一个输入字符</strong>必须与他匹配，若<strong>匹配</strong>，该字符被<strong>丢弃</strong>，若<strong>不匹配</strong>，则<strong>直接结束</strong></p></blockquote><p><strong>③scanf格式代码详解</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以%开头，后面接一个可选的星号（`*`）、可选的宽度、可选的限定符和格式代码</div><blockquote><p><strong>星号（<code>*</code>）</strong>：使<strong>转换后的值</strong>被<strong>丢弃</strong>而不是被存储</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以用于跳过不需要的字符</div><blockquote><p><strong>宽度</strong>：用于<strong>限制</strong>读取的输入字符的<strong>个数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若没有限定宽度，则遇到空白字符停止</div><blockquote><p><strong>限定符</strong>：修改一些<strong>格式代码的含义</strong>，主要是指定<strong>参数的长度</strong>，有<code>h</code>、<code>l</code>、<code>L</code></p></blockquote><blockquote><p><code>h</code>修饰<strong>整型</strong>和<strong>无符号数</strong>，表示<code>short</code>和<code>unsigned short</code></p></blockquote><blockquote><p><code>l</code>修饰<strong>整型</strong>、<strong>无符号数</strong>和<strong>浮点型</strong>表示<code>long</code>、<code>unsigned long</code>和<code>double</code></p></blockquote><blockquote><p><code>L</code>修饰<strong>浮点型</strong>表示<code>long double</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在转换short、long和long double时，采用适当的限定符，提高程序可移植性</div><blockquote><p><strong>格式代码</strong>：一个<strong>单字符</strong>，表明<strong>如何解释输入字符</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> c表示char，d表示十进制int，u表示十进制无符号数，f表示浮点数等等</div><h4 id="2-5格式化写入"><a href="#2-5格式化写入" class="headerlink" title="2.5格式化写入"></a>2.5格式化写入</h4><p><strong>①printf家族</strong></p><blockquote><p><code>int fprintf(FILE *stream,char const *format,...)</code></p></blockquote><blockquote><p><code>int printf(char const *format,...)</code></p></blockquote><blockquote><p><code>int sprintf(char const *buffer,char const *format,...)</code></p></blockquote><blockquote><p>根据<code>format</code><strong>字符串</strong>将参数列表的值<strong>格式化</strong>，并<strong>输出</strong>到一定的<strong>输出源</strong>中，<strong>返回值</strong>为<strong>实际输出的字符数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中fprintf为stream指定的流，printf为标准输入，sprintf为buffer指向的缓冲区</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 使用sprintf要注意缓冲区的溢出问题</div><p><strong>②format格式代码</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 由%开头，后跟零个或多个标志字符、可选的最小字段宽度、可选的精度、可选的修改符以及转换类型</div><blockquote><p><strong>标志字符</strong>：决定其<strong>表现形式</strong>，如<strong>对齐</strong>、<strong>填充格式</strong>等</p></blockquote><blockquote><p><strong>字段宽度</strong>：指定出现在结果中的<strong>最小字符数</strong>，如果<strong>值的字符数小于该值</strong>，则对其进行<strong>填充</strong></p></blockquote><blockquote><p><strong>精度</strong>：以<strong>一个句号开头</strong>，后跟一个可选的<strong>十进制整数</strong>，不同<strong>转换类型</strong>的格式也不尽相同，对于<code>f</code>是规定<strong>小数点后的位数</strong>，对于<code>s</code>则是指定被转换的<strong>最多字符</strong></p></blockquote><blockquote><p><strong>修改符</strong>：类似于<code>scanf</code>格式代码中的<strong>限定符</strong>，指定<strong>长短类型</strong></p></blockquote><blockquote><p><strong>转换类型</strong>：转化为那种<strong>数据类型</strong>、<strong>格式</strong>和<strong>进制</strong>等，常用的有整数<code>d</code>、字符串<code>s</code>和浮点数<code>f</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 其中字段宽度和精度可以用星号替代，由print的下一个参数指定</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当字符或短整数作为printf的参数时，会被先转化为整数，需要使用修改符，修改符在转换发生之前将其转换为对应类型，同样在长整型和int长度不同的环境中也需要对应的修改符指明其长度</div><hr><h3 id="3-标准函数库"><a href="#3-标准函数库" class="headerlink" title="3.标准函数库"></a>3.标准函数库</h3><h4 id="3-1整型函数"><a href="#3-1整型函数" class="headerlink" title="3.1整型函数"></a>3.1整型函数</h4><p><strong>①算数</strong></p><blockquote><p><code>int abs(int value)</code>：返回<strong>绝对值</strong></p></blockquote><blockquote><p><code>div_t div(int x,int y)</code>：将<strong>第二个参数</strong>除以<strong>第一个参数</strong>，产生<strong>商</strong>和<strong>余数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中商是最靠近精确解的整数，其中div_t是一个结构，其中quot是商，rem是余数</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 都有对应的处理长整型的版本</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> /操作符的除法运算结果并未精确定义，当其操作数任一为负数且不能整除时，商和精确解的舍入关系取决于编译器</div><p><strong>②随机数</strong></p><blockquote><p><code>int rand (void)</code>：返回一个<code>0</code>至<code>RAND_MAX</code><strong>区间内</strong>的<strong>伪随机数</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了得到特定范围的伪随机数，可以对其进行取模并添加偏移量</div><blockquote><p><code>void srand(unsigned int seed)</code>：利用<code>seed</code>对<code>rand</code>进行<strong>初始化</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> seed常常采用每天的时间，即srand((unsigned int)time(0))</div><h4 id="3-2浮点型函数"><a href="#3-2浮点型函数" class="headerlink" title="3.2浮点型函数"></a>3.2浮点型函数</h4><p><strong>①算数</strong></p><blockquote><p><code>double sqrt(double x)</code>：取<strong>平方根</strong></p></blockquote><blockquote><p><code>double exp(double x)</code>：返回以<code>e</code>的<code>x</code><strong>次幂</strong></p></blockquote><blockquote><p><code>double floor(double x)</code>：返回<strong>不大于参数</strong>的<strong>最大整数</strong></p></blockquote><blockquote><p><code>double ceil(double x)</code>：返回<strong>不小于参数</strong>的<strong>最小整数</strong></p></blockquote><blockquote><p><code>double fabs(double x)</code>：返回参数的<strong>绝对值</strong></p></blockquote><blockquote><p><code>double fmod(double x,double y)</code>：返回<code>x</code>除以<code>y</code>的<strong>余数</strong></p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 参数需要在定义域内，结果需要在double所能表示的范围内</div><p><strong>②三角函数</strong></p><blockquote><p><code>sin</code>、<code>cos</code>、<code>tan</code>、<code>asin</code>、<code>acos</code>、<code>atan</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这些函数接收返回均为double，sin、cos、tan的参数是弧度，asin、acos、atan的参数范围从-1至1</div><p><strong>③对数和指数函数</strong></p><blockquote><p><code>double exp(double x)</code>：<code>e</code>的<code>x</code>次幂</p></blockquote><blockquote><p><code>double pow(double x,double y)</code>：<code>x</code>的<code>y</code>次幂，其中<code>x</code>不能是<strong>负数</strong>，<code>y</code>必须是<strong>整数</strong></p></blockquote><blockquote><p><code>double log(double x)</code>：以<code>e</code>为底的<strong>对数</strong></p></blockquote><blockquote><p><code>double log10(double x)</code>：以<code>10</code>为底的<strong>对数</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以采用换底公式计算任意底数的对数</div><p><strong>④浮点数表示</strong></p><blockquote><p><code>double frexp(double value,int *exponent)</code>：该函数返回<code>fraction</code>，并将<code>exponent</code>存储到第二个参数<strong>指定位置</strong>，其中<code>fraction*2^exponent = value</code></p></blockquote><blockquote><p><code>double ldexp(double fraction,int exponent)</code>：配合以上函数，<strong>还原该浮点数</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 用于浮点格式不兼容的机器之间传递浮点数</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 要记得包含math.h头文件，绝大部分参数和返回值都是double类型</div><h4 id="3-3时间与日期函数"><a href="#3-3时间与日期函数" class="headerlink" title="3.3时间与日期函数"></a>3.3时间与日期函数</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要记得包含time.h头文件</div><p><strong>①处理器时间</strong></p><blockquote><p><code>clock_t clock(void)</code>：返回从<strong>程序开始</strong>起<strong>处理器</strong>消耗的时间</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> clock_t由编译器定义，通常是处理器时钟滴答的次数，可以将其除以CLOCKS_PER_SEC转化为秒</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果想要精确的执行时间，可以在程序（某段语句）开始处与结尾处，各放置一个clock()，将结果相减</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若操作系统不能追踪处理器时间，则返回已经流逝的实际时间数量</div><p><strong>②当天时间</strong></p><blockquote><p><code>time_t time(time_t *returned_value)</code>：返回<strong>当前</strong>的<strong>时期</strong>和<strong>时间</strong>，并存储到<strong>参数指向位置</strong>，当<strong>机器无法提供时间</strong>或者<strong>时间值太大</strong>，就返回<code>-1</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不同的编译器格式不同，常见的形式是从某一特定时间开始流逝的秒数，在UNIX中，这个时间为1970年1月1日零点</div><p><strong>③日期和时间的转换</strong></p><blockquote><p><code>double difftime(time_t time1,time_t time2)</code>：计算<code>time1-time2</code>，并将其<strong>转化为秒</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不要直接调用两次time函数并相减</div><blockquote><p><code>struct tm *gmtime(time_t const *time_value)</code>：将时间转换为<strong>世界协调时间</strong></p></blockquote><blockquote><p><code>struct tm *localtime(time_t const *time_value)</code>：将时间转换为<strong>当地时间</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> tm结构包含了很多与时间有关的成员</div><blockquote><p><code>char *ctime(time_t const *time_value)</code>：接收一个<code>time_t</code>的指针，返回一个对应时间的字符串</p></blockquote><blockquote><p><code>char *asctime(struct tm const *tm_ptr)</code>：将<code>tm</code>结构转化为与<code>ctime</code>结果一样的字符串</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 字符串格式是固定的，编译器通常将其保存在一个静态数组中，如果想要特定格式的字符串，可以调用strftime()</div><p><strong>3.4非本地跳转</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要记得包含setjmp.h头文件</div><p><strong>①定义</strong></p><blockquote><p>类似于<code>goto</code>语句，但是<strong>不局限于一个函数的作用域</strong>之内</p></blockquote><p><strong>②相关函数</strong></p><blockquote><p><code>int setjmp(jmp_buf state)</code>：<strong>初始化</strong>一个<code>jmp_buf</code>变量，并将<strong>程序的状态信息</strong>保存到<strong>跳转缓冲区</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 调用setjmp的函数称为顶层函数</div><blockquote><p><code>void longjmp(jump_buf state,int value)</code>：使得<strong>跳转缓冲区的状态被恢复</strong>，从而<strong>立即跳转</strong>到<strong>顶层函数</strong></p></blockquote><p><strong>3.5信号</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 要记得包含signal.h头文件</div><p><strong>①含义</strong></p><blockquote><p>一种<strong>非程序本身</strong>引发的事件</p></blockquote><p><strong>②标准定义的信号</strong></p><blockquote><p><code>SIGABRT</code>：<strong>程序请求异常终止</strong>，由<code>abort</code>函数引发，常见的错误是<strong>算数溢出</strong>以及<strong>除零错误</strong></p></blockquote><blockquote><p><code>SIGFPE</code>：发生一个<strong>算数错误</strong></p></blockquote><blockquote><p><code>SIGILL</code>：检测到<strong>非法指令</strong>，比如<strong>指令版本不同</strong></p></blockquote><blockquote><p><code>SIGSEGV</code>：检测到<strong>对内存的非法访问</strong>，比如访问<strong>未分配给该程序的内存</strong>，或者出现<strong>边界对齐错误</strong></p></blockquote><blockquote><p><code>SIGINT</code>：收到一个<strong>交互性注意信号</strong></p></blockquote><blockquote><p><code>SIGTERM</code>：收到到一个<strong>终止程序的请求</strong></p></blockquote><p><strong>③信号处理</strong></p><blockquote><p><code>int raise(int sig)</code>：显示地<strong>引发一个信号</strong></p></blockquote><blockquote><p><code>void (*signal(int sig,void(*handler)(int))) (int)</code>：将<strong>某信号的处理函数</strong>指定为<code>handler</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将函数简化为void(*signal()) (int)，则signal是一个返回类型为函数指针（对应信号以前的处理函数）的函数，其所接受参数sig为标准定义的信号，handler为希望信号发生时调用的函数，当函数调用失败时，返回SIG_ERR</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 还可以将signal函数第二个参数替换为SIG_DFL，恢复对该信号的缺省反应；或者替换为SIG_IGN，使该信号被忽略</div><h4 id="3-6执行环境"><a href="#3-6执行环境" class="headerlink" title="3.6执行环境"></a>3.6执行环境</h4><p><strong>①终止程序</strong></p><blockquote><p><code>void abort(void)</code>：引发<code>SIGABRT</code>信号，若<strong>没有</strong>在程序中为其<strong>设置信号处理函数</strong>，则<strong>程序终止</strong></p></blockquote><blockquote><p><code>void atexit(void(func)(void))</code>：把<strong>一些函数</strong>注册为<strong>退出函数</strong>，当程序<strong>正常终止（调用<code>exit()</code>函数）</strong>，<strong>退出函数</strong>将被调用</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意该退出函数的格式</div><blockquote><p><code>void exit(int status)</code>：当<strong>该函数被调用</strong>时，所有被<code>atexit()</code><strong>注册的函数</strong>将按照他们<strong>注册的顺序</strong>被<strong>反序</strong>调用，随后<strong>刷新所有缓冲区</strong>，<strong>关闭所有文件</strong>，并<strong>删除所有临时文件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> main函数return语句相当将返回值传递给exit()并调用它</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 由atexit()注册的函数中不能包含exit()，其结果是未定义的</div><p><strong>②断言</strong></p><blockquote><p><code>void assert(int expression)</code>：当<code>expression</code>为假时，向<strong>标准错误</strong>打印一条<strong>诊断信息</strong>并<strong>终止程序</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 本质上是一个宏，其诊断信息的格式由编译器定义</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过定义NDEBUG宏消除所有断言，可以将其定义为任意值</div><p><strong>③环境与系统</strong></p><blockquote><p><code>char *getenv(char const *name)</code>：在<strong>环境</strong>中查找一个<strong>特定的名字</strong>，如果<strong>找到</strong>则返回一个<strong>不能修改</strong>的<strong>字符指针</strong>，否则返回<code>NULL</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 环境：一个由编译器定义的名字/值对的列表</div><blockquote><p><code>void system(char const *command)</code>：将字符串传递给<strong>操作系统</strong>，将其作为一条命令，由<strong>系统的命令处理器</strong>运行</p></blockquote><p><strong>④排序与查找</strong></p><blockquote><p><code>qsort()</code>：以<strong>升序</strong>的方式<strong>对数组进行排序</strong>，与<strong>类型无关</strong></p></blockquote><blockquote><p><strong>函数原型</strong>：<code>void qsort(void *base,size_t n_elements,size_t el_size,int(*compare)(void const *,void const *))</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中第一个参数指向需要排序的数组，第二个参数指定数组中元素的数目，第三个参数指定每个元素的长度，第四个参数时一个用于比较的函数指针</div><blockquote><p><code>bsearch()</code>：在一个已经<strong>排好序</strong>的数组中用<strong>二分法</strong>查找一个<strong>特定的元素</strong></p></blockquote><blockquote><p><strong>函数原型</strong>：<code>void *bsearch(void const *key,void const *base,size_t n_elements,size_t el_size,int(*compare)(void const *,void const *))</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中第一个参数时需要查找的值，第二个参数指向查找的数组，第三个参数指定数组的数目，第四个参数是每个元素的长度，最后一个参数是用于比较的函数指针</div><p><strong>3.7本地化</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 详细见《C与指针》p347-349</div><p><strong>①<code>locale</code></strong></p><blockquote><p>一组<strong>特定的参数</strong>，每个<strong>国家</strong>和<strong>地区</strong>都<strong>不同</strong></p></blockquote><p><strong>②设置<code>locale</code></strong></p><blockquote><p><code>char *setlocale(int category,char const *locale)</code></p></blockquote><blockquote><p>其中，<code>category</code>用于指定<code>locale</code>的<strong>哪个部分</strong>需要被修改，<code>locale</code>指定新的<code>locale</code>，若该参数为<code>NULL</code>，则返回当前的<code>locale</code></p></blockquote><p><strong>③<code>setlocale</code>参数列表</strong></p><blockquote><p><code>LC_ALL</code>：整个<code>locale</code></p></blockquote><blockquote><p><code>LC_COLLATE</code>：<strong>字符集对照序列</strong>，将影响<code>strcoll</code>和<code>strxfrm</code>函数的行为</p></blockquote><blockquote><p><code>LC_CTYPE</code>：定义于<code>ctype.h</code>中的函数所使用的<strong>字符类型分类</strong>信息</p></blockquote><blockquote><p><code>LC_MONETARY</code>：<strong>格式化货币值</strong>使用的<strong>相关字符</strong></p></blockquote><blockquote><p><code>LC_NUMERIC</code>：<strong>格式化非货币值</strong>使用的<strong>相关字符</strong></p></blockquote><blockquote><p><code>LC_TIME</code>：<code>strftime</code><strong>函数的行为</strong></p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 《C和指针》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记（二）</title>
      <link href="/2023/12/10/c-yu-yan-xue-xi-bi-ji-er/"/>
      <url>/2023/12/10/c-yu-yan-xue-xi-bi-ji-er/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言学习笔记（二）"><a href="#C语言学习笔记（二）" class="headerlink" title="C语言学习笔记（二）"></a>C语言学习笔记（二）</h1><h2 id="C语言基础"><a href="#C语言基础" class="headerlink" title="C语言基础"></a>C语言基础</h2><h3 id="1-指针"><a href="#1-指针" class="headerlink" title="1.指针"></a>1.指针</h3><h4 id="1-1引言"><a href="#1-1引言" class="headerlink" title="1.1引言"></a>1.1引言</h4><blockquote><p><strong>比特/位</strong>：计算机的<strong>最小存储单位</strong>，可以存储<strong>1和0</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 数据以比特流的形式存储，被解释为什么取决于我们的使用方式和声明方式</div><blockquote><p><strong>字节</strong>：<strong>一个字节</strong>包含<strong>8个比特</strong>，存储<strong>一个字符</strong>所需要的<strong>位数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 字节是计算机的最小寻址单位</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 一些数据类型（如整型）的存储的起始位置只能是某些特定的字节，通常是2和4的倍数</div><blockquote><p><strong>字</strong>：<strong>一个字</strong>由<strong>2/4个字节</strong>组成</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个字的地址是其最左边或者最右边的字节的地址，每台机器规定不同</div><blockquote><p><strong>寻址</strong>：<strong>高级语言</strong>一般通过<strong>变量名</strong>访问<strong>内存位置</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 变量名和地址的关系由编译器提供，硬件还是通过地址访问内存位置</div><h4 id="1-2指针变量"><a href="#1-2指针变量" class="headerlink" title="1.2指针变量"></a>1.2指针变量</h4><p><strong>①声明格式</strong>：</p><blockquote><p><code>[指向变量的数据类型] *[指针变量名] = &amp;[指向的变量]</code></p></blockquote><blockquote><p><code>*</code>为<strong>间接访问操作符</strong>，可以通过它<strong>访问指针指向的地址</strong></p></blockquote><blockquote><p><code>&amp;</code>为<strong>取址符</strong>，通过它可以<strong>获得变量的地址</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对（*指针变量）进行操作相当于对其指向的变量进行操作</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 指针不是一个整型，其数据类型取决于指向的变量的数据类型</div><blockquote><p>假设<strong>整数</strong><code>a</code>的<strong>地址</strong>是<code>100</code>，不能使用<code>*100 = 10</code>对<code>a</code>进行<strong>赋值</strong>，因为<code>100</code>是<strong>字面量</strong>，<strong>缺省情况</strong>下是<strong>整型</strong>而不是<strong>指针变量</strong>，应该写为<code>*（int*）100 = 10</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以使用该技巧访问特定地址</div><p><strong>②未初始化的指针</strong></p><blockquote><p>使用<strong>未初始化的指针</strong>会<strong>引发错误</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">int *a;*a = 12;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若指针变量没有被初始化，则其值可能为一垃圾值（动态变量）或者0（静态变量）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 未初始化指针可能指向非法地址（内存错误）或者导致储存地址处于错误的边界（总线错误）</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以先将指针初始化为空指针NULL，但是注意要进行空指针检查，因为对空指针引用也是错误的</div><p><strong>③指针的指针</strong></p><blockquote><p><code>int** a = &amp;b</code>：其中<code>b</code>是一个<strong>指向整型变量的指针</strong>，<code>a</code>表示一<strong>个指向指向整型变量指针的指针</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 依此类推，也称为多重指针</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 尽量少使用多重指针</div><p><strong>④指针与左右值</strong></p><pre class="line-numbers language-none"><code class="language-none">int a = 10；int* b = &amp;a；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><code>*b</code>相当于<code>a</code>，作为<strong>右值</strong>代表的是<code>10</code>，作为<strong>左值</strong>时代表<code>a</code>的<strong>内存位置</strong></p></blockquote><blockquote><p><code>&amp;a</code>作为<strong>右值</strong>代表<strong>a的地址</strong>，<strong>不能作为左值</strong>，因为<code>&amp;a</code><strong>不能代表内存中某一特定位置</strong></p></blockquote><blockquote><p><code>b</code>作为<strong>右值</strong>代表<code>a</code>的<strong>地址</strong>，作为<strong>左值</strong>表示的是<code>b</code><strong>自身的地址</strong></p></blockquote><h4 id="1-3指针表达式"><a href="#1-3指针表达式" class="headerlink" title="1.3指针表达式"></a>1.3指针表达式</h4><p><strong>①单操作符</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ++/--的优先级高于*，*的优先级高于+/-</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意++/--操作符和+/-1的不同，前者会改变变量，后者不会</div><blockquote><p><code>*b+1</code>：作为<strong>左值</strong>是<strong>非法</strong>的，作为<strong>右值</strong>表示对<strong>变量</strong><code>a</code>中的<strong>数据加1</strong></p></blockquote><blockquote><p><code>*（b+1）</code>：相当于<code>b</code><strong>后一个内存</strong>的<strong>标识符</strong>，作为<strong>左值</strong>代表对应的<strong>内存位置</strong>，作为<strong>右值</strong>代表对应位置<strong>存储的数据</strong>。</p></blockquote><blockquote><p><code>++b</code>：作为<strong>左值</strong>是<strong>非法</strong>的，作为<strong>右值</strong>表示<code>b</code>后一个<strong>内存位置</strong></p></blockquote><blockquote><p><code>b++</code>：作为<strong>左值</strong>是<strong>非法</strong>的，作为<strong>右值</strong>表示<code>b</code>对应的<strong>内存位置</strong>，随后<strong>该指针变量指向后一个内存位置</strong></p></blockquote><blockquote><p><code>*++b</code>：作为的<strong>左值</strong>表示的是<code>b</code><strong>指向内存单元的后一个内存单元</strong>，作为<strong>右值</strong>表示<code>b</code><strong>指向位置后一个位置存放的数据</strong></p></blockquote><blockquote><p><code>*b++</code>：作为<strong>左值</strong>表示的是该<strong>指针指向的内存位置</strong>，随后<strong>该指针变量加一</strong>，作为<strong>右值</strong>表示的是<strong>该指针指向位置存放的数据</strong>，随后<strong>该数据加一</strong></p></blockquote><blockquote><p><code>++*b</code>：作为<strong>左值</strong>是<strong>非法</strong>的，作为<strong>右值</strong>表示的是<strong>b指向变量存放数据</strong>的值<strong>加一</strong></p></blockquote><p><strong>②加减法</strong></p><blockquote><p><strong>与整数加减法</strong>：当对<strong>指针</strong>加减一个<strong>整数</strong><code>n</code>时，该指针会<strong>根据其指向的数据的类型调整自身大小</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如某台机器上float占4个字节，对一个float类型指针+n，该指针的大小会增加4n个字节</div><blockquote><p><strong>指针之间的减法</strong>：只有当<strong>两个指针</strong>都指向<strong>同一数组中的元素</strong>时，才允许进行<strong>减法</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 得到的数据类型是ptrdiff_t，是一种有符号整数，表示两个指针指向位置的距离（以数组元素的长度为单位）</div><p><strong>③比较</strong></p><blockquote><p><strong><code>==</code>与<code>!=</code><strong>：可以用于</strong>任意两个指针</strong>，判断两个指针<strong>是否相同</strong></p></blockquote><blockquote><p><strong>大小比较</strong>：只能用于<strong>同一个数组</strong>内的元素</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 同一数组的元素还包括数组末尾后一位元素，但是不包括数组开头前一位元素</div><h4 id="1-4函数指针"><a href="#1-4函数指针" class="headerlink" title="1.4函数指针"></a>1.4函数指针</h4><p><strong>①格式</strong></p><blockquote><p><code>返回类型 (*f)(参数列表)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ()为函数调用操作符，f()的结果是函数f的返回值</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以解释为f被间接引用后是一个函数，该函数的返回值是一个整型，所以f为一个函数指针</div><p><strong>②初始化</strong></p><blockquote><p><code>返回类型 (*f)(参数列表) = 函数名</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在函数指针初始化时，其参数列表需要与之对应</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中函数名在编译时会被转换为函数指针，故可以不用取址符号</div><p><strong>③函数指针数组</strong></p><blockquote><p><code>返回类型 (*f[]) ();</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ()和[]均为同一优先级，结合性从左向右，优先级均高于*</div><pre class="line-numbers language-none"><code class="language-none">double  (*oper_func[])(double,double) = {a,b,c...};result = oper_func[1](i,j);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>④用途</strong></p><blockquote><p><strong>函数指针</strong>可以作为<strong>参数</strong>提供给<strong>另一个函数</strong>，以便在<strong>另一个函数</strong>中使用，也被称为<strong>回调函数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 将函数中与数据类型相关的操作替换为一系列等价的函数，需要使用哪类数据类型的对应操作，传递对应的函数指针</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将传递给函数以及回调函数的数据类型采用*void，用于接收不同数据类型的指针</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在使用这些数据的指针时，必须要强制转换为正确的数据类型</div><pre class="line-numbers language-none"><code class="language-none">/*比较函数的整数版本int compare_ints(void const *a,void const *b){if(*(int *)a = *(int *)b)return 0;elsereturn 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数</h3><h4 id="2-1格式"><a href="#2-1格式" class="headerlink" title="2.1格式"></a>2.1格式</h4><p><strong>①源文件</strong></p><blockquote><p><strong>概述</strong>：由<strong>返回类型</strong>、<strong>函数名</strong>、<strong>参数列表</strong>和<strong>函数主体</strong>组成</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 函数可以没有返回值，这是返回类型为void</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 函数中的形参是实参的一个副本，修改形参不会影响实参，如果想要修改实参，需要传递实参的地址</div><pre class="line-numbers language-none"><code class="language-none">返回类型 函数名（形参类型1 形参名1，...形参类型n 形参名n）{statement；    return expression；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong><code>return</code>语句</strong>：用于<strong>返回结果</strong>并表明此处是函数的<strong>退出点</strong>，可以出现在<strong>函数主体</strong>的<strong>任意位置</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如果函数主体的最后一条语句不是return语句，则该语句之后为函数的隐式退出点</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若函数的返回类型不为void，则需要在每个可能的退出点将值返回，其函数主体最后一条语句必为return语句</div><blockquote><p><strong>类型</strong>、<strong>形参</strong>和<strong>statement</strong>都<strong>不是必须</strong>的，因此<strong>最简单的函数</strong>如下</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 这种函数可以达到存根的目的,即为尚未编写的代码“占好位置”，可以保持程序在结构上的完整性</div><pre class="line-numbers language-none"><code class="language-none">void function （void）{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②函数声明</strong></p><blockquote><p><strong>格式</strong>：<code>返回类型 函数名(形参类型n 形参名n);</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 向编译器提供函数相关信息，当调用函数时传入参数与形参的类型不匹配，会根据函数声明强制转换变量类型</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以将函数定义在单独的C文件中，并将函数声明置于同一个头文件中，主函数文件使用include命令调用即可</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若没有对应的函数声明，函数会被调用，但是传递给函数的参数会进行缺省参数提升</div><blockquote><p><code>char</code>和<code>short</code>被转换为<code>int</code>，<code>float</code>被转化为<code>double</code>，且默认返回一个<strong>整型</strong></p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 函数原型不要写在代码块中，因为代码块中的函数原型有代码块作用域，可能会覆盖原来的函数声明</div><p><strong>③黑盒</strong></p><blockquote><p>利用<code>static</code>关键字修饰<strong>函数内置数据和函数</strong>，使其变为<strong>函数文件私有</strong>，<strong>外界不能访问</strong></p></blockquote><h4 id="2-递归函数"><a href="#2-递归函数" class="headerlink" title="2.递归函数"></a>2.递归函数</h4><p><strong>①定义</strong></p><blockquote><p>直接或者间接<strong>调用自身</strong>的函数，当递归函数<strong>不再满足某个条件</strong>时，便<strong>停止</strong>调用自身</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 递归函数需要设置限制条件，且每次递归调用之后就越接近该限制条件</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 递归的计算代价非常大，如果可以使用循环等解决问题，不要使用递归</div><p><strong>②例子</strong></p><blockquote><p>输入<code>value</code>为<code>4267</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">binary_to_ascii(unsigned int value){unsigned int a;a = value/10;if(a!=0)binary_to_ascii(a)putchar(value%10+‘0)’;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③实现过程</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每次函数调用，都会创建一个栈帧，存放临时变量和返回地址等，并压入程序栈中，直到函数调用结束才会弹出</div><blockquote><p><strong>第一次调用</strong>，在<strong>堆栈</strong>中压入了<code>value1 = 4267</code>和<code>a1 = 426</code></p></blockquote><blockquote><p><code>a!=0</code>，进行<strong>第二次调用</strong>，压入<code>value2 = 426</code>、<code>a2 = 42</code></p></blockquote><blockquote><p><code>a!=0</code>，进行<strong>第三次调用</strong>，压入<code>value3 = 42</code>，<code>a3 = 4</code></p></blockquote><blockquote><p><code>a!=0</code>，进行<strong>第四次调用</strong>，压入<code>value[4] = 4</code>，<code>a[4] = 0</code></p></blockquote><blockquote><p><code>a=0</code>，<strong>递归停止</strong>，开始<strong>从堆栈中弹出并打印</strong>变量<code>a4</code>、<code>a3</code>、<code>a2</code>、<code>a1</code></p></blockquote><h4 id="2-3可变参数列表"><a href="#2-3可变参数列表" class="headerlink" title="2.3可变参数列表"></a>2.3可变参数列表</h4><p><strong>①实现</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要引入stdarg.h头文件</div><blockquote><p>该<strong>头文件</strong>中声明了一个<code>va_list</code><strong>类型</strong>和<strong>三个宏</strong><code>va_start</code>、<code>va_arg</code>和<code>va_end</code></p></blockquote><p><strong>②用法</strong></p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意函数形参部分的写法，可变参数列表用...代替，在书写函数声明时，也需要注意</div><blockquote><p>在<strong>函数体内部</strong>定义<code>va_list</code>类型参数，代表<strong>可变参数列表</strong></p></blockquote><blockquote><p>使用<code>va_statr</code>宏<strong>初始化</strong><code>va_list</code>类型参数</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该宏第一个参数是va_list类型参数number_n，第二个参数是可变参数列表的前一个参数n_value</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 要使用该宏，则函数必须至少有一个已确定的参数，如下例中的value</div><blockquote><p>使用<code>va_arg</code><strong>代替可变参数</strong>进行计算</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该宏接收的第一个参数是va_list类型参数number_n，第二个参数是可变参数列表的数据类型</div><blockquote><p>使用<code>va_end</code><strong>注销</strong>可变参数列表</p></blockquote><p><strong>③例子</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdarg.h&gt;</span></span><span class="token comment">//用于计算输入数字的平均数</span><span class="token keyword">float</span> <span class="token function">average</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n_value<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>va_list number_n<span class="token punctuation">;</span><span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token keyword">float</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">va_start</span><span class="token punctuation">(</span>number_n<span class="token punctuation">,</span>n_value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>count<span class="token operator">&lt;</span>n_value<span class="token punctuation">;</span>count<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>sum <span class="token operator">=</span> sum<span class="token operator">+</span><span class="token function">va_arg</span><span class="token punctuation">(</span>number_n<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">va_end</span><span class="token punctuation">(</span>number_n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> sum<span class="token operator">/</span>n_value<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h3><h4 id="3-1引言"><a href="#3-1引言" class="headerlink" title="3.1引言"></a>3.1引言</h4><p><strong>①格式</strong></p><blockquote><p><code>数据类型 数组名[数组大小]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> C语言中，数组的长度一开始就要确定</div><p><strong>②数组名</strong></p><blockquote><p><strong>本质</strong>上是一个<strong>指针常量</strong>，指向<strong>数组的起始位置</strong>，同时还包含<strong>数组长度等信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 创建数组时编译器会根据其长度为数组划分对应的内存空间，随后为数组名划分内存</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 只有数组名在表达式中被使用了，编译器才会创建对应的指针常量</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 数组名大部分情况下可作为指针常量使用，但是有些情况下代表整个数组</div><blockquote><p>比如<code>sizeof(数组名)</code>会返回<strong>整个数组的长度</strong>，<code>&amp;数组名</code>产生的是一个<strong>数组的指针</strong>，而<strong>不是</strong>一个<strong>指向指针的指针</strong></p></blockquote><p><strong>③下标引用</strong></p><blockquote><p><code>a[b]</code>相当于<code>*(a+b)</code>，<strong>所以下标从0开始</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 指针间接访问的效率大于等于下标引用效率，详细见《C与指针》p145-p150</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> C语言中，下标引用可以应用于所有的指针，不仅仅局限于数组名</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意检查数组越界问题</div><p><strong>④作为形参传递</strong></p><blockquote><p><strong>格式</strong>：<code>数据类型 数组名[]</code>或者<code>数据类型 *指针名</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 函数在声明数组参数时，不需要指明他的长度，因为函数只接受数组的地址，而不为其分配内存</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果需要知道数组的大小，还需要传递另一个参数</div><h4 id="3-2初始化"><a href="#3-2初始化" class="headerlink" title="3.2初始化"></a>3.2初始化</h4><p><strong>②格式</strong></p><blockquote><p><code>数据类型 数组名[] = {值1,值2,…}</code></p></blockquote><blockquote><p>当数组为<strong>静态变量</strong>时，在<strong>程序执行前</strong>便被初始化，<strong>缺省情况</strong>下<strong>全部初始化</strong>为<strong>0</strong></p></blockquote><blockquote><p>当数组为<strong>动态变量</strong>时，在<strong>缺省情况</strong>下各个元素的<strong>值是随机的</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 若程序执行流将多次经过一数组，可以将其设置为静态变量，减少其初始化次数</div><p><strong>②不完整的初始化</strong></p><blockquote><p><strong>缺少元素</strong>：<strong>优先填充前面的</strong>，<strong>其余</strong>的被<strong>初始化</strong>为<code>0</code></p></blockquote><blockquote><p><strong>缺少数组长度</strong>：<strong>编译器</strong>将其<strong>设置为</strong>刚好能够<strong>容纳所有初始值</strong>的大小</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 只有在显示初始化时才能缺少数组长度</div><p><strong>③字符数组的初始化</strong></p><blockquote><p><code>char a[] = “b”</code>相当于<code>char a = {'b',NUL}</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 只有在初始化字符数组时“b”才代表一个初始化列表，其他场合均为字符串常量</div><blockquote><p>如下，<code>message1</code>是一个<strong>字符数组</strong>，<code>message2</code>是一个<strong>指向字符串字面值的指针</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">char message1[] = "hello";char *message2 = "hello";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="3-3多维数组"><a href="#3-3多维数组" class="headerlink" title="3.3多维数组"></a>3.3多维数组</h4><p><strong>①定义</strong></p><blockquote><p><code>数据类型 数组名 [维度1][维度2]…[维度N]</code>，如<code>int a [3][4]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以解读为a数组有三个元素，每个元素又是一个包含4个元素的数组</div><blockquote><p><strong>存储形式</strong>：按照<strong>最右边的下标</strong>率先变化，比如<code>int *b = &amp;a[1][3]</code>,<code>b++</code>为<code>a[2][0]</code></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/C_1.png" alt="多维数组的存储"></p><p><strong>②数组名</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 类比一维数组，将n维数组看为一个元素是n-1维数组的一维数组，数组名即指向第一个n-1维数组的指针</div><blockquote><p><code>a</code>：指向第一个包含<strong>四个整型元素的数组</strong></p></blockquote><blockquote><p><code>a+1</code>:指向的<strong>第二个四元素一维数组</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 指针的加减法根据指针的类型决定</div><blockquote><p><code>*(a+1)</code>：指向<strong>第二个四个元素数组</strong>的<strong>第一个整型元素的指针</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意这还不是其中所包含的数据，而是一个指针常量</div><blockquote><p><code>*a+1</code>:指向<strong>第一个四个元素数</strong>组的<strong>第二个元素</strong></p></blockquote><blockquote><p><code>*(*a+1)</code>：为<strong>第一个四个元素数组</strong>的<strong>第二个元素</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一层一层解引用，n维数组要解引用n次，才能获得数据</div><p><strong>③初始化</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以二维数组a为例</div><blockquote><p><code>int a[][] = {元素1、元素2…};</code>，元素按照其<strong>存储顺序</strong>排列</p></blockquote><blockquote><p><code>int a[][] = {{数组1}，{数组2}…};</code></p></blockquote><blockquote><p>通过<code>a[i][j] = 值ij;</code>，<strong>一个个赋值</strong></p></blockquote><p><strong>④多维数组与指针</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以二维数组a为例</div><blockquote><p><strong>多维数组的指针</strong>：<code>数组元素数据类型 (*p)[数组元素个数] = 二维数组名</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对*p进行下标引用，得到一个数据，所以*p是一个一维数组，故p为一个指向一维数组的指针，也就是二维数组名</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 这里的数组元素个数与之对应，如int (*p)[4] = a;，且要记得加上括号，因为下标引用的优先级高于引用</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将数组传递给一个函数，本质上是传递其元素类型的指针，对于多维数组，就是传递一个指向数组的指针</div><blockquote><p><strong>接收二维数组的形参</strong>应写为<code>void func1(int (*a)[4])</code>或者<code>void func1(int a[][4])</code></p></blockquote><blockquote><p><strong>指向元素的指针</strong>：<code>数组元素数据类型 *p = &amp;数组名[0][0]</code>或者<code>数组元素数据类型 *p = 数组名[0]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 注意后者是没有&amp;符号的，因为后者就是一个指向元素的指针！</div><blockquote><p><strong>指针数组</strong>：<code>数据类型* 数组名[元素个数]</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 与指向数组的指针仅仅只有一个括号之差</div><h4 id="3-4字符串"><a href="#3-4字符串" class="headerlink" title="3.4字符串"></a>3.4字符串</h4><p><strong>①定义</strong></p><blockquote><p>以<code>'/0'</code><strong>结尾</strong>的<strong>字符数组</strong> </p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> '/0'的位模式全为0，也叫NUL字节，是字符串的终止符，字符串长度不包括终止符的长度</div><p><strong>②基本操作</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要包含string.h头文件</div><blockquote><p><code>strlen()</code>：<strong>测量字符串长度</strong>，即字符串包含的<strong>字符个数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该函数返回的长度的数据类型为size_t，是一个无符号数</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 大部分字符串相关函数都是根据终止符判断字符串长度，故要确保操作后字符串不会溢出，否则会缺少终止符</div><blockquote><p><code>strcpy()</code>：<strong>复制字符串</strong>，若其长度<strong>超出了容器的限度</strong>，则会<strong>覆盖其后面的内存空间</strong></p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 大部分字符串函数不允许两个字符数组参数重叠，否则函数的返回值是未定义的</div><blockquote><p><code>strcat()</code>：<strong>连接字符串</strong>，将<strong>一个字符串</strong>添加到<strong>另一个字符串后面</strong></p></blockquote><blockquote><p><code>strcmp()</code>：<strong>字符串比较</strong>，进行的是<strong>字典比较</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 字典比较：对两个字符串的逐个字符从头进行比较，只要比较出一个字符大小即可判断结果，'/0'小于任何字符</div><blockquote><p><strong>长度受限的字符串函数</strong>：为了<strong>防止目标数组溢出</strong>，定义了<strong>对应函数</strong>的<strong>长度受限版本</strong>，接受一个<strong>长度参数</strong>，用于<strong>限制操作的字符个数</strong>，如<code>strncpy()</code></p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 但是这些函数可能导致目标数组不是以'/0'结尾，可能会导致程序崩溃</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以在函数调用完后将字符数组的最后一个元素改为NUL</div><p><strong>③字符查找</strong></p><blockquote><p><code>strchr()</code>：返回对应字符<strong>第一次</strong>出现的下标</p></blockquote><blockquote><p><code>strrchr()</code>：返回对应字符<strong>最后一次</strong>出现的下标</p></blockquote><blockquote><p><code>strpbrk()</code>：返回<strong>一组字符中任意一个字符第一次</strong>出现的下标</p></blockquote><p><strong>④字串查找</strong></p><blockquote><p><code>strstr()</code>：返回<strong>子串</strong>第一次出现的<strong>起始位置</strong></p></blockquote><blockquote><p><code>strtok()</code>：<strong>删除</strong>字符串中的所有<strong>标记字符</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通常以字符串形式传递多个标记字符</div><blockquote><p><code>strcspn()</code>:检索<strong>字符串中标记字符第一次出现</strong>的下标</p></blockquote><p><strong>⑤字符操作</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要包含ctype.h头文件</div><blockquote><p><strong>字符分类</strong>：根据对应<strong>分类函数</strong>定义，判断<strong>字符</strong>是否为<strong>该类型</strong>，如<code>isspace()</code>判断其是否为<strong>空白字符</strong></p></blockquote><blockquote><p><strong>字符转换</strong>：转换<strong>字符</strong>的<strong>大小写</strong>等形式，如<code>tolower()</code>将<strong>字符</strong>转化为<strong>小写形式</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 直接测试或者操纵字符可能会影响程序的移植性，推荐使用对应的字符操作函数</div><blockquote><p>比如<code>if(ch&gt;='A' &amp;&amp; ch&lt;='Z')</code>判断<code>ch</code>是否为<strong>大写字母</strong>，在使用<strong>EBCDIC字符集</strong>上的机器上将<strong>失败</strong></p></blockquote><h3 id="4-结构"><a href="#4-结构" class="headerlink" title="4.结构"></a>4.结构</h3><h4 id="4-1格式"><a href="#4-1格式" class="headerlink" title="4.1格式"></a>4.1格式</h4><p><strong>①定义</strong></p><blockquote><p><strong>声明格式</strong>：<code>struct 结构类型名称 结构名</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 结构变量是标量类型，所以相同的结构变量可以相互赋值</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 将结构定义在一个头文件中，使用include包含即可</div><pre class="line-numbers language-none"><code class="language-none">struct [结构类型名称]{/*每个成员的类型和名字*/结构成员表;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以使用typedef关键字为结构定义新的名字</div><blockquote><p><strong>声明格式</strong>：<code>结构类型名称 结构名</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">typedef struct{结构成员表(每个成员的类型和名字);}[结构类型名称];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②结构的访问</strong></p><blockquote><p><strong><code>.</code>操作符</strong>：<code>结构名.成员名</code></p></blockquote><blockquote><p><strong><code>-&gt;</code>操作符</strong>：<code>对应结构指针-&gt;成员名</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这两个操作符优先级相同，比*和[]高，结合性从左向右</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当结构需要作为函数参数时，可以传递该结构的指针，并使用-&gt;访问成员，效率较高</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 假设px是结构x的指针，px指向的地址和结构第一个成员的地址是一样的，但是*px代表的是整个结构</div><p><strong>③初始化</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 结构体的初始化也分为静态变量和动态变量两种，各个成员按照对应的规则初始化</div><blockquote><p><strong>整体赋值</strong>：<code>x1.a = {10,'x',1.0}</code></p></blockquote><blockquote><p><strong>成员赋值</strong>：<code>x1.a = 10</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">typedef struct {int a;char b;float c;}X;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④结构体的内存分配</strong></p><blockquote><p><strong>编译器</strong>按照<strong>成员列表顺序</strong>给<strong>每个成员</strong>分配内存</p></blockquote><blockquote><p><code>sizeof()</code>可以得到一个结构的<strong>整体长度</strong>，<code>offsetof</code>可以确定<strong>结构中某个成员</strong>的<strong>偏离结构存储起始位置的字节数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当成员的存储需要满足正确的边界对齐条件，结构的起始位置必须满足成员中边界要求最严格的对齐条件</div><blockquote><p>假设<strong>一台机器</strong>的<strong>整型值长度</strong>为<strong>4字节</strong>，且要求其<strong>起始存储位置</strong>必须能<strong>被4整除</strong>，则<strong>结构</strong><code>X</code>在<strong>内存中</strong>的<strong>存储情况</strong>如下</p></blockquote><pre class="line-numbers language-none"><code class="language-none">struct X1{char a;int b;char c;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 成员之间会出现未填充的内存空间</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 对边界要求最严格的成员应该首先出现，这样可以节省内存</div><pre class="line-numbers language-none"><code class="language-none">struct X2{int b;char a;char c;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/C_3.png" alt="结构的存储"></p><h4 id="4-2结构的引用"><a href="#4-2结构的引用" class="headerlink" title="4.2结构的引用"></a>4.2结构的引用</h4><p><strong>①结构的自引用</strong></p><blockquote><p>结构<strong>内部成员为自己</strong>本身是<strong>非法</strong>的，但是可以<strong>包含自己的指针类型</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因为结构在定义时内存大小是不确定的，而结构指针的内存大小在结构创建前就已经确定</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不能使用之前没有定义的结构标签</div><pre class="line-numbers language-none"><code class="language-none">//非法，因为在声明next成员时，Node还有没被声明typedef struct{  ElemType data;  struct Node *next;}Node;//合法typedef struct Node{  ElemType data;  struct Node *next;}Node;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②结构之间的引用</strong></p><blockquote><p>当需要定义几种之间<strong>存在联系</strong>的结构，可以采用<strong>不完整声明</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如下，A中不能以B为成员，只能以B的指针为成员，因为不完整声明导致B的大小不能确定</div><pre class="line-numbers language-none"><code class="language-none">struct B; //B的不完整声明struct A{struct *B;};struct B{struct A;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3位段"><a href="#4-3位段" class="headerlink" title="4.3位段"></a>4.3位段</h4><p><strong>①定义</strong></p><blockquote><p>一种<strong>特殊的结构</strong>，<strong>成员</strong>必须是<code>int</code>、<code>signed</code>、<code>unsigned</code>类型，<strong>成员名后面</strong>是<strong>一个冒号</strong>和<strong>一个整数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 整数表示该成员占用的位的数目</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 位段可以将长度为奇数的数据包装在一起，并且可以访问一个整型值的部分内容</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> signed和unsigned声明位段成员比较好，如果将位段声明为int类型，被解释为有符号数还是无符号数由编译器决定</div><pre class="line-numbers language-none"><code class="language-none">struct WeiDuan{unsigned a : 7;unsigned b : 6;unsigned c : 19;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②位段的移植性问题</strong></p><blockquote><p>很多<strong>编译器</strong>将<strong>位段成员</strong>的<strong>长度</strong>限制在<strong>一个整型值</strong>之内，<strong>32位机器可以使用</strong>的位段声明可能在<strong>16位机器无法使用</strong></p></blockquote><blockquote><p><strong>位段的内存</strong>是<strong>从左向右</strong>分配还是<strong>从右向左</strong>分配<strong>由机器决定</strong></p></blockquote><blockquote><p>当位段的<strong>总位数</strong>不是<strong>8的倍数</strong>时，其<strong>内存分配</strong>是否要<strong>边界对齐</strong>取决于<strong>编译器</strong></p></blockquote><h4 id="4-4联合"><a href="#4-4联合" class="headerlink" title="4.4联合"></a>4.4联合</h4><p><strong>①定义</strong></p><blockquote><p>联合<strong>各个成员共用</strong>内存中的<strong>位置以及数据</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当联合的某个成员被访问时，则将该联合所在位置的位以该成员类型解释被访问</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当联合中各个成员具有不同的长度，联合的长度就是它最长成员的长度</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当成员之间大小相差太大时，可以将联合的成员修改为不同数据类型的指针，这样就不会造成空间浪费</div><pre class="line-numbers language-none"><code class="language-none">union{float f;int i;}fi;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②初始化</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 联合变量的初始值只有一个，且必须是联合第一个成员类型的数据</div><pre class="line-numbers language-none"><code class="language-none">union{int a;float b;char c[4];}x = {5};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-内存操作"><a href="#5-内存操作" class="headerlink" title="5.内存操作"></a>5.内存操作</h3><h4 id="5-1动态内存分配"><a href="#5-1动态内存分配" class="headerlink" title="5.1动态内存分配"></a>5.1动态内存分配</h4><p><strong>①<code>malloc()</code></strong></p><blockquote><p><strong>概述</strong>：从<strong>堆</strong>中提取一块<strong>连续的内存</strong>，并返回一个<strong>指向这块内存的指针</strong>，如果<strong>没有合适的内存</strong>则返回<strong>NULL</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这块内存没有被初始化</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> malloc()返回内存的起始位置始终满足边界对齐条件</div><blockquote><p><strong>格式</strong>：<code>p = malloc（size）;</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> malloc()返回值是void *，size为需要分配的字节数，其类型是size_t，一个无符号类型</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以将size替换为n*sizeof（数据类型），n为数量，还可以提高程序的可移植性</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> C语言中，void*可以赋值给其他类型指针，但是在其他语言如C++中不行，故最好在前面加一个强制类型转换</div><p><strong>②<code>calloc()</code></strong></p><blockquote><p><strong>概述</strong>：和<code>malloc</code>一样用于<strong>分配内存</strong>，但是<code>calloc</code>会将内存内<strong>所有元素初始化为0</strong></p></blockquote><blockquote><p><strong>格式</strong>：<code>p = calloc(num,size);</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中num为元素的个数，size为每个元素的大小，类型均为size_t</div><p><strong>③<code>realloc()</code></strong></p><blockquote><p><strong>概述</strong>：<strong>修改</strong>一个<strong>已经分配</strong>的<strong>内存块的大小</strong>，<strong>新增加的内存</strong>添加到<strong>原先内存块</strong>的<strong>尾部</strong>，如果用于<strong>缩小原来的内存块</strong>，则将<strong>尾部</strong>的内存块<strong>释放</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 新增内存没有被初始化</div><blockquote><p><strong>格式</strong>：<code>p = realloc(ptr,size);</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其中ptr是需要调整大小的指针，size是调整后内存的大小</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若原先的内存块大小无法改变，则realloc会重新划分一块内存，并释放原来的内存，所以要使用realloc返回的指针</div><p><strong>④<code>free()</code></strong></p><blockquote><p><strong>概述</strong>：当<strong>分配的内存不再使用</strong>时，需要使用<code>free()</code>将其<strong>释放</strong></p></blockquote><blockquote><p><strong>格式</strong>：<code>free (p)</code></p></blockquote><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 动态分配得到的指针是变量，但最好不要修改，因为最后还需要根据其释放掉对应内存块</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以构建该指针的副本对内存进行操作</div><p><strong>⑤常见错误</strong></p><blockquote><p>对<code>NULL</code>指针/<strong>非动态分配</strong>的指针使用<code>free()</code>进行<strong>释放</strong></p></blockquote><blockquote><p>对<strong>分配的内存</strong>操作时<strong>越界</strong></p></blockquote><blockquote><p>释放<strong>动态内存的一部分</strong></p></blockquote><blockquote><p><strong>访问</strong>一块<strong>已经被释放的内存</strong>，如当<strong>内存分配指针被备份</strong>时</p></blockquote><blockquote><p>内存释放<strong>不及时</strong>，导致<strong>内存泄漏</strong></p></blockquote><h4 id="5-2内存操作函数"><a href="#5-2内存操作函数" class="headerlink" title="5.2内存操作函数"></a>5.2内存操作函数</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 内存操作函数接收和返回的参数都是void*，且会以字节规定操作的内存长度</div><blockquote><p><code>memcpy()</code>：<strong>直接复制一块内存中</strong>数据到<strong>另一块内存</strong>中</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 操作的两块内存不能重叠</div><blockquote><p><code>memmove()</code>：类似于<code>memcpy()</code>，但是<code>memmove()</code>在<strong>转移时</strong>会经过一块<strong>临时内存</strong></p></blockquote><blockquote><p><code>memcmp()</code>：按照<strong>无符号字符逐字节比较</strong>两块内存的内容</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 不能用于比较非单字节数据</div><blockquote><p><code>memchr()</code>：查找某块内存<strong>某个字符第一次出现</strong>的位置</p></blockquote><blockquote><p><code>memset()</code>：将一段内存<strong>都设置</strong>为<strong>某个字符</strong></p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 《C和指针》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记（一）</title>
      <link href="/2023/12/10/c-yu-yan-xue-xi-bi-ji-yi/"/>
      <url>/2023/12/10/c-yu-yan-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言学习笔记（一）"><a href="#C语言学习笔记（一）" class="headerlink" title="C语言学习笔记（一）"></a>C语言学习笔记（一）</h1><h2 id="C语言启蒙"><a href="#C语言启蒙" class="headerlink" title="C语言启蒙"></a>C语言启蒙</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1C语言程序框架"><a href="#1-1C语言程序框架" class="headerlink" title="1.1C语言程序框架"></a>1.1C语言程序框架</h4><p><strong>①预处理命令</strong></p><blockquote><p><code>#include &lt;xx.h&gt;</code>：将<strong>对应文件内容</strong>逐字写到<strong>对应位置</strong>，<strong>常用的库</strong>有<code>stdio.h</code>和<code>stdlib.h</code></p></blockquote><blockquote><p><code>#define [变量] [值]</code>：将<strong>宏变量</strong>替换为<strong>对应值</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> define还可定义宏，暂不介绍</div><p><strong>②空白</strong></p><blockquote><p><strong>概述</strong>：主要有<strong>换行</strong>、<code>tab</code>和<strong>空格键</strong>，使得程序更加<strong>美观</strong></p></blockquote><p><strong>③注释</strong></p><blockquote><p><strong>单行注释</strong>：以<code>//</code>开始、以<strong>换行符</strong>结束</p></blockquote><blockquote><p><strong>多行注释</strong>：以<code>/*</code>开始，以<code>*/</code>结束</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 对于多行注释内的每一行，以*开头指示其也为注释，这不是语法规定，而是一种编程风格</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 多行注释不能嵌套，第一个/*到第一个*/之间都视为注释</div><blockquote><p><strong>预处理注释</strong>：用于注释<strong>包含注释</strong>的代码块</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>  statement<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>④函数声明</strong></p><blockquote><p><strong>概述</strong>：告诉<strong>编译器</strong>调用函数的<strong>特征</strong>，以便于<strong>调用该函数</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果一些函数声明经常需要使用，可以将他们的函数声明写到一个头文件中，再调用#include宏将该头文件写入</div><p><strong>⑤main函数</strong></p><blockquote><p><strong>概述</strong>：程序执行的<strong>起点</strong>和<strong>终点</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 程序无误时返回0，否则返回其他非0值，用于指明错误类型，由系统定义，在errno头文件中</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> Unix系统中，可以采用echo $?查看程序返回状态</div><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  statement<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2C程序内存分布"><a href="#1-2C程序内存分布" class="headerlink" title="1.2C程序内存分布"></a>1.2C程序内存分布</h4><blockquote><p><strong>代码段</strong>：存放<strong>程序执行代码</strong>的内存区域，也包括一些<strong>只读的常量</strong>，在<strong>程序运行前</strong>就已经确定</p></blockquote><blockquote><p><strong>初始化数据段</strong>：存放<strong>已初始化的全局变量</strong>，在进程运行时<strong>静态分配</strong></p></blockquote><blockquote><p><strong>未初始化数据段</strong>：存放程序中<strong>未初始化的全局变量</strong>和<strong>静态变量</strong>，默认为<code>0</code>，在进程运行时<strong>静态分配</strong></p></blockquote><blockquote><p><strong>栈</strong>：存放<strong>自动变量</strong>以及<strong>函数调用时所需的信息</strong>，按内存地址<strong>由高到低</strong>扩张，最大长度<strong>编译时确定</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每次函数调用，都会创建一个新的栈帧存放函数返回地址、寄存器的值</div><blockquote><p><strong>堆</strong>：可<strong>自由申请</strong>的空间，按内存地址<strong>由低到高</strong>方向扩张，其长度由<strong>系统内存/虚拟内存上限</strong>决定，通常在堆中进行<strong>动态存储分配</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 进程的每个线程都会有自己的栈，但是堆空间是共用的。</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 自动变量因为其地址只有在其创建时确定，故其缺省情况下的初始值是垃圾</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/C_2.png" alt="C程序内存分布"></p><h4 id="1-3-基本内置类型"><a href="#1-3-基本内置类型" class="headerlink" title="1.3 基本内置类型"></a>1.3 基本内置类型</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> C语言中，内置数据类型的尺寸再不同机器上有所差异，只规定了其最小值和大小关系，详细自行查询</div><p><strong>①引言</strong></p><blockquote><p><strong>比特</strong>：<strong>每个比特</strong>都存储<strong>一位0或1</strong></p></blockquote><blockquote><p><strong>字节</strong>：可<strong>寻址</strong>的最小单元，通常为<strong>8比特</strong></p></blockquote><blockquote><p><strong>字</strong>：<strong>存储</strong>的最小单元，通常为<strong>4字节</strong>或者<strong>8字节</strong></p></blockquote><p><strong>②整型</strong></p><blockquote><p><strong>分类</strong>：<strong>字符</strong><code>char</code>、<strong>短整型</strong><code>short</code>、<strong>整型</strong><code>int</code>、<strong>长整型</strong><code>long</code>等</p></blockquote><blockquote><p><strong>字符</strong>：大小和<strong>机器字节</strong>相同，通常是<strong>8位</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 还有一些字符类型用于扩展字符集，如char_32t位Unicode字符集服务</div><blockquote><p><strong>整数</strong>：<code>int</code>位数由<strong>编译器决定</strong>，通常是这种机器<strong>最为高效的位数</strong>，规定长度上<strong>长整型≥整型≥短整型</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> int、short至少为16位，long至少为32位，他们能表示的范围是不同的</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在C11的标准中追加stdint.h避免了位数的不确定性，如int32_t长度为4个字节，int8_t就是一个字节</div><p><strong>③浮点类型</strong></p><blockquote><p><strong>分类</strong>：<strong>单精度浮点数</strong><code>float</code>、<strong>双精度浮点数</strong><code>double</code>、<strong>扩展精度浮点数</strong><code>long double</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 也没有规定浮点类型的长度，仅规定长度上long double≥doubl≥float，通常float为一个字，double为两个字</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 只有某些机器支持扩展精度，通常采用double进行浮点数表示</div><p><strong>④有符号数和无符号数</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 仅对整型具有意义</div><blockquote><p>对于<code>int</code>、<code>short int</code>、<code>long int</code>来说，<strong>缺省情况</strong>下为<strong>有符号数</strong></p></blockquote><blockquote><p>对于<code>char</code>来说，分为<code>char</code>、<code>singed char</code>和<code>unsigned char</code>，其中<code>char</code>的带符号与否<strong>取决于编译器</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 为了提高程序的可移植性，需要将char限制为正，且只对显式声明为有符号数和无符号数的char进行数值运算</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 有符号数与无符号数进行运算，有符号数会被转化为无符号数，且结果也为无符号数</div><blockquote><p>若有符号数为<strong>正数</strong>，则转换后<strong>大小不变</strong>，若为<strong>负数</strong>，则相当于<strong>加上2^n</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 无符号数a、b相互比较时，应该使用a&gt;b，而不是a-b&gt;0，因为运算结果为无符号数，无符号数永远大于0</div><p><strong>④枚举类型</strong></p><blockquote><p><strong>格式</strong>：<code>enum 枚举类型名{枚举1,枚举2,枚举3…} ；</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如果不对枚举进行赋值，则枚举从0开始，依次增大1，如果对某些枚举复制，则没有被赋值的枚举比前者大1</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 本质上还是int，相当于被命名的int集合</div><p><strong>⑤字面值</strong></p><blockquote><p><strong>定义</strong>：<strong>没有赋予给变量</strong>的数据，有<strong>整型字面值</strong>、<strong>字符型字面值</strong>、<strong>字符串字面值</strong>和<strong>浮点数字面值</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 字面值的地址有编译器分配，且不能改变</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 字面值类型可以用前缀或者后缀修改字面值的数据类型</div><blockquote><p><strong>整型字面量</strong>：若其为<strong>十进制</strong>，则其为<strong>带符号数</strong>，若其为<strong>八/十六进制</strong>，则<strong>都有可能</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 缺省情况下，十进制整型字面值类型为能表示该字面量的尺寸最短类型，从int，long中选，八/十六进制类似</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 严格来说，整型字面值均为正值，-42表示给42整型字面值加上负号</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> short类型没有对应的字面值</div><blockquote><p><strong>浮点数字面值</strong>：<strong>缺省</strong>类型为<code>double</code></p></blockquote><blockquote><p><strong>字符/字符串型字面值</strong>：<strong>前者</strong>用<code>''</code>包围，<strong>类型</strong>为<code>char</code>，<strong>后者</strong>用<code>""</code>包围，为一<code>char</code><strong>数组</strong></p></blockquote><hr><h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h3><h4 id="2-1声明与定义"><a href="#2-1声明与定义" class="headerlink" title="2.1声明与定义"></a>2.1声明与定义</h4><p><strong>①格式</strong></p><blockquote><p><code>说明符 声明表达式列表</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 说明符用于指明变量的基本类型、存储类型和作用域；声明表达式用于命名变量并对其赋值</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 变量的声明可以理解为，变量通过声明表达式的运算得到说明符</div><blockquote><p>如<code>int a[]</code>可以理解为<strong>变量<code>a</code><strong>通过</strong>下标运算</strong>得到一个<strong>整数</strong>，则<code>a</code>就是一个<strong>数组</strong></p></blockquote><p><strong>②定义</strong></p><blockquote><p><strong>声明</strong>：<strong>表明</strong>变量的<strong>类型和名字</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若一源文件中只有变量的声明，则会去别的地方寻找该变量的定义</div><blockquote><p><strong>定义</strong>：为变量<strong>分配存储空间</strong>，还可为变量<strong>指定初始值</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对于int a;，如果a是全局变量的话就是声明，是局部变量的话就是定义，可以使用extern修饰表示声明</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在实际开发中，经常会在函数或变量定义之前就使用它们，这个时候就需要提前声明（extern）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 只要对变量赋值，就一定是定义变量，即使有extern修饰</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 变量可以声明多次，而只能定义一次</div><p><strong>③typedef</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 只要在变量声明前面加上typedef，就成了类型定义，对应变量名即称为新的类型名</div><blockquote><p>如<code>typedef int (*function_t) (int param);</code>，在这里<code>function_t</code>则成为了<strong>对应的函数指针的类型名</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 与define不同，define只是简单的替换</div><blockquote><p>如下，<code>a</code>被<strong>定义</strong>为一个<strong>字符指针</strong>，而<code>b</code>被<strong>定义</strong>为一个<strong>字符</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#define char* ptr_to_charptr_to_char a,b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 在进行句法分析的时候，typedef和存储类型指示符是等价的，故该关键词不能和static等存储类型指示符一起用</div><h4 id="2-2作用域"><a href="#2-2作用域" class="headerlink" title="2.2作用域"></a>2.2作用域</h4><blockquote><p><strong>代码块作用域</strong>：<strong>代码块中</strong>变量的作用域，<strong>于代码块开头开始，到代码块结尾结束</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 非嵌套的代码块，每个代码块的变量无法被另一个代码块访问，代码块之间变量隔离</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在ANSI C中，函数形参的作用域在函数最外层代码块内（动态变量）</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 嵌套的代码块中，同名变量会覆盖外层变量，包括全局变量</div><blockquote><p><strong>文件作用域</strong>：在<strong>代码块外</strong>声明的变量都具有<strong>文件作用域</strong>，从他们<strong>声明之处到所处源文件结尾</strong>都可以访问</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用include包含到该文件的变量属于文件作用域</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 也称为extern属性，缺省情况下相当于有extern修饰</div><blockquote><p><strong>原型作用域</strong>：只适用于<strong>函数原型（不是函数定义）</strong>中声明的参数名，只存在<strong>那个括号</strong>内</p></blockquote><blockquote><p><strong>函数作用域</strong>：只适用于语句标签，一个函数中所有<strong>语句标签必须唯一</strong></p></blockquote><h4 id="2-2链接属性（如果使用extern修饰局部变量的效果是什么？？？）"><a href="#2-2链接属性（如果使用extern修饰局部变量的效果是什么？？？）" class="headerlink" title="2.2链接属性（如果使用extern修饰局部变量的效果是什么？？？）"></a>2.2链接属性（如果使用extern修饰局部变量的效果是什么？？？）</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 变量的链接属性决定如何处理在不同文件中的同名变量</div><blockquote><p><strong><code>none</code><strong>：只能在其</strong>所在代码块中</strong>被访问。</p></blockquote><blockquote><p><strong><code>internal</code><strong>：</strong>同一个源文件</strong>中的所有同名变量都是同一个实体，可以在<strong>该源文件</strong>中被访问</p></blockquote><blockquote><p><strong><code>external</code><strong>：</strong>所有源文件</strong>的所有同名变量是<strong>同一个实体</strong>，可以<strong>被所有源文件访问</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在缺省情况下，在代码块外的链接属性为external，其余none</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 拥有extern属性的变量在单个源文件中，从头到尾都可以访问，在有多个源文件时，其他源文件也可以访问</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> external属性变量只是能被其他源文件访问，若要使用，还需要在该文件中声明该变量</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 在多个文件中定义同名的全局变量会导致链接错误</div><h4 id="2-3存储类型（静态变量和全局变量的区别？？？？）"><a href="#2-3存储类型（静态变量和全局变量的区别？？？？）" class="headerlink" title="2.3存储类型（静态变量和全局变量的区别？？？？）"></a>2.3存储类型（静态变量和全局变量的区别？？？？）</h4><blockquote><p><strong>静态变量</strong>：在<strong>代码块之外</strong>声明的变量</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在程序运行之前创建，在程序的整个执行期间始终存在</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 无法改变静态变量的存储类型</div><blockquote><p><strong>动态变量</strong>：在<strong>代码块内</strong>声明的变量</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 存储在堆栈中，当程序执行流到达该代码块时，才被创建，执行流离开该代码块时，该变量被销毁</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 当该代码块重复执行时（比如循环）内存位置不固定</div><blockquote><p><strong>寄存器变量</strong>：使用<code>register</code>可以将<strong>动态变量</strong>转化为<strong>寄存器变量</strong>，<strong>访问效率更高</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 寄存器变量是一种请求，编译器可能忽略该请求，同时，当寄存器数量不足时，寄存器变量会为自动变量</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以把高频使用的变量声明为寄存器变量，寄存器变量的生命周期和动态变量相同</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 只要声明为寄存器变量，就不能对其取址</div><h4 id="2-4修饰符"><a href="#2-4修饰符" class="headerlink" title="2.4修饰符"></a>2.4修饰符</h4><p><strong>①<code>static</code></strong></p><blockquote><p>对<strong>缺省属性</strong>为<code>extern</code>属性的的变量，<code>static</code>将改变其<strong>链接属性</strong>，变为<code>internal</code></p></blockquote><blockquote><p>对<strong>缺省属性</strong>为<code>none</code>属性的的变量，<code>static</code>将改变其<strong>存储类型</strong>，由动态变量变为<strong>静态变量</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 用static将动态变量转化为静态变量，其作用域不会改变，原先的值也不会改变</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> static不能修饰形参</div><p><strong>②<code>extern</code></strong></p><blockquote><p>可以给<strong>变量</strong>赋予<code>external</code>链接属性（只需要在声明处添加即可），则<strong>所有源文件都能访问该变量</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若变量已经有链接属性，则extern修饰符无效</div><p><strong>③<code>const</code></strong></p><blockquote><p>使得变量被<strong>初始化后不得被更改</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> const只能用于允许使用变量的地方，不允许使用变量的地方比如数组的大小，可以使用define</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 函数中被const修饰的形参获得对应的实参的值后无法被改变，当你不希望函数改变该值时，可以使用const修饰该形参</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 要注意const修饰的变量是什么，尤其是修饰指针时</div><pre class="line-numbers language-none"><code class="language-none">int const *a：指针指向的值不能被修改int * const a：指针无法被修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-语句"><a href="#3-语句" class="headerlink" title="3.语句"></a>3.语句</h3><h4 id="3-1基本语句"><a href="#3-1基本语句" class="headerlink" title="3.1基本语句"></a>3.1基本语句</h4><blockquote><p><strong>空语句</strong>：本身<strong>只包含一个分号</strong>，用于<strong>不需要操作但是语法要求出现一条完整语句</strong>的场合</p></blockquote><blockquote><p><strong>表达式语句</strong>：由<strong>变量</strong>和<strong>操作符</strong>构成，如<code>1+1</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个表达式语句都有其返回值，但是没有其他操作的情况下，该返回值不被保存</div><blockquote><p><strong>代码块</strong>：被<strong>一对花括号</strong>囊括的<strong>语句</strong>，在语法上相当于<strong>一条语句</strong></p></blockquote><h4 id="3-2条件语句"><a href="#3-2条件语句" class="headerlink" title="3.2条件语句"></a>3.2条件语句</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 出现if嵌套时，else从句属于最靠近他的不完整的if从句</div><pre class="line-numbers language-none"><code class="language-none">if （expression）{statement;}else if (expression){statement;}else {statement；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3循环语句"><a href="#3-3循环语句" class="headerlink" title="3.3循环语句"></a>3.3循环语句</h4><p><strong>①<code>while</code>循环</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> expression的结果必须是整数，C语言中没有布尔类型，非零值为真，零值为假，缺省情况下，真值为1，假值为0</div><pre class="line-numbers language-none"><code class="language-none">while （expression）{statement;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②<code>for</code>循环</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 初始化语句在循环一开始执行，条件语句在每一次循环开始之前执行，调整语句在每一次循环后执行</div><pre class="line-numbers language-none"><code class="language-none">for （初始化语句; 条件语句;调整语句）{statement;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③<code>do while</code>循环</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 与while语句相比，do while语句会先执行语句然后再判断条件是否成立</div><pre class="line-numbers language-none"><code class="language-none">do{statement;}while(expression);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>④<code>switch</code>循环</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当执行到匹配到case语句后，执行流会一直往下直到switch语句结束，包括default子句</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在每个case语句下添加break及时退出</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在循环中可以使用break语句，用于永久终止循环，使用continue语句终止当前的循环</div><pre class="line-numbers language-none"><code class="language-none">switch（expression）{    case expression_n：  statement；      break；    default：      statement；      break；}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-4跳转语句"><a href="#3-4跳转语句" class="headerlink" title="3.4跳转语句"></a>3.4跳转语句</h4><blockquote><p>当执行到<strong>跳转语句</strong>时，会<strong>跳转</strong>到<strong>标号</strong>处</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 标签就是标识符后面加一个冒号</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 非必要不使用goto语句</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以通过goto语句跳出嵌套循环</div><pre class="line-numbers language-none"><code class="language-none">biaoqian:goto biaoqian;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-操作符"><a href="#4-操作符" class="headerlink" title="4.操作符"></a>4.操作符</h3><h4 id="4-1基本操作符"><a href="#4-1基本操作符" class="headerlink" title="4.1基本操作符"></a>4.1基本操作符</h4><p><strong>①算术操作符</strong></p><blockquote><p><strong>加</strong><code>+</code>、<strong>减</strong><code>-</code>、<strong>乘</strong><code>*</code>、<strong>除</strong><code>/</code>、<strong>取余</strong><code>%</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> /操作符只有当两个操作数都为整型时，才做整型运算，%只能接受两个整型</div><p><strong>②关系操作符</strong></p><blockquote><p><strong>大于</strong><code>&gt;</code>、<strong>小于</strong><code>&lt;</code>、<strong>大于等于</strong><code>&gt;=</code>、<strong>小于等于</strong><code>&lt;=</code>、<strong>不等于</strong><code>!=</code>、<strong>等于</strong><code>==</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意==和赋值符号=的区别</div><p><strong>③逻辑操作符</strong></p><blockquote><p><strong>与</strong><code>&amp;&amp;</code>、<strong>或</strong><code>||</code>、<strong>异或</strong><code>^</code>、<strong>非</strong><code>！</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 短路求值：通过第一个操作数能判断结果就不会判断后面的操作数，且要求操作数均为整数</div><p><strong>④赋值操作符</strong></p><blockquote><p><strong>基本赋值操作符</strong>：<code>=</code>，<strong>赋值表达式语句</strong>的<strong>返回值</strong>是<strong>左操作数的新值</strong>，所以可以<strong>连等</strong><code>a=b=10</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在复制操作符左边的标识符称为左值，右边的称为右值</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 左值相当于一个容器，可以储存结果的地方，一个内存位置，右值则是一个可以被储存的数据</div><blockquote><p><strong>变量</strong><code>a</code>可以表示一个<strong>容器</strong>，也可以表示一个<strong>数据</strong>，<code>a+1</code>只能是一个<strong>数据</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 左值是一个确切知道地址的容器</div><blockquote><p><strong>复合赋值符</strong>：比如<code>+=</code>，<code>a += （expression）</code>代表<code> a = a+（expression）</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当a比较复杂或者其中有需要编译器实时计算的项，采用复合赋值符可以提高效率</div><p><strong>⑤逗号操作符</strong></p><blockquote><p><code>expression1,expression2,...,expressionN</code>,<code>expression</code>都会被求值，但是<strong>整个表达式的值</strong>是<strong>最后一个表达式</strong>的值</p></blockquote><p><strong>⑥条件操作符</strong></p><blockquote><p><code>expression1 ？ expression2 ： expression3</code>：如果<code>expression1</code>值为<strong>真</strong>，则该<strong>表达式结果</strong>为<code>expression2</code>，反之为<code>expression3</code></p></blockquote><p><strong>⑦单目操作符</strong></p><blockquote><p><strong>取址</strong><code>&amp;</code>、<strong>引用</strong><code>*</code>、<strong>判断类型长度</strong><code>sizeof()</code>、<strong>求补码</strong><code>~</code>、<strong>递增/减</strong><code>++/--</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ++/--为前缀时，先递加/减，再进行相关操作，为后缀时，先进行相关操作，再递加/减</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 强制类型转换的优先级非常高</div><h4 id="4-2位操作符"><a href="#4-2位操作符" class="headerlink" title="4.2位操作符"></a>4.2位操作符</h4><p><strong>①移位操作符</strong></p><blockquote><p><strong>左移<code>&lt;&lt;</code><strong>：</strong>左边</strong>的几位被<strong>丢弃</strong>，<strong>右边</strong>多出来的几位<strong>由0补齐</strong></p></blockquote><blockquote><p><strong>右移<code>&gt;&gt;</code><strong>：有</strong>两种</strong>移位方案，一种是<strong>逻辑移位</strong>，用<strong>0</strong>补充，一种是<strong>算数移位</strong>，使用<strong>符号位（最高位）</strong>补全</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对于无符号数，采用的都是逻辑移位，对于有符号数，则取决于编译器，这可能会影响程序的移植性</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 两边的操作数都必须是整型，需要移动的位数必须正数，且不能超过被操作数的位数</div><p><strong>②逻辑位操作符</strong></p><blockquote><p>对操作数的<strong>各个位</strong>执行<strong>逻辑运算</strong>，<strong>与</strong><code>&amp;</code>、<strong>或</strong><code>|</code>、<strong>异或</strong><code>^</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 位操作符优先级比移位操作符高</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> value = value | 1 &lt;&lt; bit_number;即将bit_number对应位置转换为1</div><h4 id="4-3类型转换"><a href="#4-3类型转换" class="headerlink" title="4.3类型转换"></a>4.3类型转换</h4><p><strong>①隐式类型转换</strong></p><blockquote><p>当<strong>操作数</strong>为<strong>字符型</strong>和<strong>短整型</strong>时，使用之前会先被<strong>转化为普通整型</strong>再进行运算，结果是<strong>普通整型</strong>，若将<strong>结果</strong>存储到<strong>字符型</strong>和短<strong>整型</strong>中，则会<strong>截短</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在C中的整型算数运算总是以缺省整型类型精度进行的</div><p><strong>②算数转换</strong></p><blockquote><p>当<strong>多操作数</strong>进行<strong>运算</strong>时，且操作数属于<strong>不同的类型</strong>，则会<strong>将精度低的数据类型转化为精度高的数据类型进行运算</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 防止数据丢失</div><p><strong>③强制类型转换</strong></p><blockquote><p><code>(类型) [操作数/表达式]</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在16位机器上，第三个算式可能会产生溢出，可以在运算前将 a、b中的一个或者两个转化为long即可</div><pre class="line-numbers language-none"><code class="language-none">int a = 5000；int b = 25；long c = a*b；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 强制类型转换可能会导致精度的损失，因为位数不同</div><h4 id="4-4优先级和结合性"><a href="#4-4优先级和结合性" class="headerlink" title="4.4优先级和结合性"></a>4.4优先级和结合性</h4><p><strong>①优先级</strong></p><blockquote><p>标识<strong>运算符</strong>在表达式中的<strong>运算顺序</strong></p></blockquote><p><strong>②结合性</strong></p><blockquote><p>当一个<strong>运算对象两侧</strong>运算符的<strong>优先级别相同时</strong>, <strong>运算对象</strong>与<strong>运算符</strong>的<strong>结合顺序</strong></p></blockquote><blockquote><p>如<code>*a++</code>，其中<code>*</code>和<code>++</code>为<strong>同一优先级</strong>，结合性为<strong>从右到左</strong>，先进行<code>a++</code>，再进行<code>*(a++)</code></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 表达式的求值顺序不一定完全按照优先级和结合性，面对有副作用的操作符需要小心</div><blockquote><p>如<code>c + --c</code>，<code>c</code><strong>是否</strong>在执行了<code>--c</code>后再<strong>与其相加</strong>,结果<strong>取决于编译器</strong></p></blockquote><p>分配和释放效率：栈是一块较小的内存，分配由编译器自动完成；而堆内存相对更大，可以在代码中动态分配，更容易碎片化。因此，堆上的分配和释放操作通常比栈上的慢。<br>大小限制：栈内存相对较小，堆的大小一般受限于可用内存。因此堆更加适合存储大型数组。<br>灵活性：栈上的数组的大小需要在编译时确定，而堆上的数组的大小可以在运行时动态确定。</p><p>大多为 8 字节或 4 字节。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 《C和指针》 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核设计与实现（一）</title>
      <link href="/2023/12/10/linux-nei-he-she-ji-yu-shi-xian-yi/"/>
      <url>/2023/12/10/linux-nei-he-she-ji-yu-shi-xian-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内核设计与实现（一）"><a href="#Linux内核设计与实现（一）" class="headerlink" title="Linux内核设计与实现（一）"></a>Linux内核设计与实现（一）</h1><h2 id="Linux内核基础"><a href="#Linux内核基础" class="headerlink" title="Linux内核基础"></a>Linux内核基础</h2><h3 id="1-Unix和Linux"><a href="#1-Unix和Linux" class="headerlink" title="1.Unix和Linux"></a>1.Unix和Linux</h3><p><strong>1.1Unix系统特点</strong><br>①简洁：只有几百个系统调用且设计目的简单明确<br>②一切皆文件：对数据和设备的操作可以通过同一套接口完成<br>③C语言编写：移植能力强<br>④进程创建十分迅速，提供了一套十分简单稳定的进程间通信元语<br>#Linux是类Unix系统，没有直接使用Unix源码，但是<strong>设计理念一致</strong>且保证了<strong>应用程序编程接口的一致</strong><br><strong>1.2Linux和Unix的差异</strong><br>①Linux支持动态加载和卸载内核模块<br>②Linux支持对称多处理（SMP）机制<br>③linux内核可以抢占<br>④Linux不区分进程和线程<br>⑤Linux提供具有设备类的面向对象的设备模型、热插拔事件</p><h3 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2.基本概念"></a>2.基本概念</h3><p><strong>2.1内核空间</strong>：内核等相关程序运行的空间，拥有<strong>受保护的内存空间</strong>和访问硬件的<strong>所有权利</strong><br><strong>2.2用户空间</strong>：应用程序执行的空间，应用程序在用户空间只能看到系统允许他们使用的部分系统资源，只能使用某些特定的系统功能，不能直接访问硬件，也不能访问内核划分给<strong>其他应用程序的内存空间</strong><br>#当内核运行时，系统以内核态进入内核空间，当用户程序运行时，系统以用户态进入用户空间<br><strong>2.3系统调用</strong>：应用程序通过系统调用陷入内核，应用程序调用库函数，库函数通过系统调用接口调用<strong>内核子系统/设备驱动程序</strong><br><strong>2.4单内核</strong>：内核以<strong>单个静态二进制文件</strong>的形式存放在磁盘中，运行在一个<strong>单独的地址空间</strong>上，内核之间的通信耗时可忽略不计<br><strong>2.5微内核</strong>：内核功能被划分为<strong>多个独立的过程</strong>，每个过程叫做一个<strong>服务器</strong>，每个服务器独立运行在<strong>各自的地址空间</strong>上，除了强烈要求特权服务的服务器运行在特权模式下，其他服务器运行在<strong>用户空间</strong>，每个服务器采用<strong>进程间通信机制</strong>沟通，可靠性更强，一个服务器出现问题不会祸及其他服务器，且服务器<strong>可以加载也可以卸载</strong><br>#Linux是<strong>单内核</strong>，但是汲取了微内核的精髓——模块化设计、抢占式内核、支持内核线程及动态装载内核模块</p><h3 id="3-Linux版本"><a href="#3-Linux版本" class="headerlink" title="3.Linux版本"></a>3.Linux版本</h3><p><strong>[主版本号].[从版本号].[修订版本号].[稳定版本号]</strong><br>#稳定版本号是偶数则是稳定版，反之为开发版</p><h3 id="4-简述编译内核"><a href="#4-简述编译内核" class="headerlink" title="4.简述编译内核"></a>4.简述编译内核</h3><p><strong>4.1获得内核源码</strong>：在<a href="http://www.kernel.org/">Linux内核官网</a>下载<br>①使用git clone和git pull获得内核源码<br>②自行下载安装，有bzip2和gzip两种形式，其中bzip2是默认和首选下载格式，采用tar命令解压，解压后的源码在linux-x.y.z.目录下（x.y.z.为Linux版本号）<br>③安装内核补丁进行版本的更迭<br><strong>4.2安装内核源码</strong>：系统本身的内核源码<strong>位于/usr/src/linux目录</strong>下，但是<strong>不能将该源码树用于开发</strong>，因为<strong>编译C库</strong>所用的内核版本链接到该棵树。应该建立<strong>自己的主目录</strong>，仅仅以<strong>root身份</strong>安装新内核到该目录，系统本身目录不进行任何更改<br><strong>4.3配置内核</strong>：将自己需要的<strong>特定功能和驱动程序</strong>编进内核（根目录下.config文件），常见内核配置工具如下<br>①make config<br>#遍历所有配置项，要求用户选择选项，耗时长，不推荐<br>②make menuconfig或者make gconfig<br>#图形界面，推荐<br>③make defconfig<br>#基于默认配置为你的体系结构创建一个配置<br>④make oldconfig<br>#根据.config文件生成/更新配置<br>#配置选项CONFIG_IKCONFIG_PROC将<strong>完整压缩</strong>的配置文件存放在/proc/config.gz下，可以采用zcat /proc/config.gz &gt; .config及make oldconfig克隆当前配置<br><strong>4.4编译内核</strong><br>①编译内核：make<br>②减少编译垃圾信息：make &gt; ../detritus或者make &gt; dev/null<br>#前者将编译信息重定向到该文件中，后者的/dev/null是个永无返回值的黑洞，但是警告和错误信息还是会打印出来<br>③将编译过程拆分为多个并行的作业：make -jn<br>#其中n为作业数，一般<strong>每个处理器上衍生出一两个作业</strong><br><strong>4.5安装新内核</strong>：根据启动引导工具的说明操作即可</p><h3 id="5-内核开发的特点"><a href="#5-内核开发的特点" class="headerlink" title="5.内核开发的特点"></a>5.内核开发的特点</h3><p><strong>5.1不能访问C库及标准C头文件</strong>:对于内核来说，C库<strong>太大且低效</strong>了<br>#不过大部分常用的C库函数在内核中已经得到了实现，比如string库对应&lt;linux/string.h&gt;<br>#基本的头文件位于内核源码树<strong>顶级目录的include目录</strong>下<br>#体系结构相关头文件位于arch/[architecture]/include/asm目录下,以asm为前缀，如&lt;asm/ioctl.h&gt;<br><strong>5.2必须使用GUN C</strong><br><strong>5.3没有内存保护机制</strong>：当内核自身发生了内存错误会导致oops<br>#内核中的内存<strong>不分页</strong><br><strong>5.4不要轻易使用浮点数</strong>：在内核中使用浮点数，不仅仅要人工保存和回复浮点寄存器，还需要一些繁琐的操作<br><strong>5.5容积小且固定的栈</strong>：内核栈大小随体系结构改变<br><strong>5.6同步和并发</strong>：内核的许多特性要求可以并发的访问共享数据，这就可能产生竞争<br><strong>5.7可移植性的重要性</strong></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git及其应用</title>
      <link href="/2023/12/10/git-ji-qi-ying-yong/"/>
      <url>/2023/12/10/git-ji-qi-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git应用"><a href="#Git应用" class="headerlink" title="Git应用"></a>Git应用</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1Git概述"><a href="#1-1Git概述" class="headerlink" title="1.1Git概述"></a>1.1Git概述</h4><blockquote><p>一个<strong>分布式版本控制系统</strong>，<strong>版本控制</strong>即记录文件<strong>修改历史</strong>，便于<strong>版本切换</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 很少通过拷贝历史版本进行版本控制，因为太占用存储空间</div><h4 id="1-2分布式与集中式"><a href="#1-2分布式与集中式" class="headerlink" title="1.2分布式与集中式"></a>1.2分布式与集中式</h4><blockquote><p><strong>集中式</strong>：有一个<strong>单一的集中管理的服务器</strong>，从中下载代码，修改后提交</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 便于管理，但是当中央服务器故障，则无法提交更新</div><blockquote><p><strong>分布式</strong>：分别有<strong>本地库（个人电脑）</strong>和<strong>远程库（大型代码托管中心）</strong>，从远程库上<strong>克隆</strong>代码进行修改</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在本地库和远程库上都可以进行版本控制</div><h4 id="1-3工作机制"><a href="#1-3工作机制" class="headerlink" title="1.3工作机制"></a>1.3工作机制</h4><blockquote><p><strong>代码托管中心</strong><br><strong>局域网</strong>：<code>GitLab</code><br><strong>互联网</strong>：<code>GitHub</code>、<code>Gitee</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 代码只有一份，通过保存修改历史保存版本</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 提交到本地库和远程库的代码无法单独删除</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/git_1.png" alt="git工作机制"></p><h3 id="2-Git基本操作"><a href="#2-Git基本操作" class="headerlink" title="2.Git基本操作"></a>2.Git基本操作</h3><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在git bash中进行操作，可以使用linux命令和操作，如tab补全、ctrl+滚轮调整大小等</div><h4 id="2-1设置用户签名"><a href="#2-1设置用户签名" class="headerlink" title="2.1设置用户签名"></a>2.1设置用户签名</h4><blockquote><p><strong>签名</strong>的作用是<strong>区分操作者身份</strong>，<strong>首次安装必须设置</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以在.gitconfig文件中查看是否设置成功，windows系统下位于C/用户/asus目录下</div><pre class="line-numbers language-none"><code class="language-none">git config --global user.name [用户名]git config --global user.email [用户邮箱]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-2工作流"><a href="#2-2工作流" class="headerlink" title="2.2工作流"></a>2.2工作流</h4><blockquote><p><code>git init</code>：使得<code>git</code>获得该文件夹的<strong>管理权</strong>，使得该文件夹变为<strong>工作区</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 会在该文件夹下创建一个.git文件夹</div><blockquote><p><code>git add [添加对象]</code>：将对象添加到<strong>暂存区</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用git add -A将所有改动添加</div><blockquote><p><code>git commit -m "[版本描述信息]" [提交对象]</code>：将对象提交到<strong>本地库</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若不指定提交对象，则将暂存区所有改动提交</div><h4 id="2-3查看状态"><a href="#2-3查看状态" class="headerlink" title="2.3查看状态"></a>2.3查看状态</h4><blockquote><p><code>git status</code>：查看<strong>分支</strong>以及<strong>该分支下显示未添加、未提交文件</strong>等信息</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> git的修改是先删除修改的那一行，然后重写，所以提示信息是一行新增，一行删除</div><blockquote><p><code>git reflog</code>：查看<strong>本地库的提交信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每次提交最前面的黄色字符串就是版本号</div><blockquote><p><code>git log</code>：在<code>git reflog</code>的基础上<strong>更加精细</strong>，有<strong>完整版的版本号</strong>以及<strong>提交者</strong>的等信息</p></blockquote><h4 id="2-4分支"><a href="#2-4分支" class="headerlink" title="2.4分支"></a>2.4分支</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 分支就是当时创建分支时对应对象的副本，不同的分支有不同的作用（程序员修改、运维测试和用户使用等）</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以并行推进多个版本功能开发，分支之间不会互相影响</div><blockquote><p><code>git branch -v</code>：<strong>查看</strong>分支</p></blockquote><blockquote><p><code>git branch [分支名]</code>：<strong>创建</strong>分支</p></blockquote><blockquote><p><code>git checkout [分支名]</code>：<strong>切换</strong>分支</p></blockquote><blockquote><p><code>git merge [分支名]</code>：将<strong>指定分支</strong>合并到<strong>当前分支</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 合并分支只会影响当前分支，对指定分支无影响，即将指定分支的对应版本提交到当前分支</div><h4 id="2-5合并冲突"><a href="#2-5合并冲突" class="headerlink" title="2.5合并冲突"></a>2.5合并冲突</h4><blockquote><p>假设在<code>master</code><strong>分支</strong>下新建了<code>test</code><strong>分支</strong>，分别对<strong>同一个文件修改并提交</strong>后，将<code>test</code>合并到<code>master</code>，可能会导致<strong>合并冲突</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 合并冲突：合并分支时，当两个分支在同一个文件的同一个位置有两套完全不同的修改，需要人为指定新代码内容</div><blockquote><p>一开始<code>master</code><strong>分支</strong>下有一个<code>test.txt</code>文件，创建<code>fix</code><strong>分支</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">//创建分支时test.txt代码1234567812345678<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>分别在<strong>两个分支下修改并提交</strong><code>test.txt</code>，随后将<code>fix</code><strong>分支</strong>合并到<code>master</code><strong>分支</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">//合并时master分支下test.txt文件12345678 abc12345678<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">//合并时fix分支下的test12345678 12345678 ABC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>发生<strong>合并冲突</strong>，在<code>master</code><strong>分支</strong>下打开<code>test.txt</code>文件，如下所示</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> git在冲突处显示两份代码的冲突部分，上面的是当前分支的修改，下面的是传入分支的修改</div><pre class="line-numbers language-none"><code class="language-none">//合并发生冲突，在master分支下打开test.txt文件&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD12345678 abc12345678=======12345678 12345678 ABC&gt;&gt;&gt;&gt;&gt;&gt;&gt; test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>手动修改冲突</strong>，<strong>保存</strong>文件随后将文件<strong>添加</strong>、<strong>提交</strong>即可解决冲突</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 手动修改冲突的宗旨就是保持冲突部分代码的行数不变，可以只采用某一个的修改，也可以同时采用</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 解决冲突时，提交时不能带文件名git commit -m "merge test"</div><pre class="line-numbers language-none"><code class="language-none">//仅仅采用当前分支12345678 abc12345678//仅仅采用指定分支12345678 12345678 ABC//同时采用两个的修改12345678 abc12345678 ABC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-6版本控制"><a href="#2-6版本控制" class="headerlink" title="2.6版本控制"></a>2.6版本控制</h4><blockquote><p><code>git reset --hard [版本号]</code>：将<strong>工作区的文件</strong>变为<strong>对应版本</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 版本控制本质上是控制HEAD指针和对应分支指针的指向，通过分支切换将HEAD指向不同的分支，通过reset修改对应分支执行其下不同的版本</div><blockquote><p><code>.git</code>文件夹<code>HEAD</code>文件记录了<code>HEAD</code><strong>当前指向分支</strong>,<code>refs/heads</code><strong>目录</strong>下记载<strong>各个分支</strong>的当前指向，如<code>master</code>文件记载了<code>master</code>的<strong>当前指向的版本号</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/git_2.png" alt="版本控制机制"></p><h3 id="3-Github远程库"><a href="#3-Github远程库" class="headerlink" title="3.Github远程库"></a>3.Github远程库</h3><h4 id="3-1免密登陆"><a href="#3-1免密登陆" class="headerlink" title="3.1免密登陆"></a>3.1免密登陆</h4><p><strong>①SSH密钥登陆</strong></p><blockquote><p><strong>密钥生成</strong>：<code>C/用户/asus</code><strong>目录</strong>下，在<code>git bash</code>中输入<code>ssh-keygen -t rsa -C [github邮箱]</code>，<strong>敲击三次回车</strong>，会创建<code>.ssh</code>目录，其下有<strong>公钥</strong>和<strong>私钥</strong></p></blockquote><blockquote><p><strong>密钥设置</strong>：在<strong>Github设置</strong>中的<code>SSH and GPG keys</code>添加<code>SSH key</code>，将<strong>公钥</strong>内容粘贴到<strong>对应位置</strong>即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个远程库都对应的HTTPS/SSH链接，其中SSH链接只有设置了公钥之后才能使用</div><p><strong>②口令登陆</strong></p><blockquote><p><code>github settings-&gt;develop settings-&gt;personal access tokens</code>生成<strong>登陆口令</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当使用账号密码登陆较难时，可以考虑使用口令登陆</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 口令在生成后最好立刻复制保存，因为界面一刷新就消失了，只能重新生成</div><h4 id="3-2工作流"><a href="#3-2工作流" class="headerlink" title="3.2工作流"></a>3.2工作流</h4><blockquote><p><code>git remote add [name] [HTTPS/SSH]</code>：<strong>保存远程库并命名，便于本地库识别</strong></p></blockquote><blockquote><p><code>git remote -v</code>：<strong>查看保存的远程库</strong></p></blockquote><blockquote><p><code>git clone [HTTPS/SSH]</code>：<strong>将远程库复制到本地库</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> clone实质上做了三件事，即拉取代码，初始化本地库，创建别名（初始化为origin）</div><blockquote><p><code>git pull [name/HTTPS/SSH] [本地库分支名]</code>：<strong>利用远程库更新本地库</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> pull拉取过程实质上就是一个合并的过程，可能产生合并冲突</div><blockquote><p><code>git push [name/HTTPS/SSH] [本地库分支名]</code>：<strong>将本地库分支推送到远程库</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 向别人的远程库推送代码需要权限，需要对方邀请自己成为对应库的成员并同意，且每次成员的推送都需要被库的拥有者审核后才能被合并入库（pull request）</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 想要push，必须保证本地库版本高于远程库，所以在修改代码前，最好先pull再进行修改</div><blockquote><p><code>git fork</code>：<strong>将一个远程库的代码复制到另一个远程库中</strong></p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/git_3.png" alt="github工作机制"></p><h3 id="4-IDEA集成Git"><a href="#4-IDEA集成Git" class="headerlink" title="4.IDEA集成Git"></a>4.IDEA集成Git</h3><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以VScode为例</div><h4 id="4-1初始设置"><a href="#4-1初始设置" class="headerlink" title="4.1初始设置"></a>4.1初始设置</h4><p><strong>①忽略设置</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 因为一个IDEA可能会生成一些我们不需要入库的文件，如日志文件等</div><blockquote><p>创建<code>git.ignore</code>文件（最好是在<code>.gitconfig</code>文件所在目录下），在其中添加<strong>需要忽略的文件类型</strong>，随后在<code>.gitconfig</code>文件中添加<strong>设置</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#忽略设置[core]    excludesfile = [git.ignore完整路径]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://gist.github.com/Yousha/3830712334ac30a90eb6041b932b68d7">VScode下C++的git.ignore模板</a><br><strong>②IDEA设置</strong></p><blockquote><p><code>VScode</code>中内置了对<code>Git</code>的支持，<strong>其他IDEA</strong>可能还需要<strong>在相关设置中设置<code>git.exe</code>的路径</strong></p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 工具链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码工具 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux内核设计与实现（二）</title>
      <link href="/2023/12/10/linux-nei-he-she-ji-yu-shi-xian-er/"/>
      <url>/2023/12/10/linux-nei-he-she-ji-yu-shi-xian-er/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux内核设计与实现（二）"><a href="#Linux内核设计与实现（二）" class="headerlink" title="Linux内核设计与实现（二）"></a>Linux内核设计与实现（二）</h1><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="1-进程和线程"><a href="#1-进程和线程" class="headerlink" title="1.进程和线程"></a>1.进程和线程</h3><p><strong>1.1进程</strong>：<strong>正在执行</strong>的程序的<strong>实时结果</strong><br>①进程不仅仅是一段可执行程序代码，还包含其他资源，如打开的文件、挂起的信号、内核内部数据、处理器状态、一个或多个具有内存映射的内存地址空间、执行线程和存放全局变量的数据段等<br>②进程和程序不是一对一关系，可能多个进程执行的是一个程序<br><strong>1.2线程</strong>：在<strong>进程中活动的对象</strong>，每个线程都拥有独立的程序计数器、进程栈和一组进程寄存器<br>①<strong>内核调度的对象</strong>是线程，不是进程<br>②在Linux中，线程被看作是<strong>特殊的进程</strong><br>③线程可以<strong>共享虚拟内存</strong>，但是有其<strong>各自的虚拟处理器</strong><br><strong>1.3内核线程</strong>：独立运行在<strong>内核空间</strong>的标准进程，但是没有独立的地址空间，只能<strong>由内核线程创建</strong><br><strong>1.4进程上下文</strong>：</p><h3 id="2-进程描述符（task-struct）"><a href="#2-进程描述符（task-struct）" class="headerlink" title="2.进程描述符（task_struct）"></a>2.进程描述符（task_struct）</h3><p><strong>2.1定义</strong>：内核将进程的列表存放在名为<strong>任务队列</strong>的<strong>双向循环链表</strong>中，链表的每一项就是进程描述符，包含了<strong>内核管理一个进程的所有信息</strong>，类型为<code>task_struct</code>，定义在&lt;linxu/sched.h&gt;中<br><strong>2.2分配</strong><br>①通过<strong>slab分配器</strong>分配进程描述符，能达到<strong>对象复用</strong>和<strong>缓存着色</strong>的目的<br>②slab分配器分配进程描述符后，在<strong>进程内核栈的尾端</strong>创建<code>thread_info</code>结构，其中<code>task</code>域存放指向<strong>其进程描述符的指针</strong><br><strong>2.3访问</strong>：内核通过访问进程描述符处理进程<br>①thread_info结构：采用<strong>硬件体系结构对应的current宏</strong>访问thread_info结构访问其task域<br>②特殊寄存器：有的硬件体系结构拿出<strong>一个专门寄存器</strong>存放指向当前进程task_struct的指针<br><strong>2.4PID</strong>：每个进程的标志，PID号的最大值表示系统中允许同时存在的进程的最大数目<br><strong>2.5进程状态</strong>：进程描述符中的<strong>state域</strong>描述了进程当前状态<br>①TASK_RUNNING（运行）：正在执行或者在运行队列中等待执行<br>②TASK_INTERRUPTIBLE（可中断）：进程被<strong>阻塞（睡眠）</strong>，<strong>等待某些条件的达成</strong>状态便改为运行，可能<strong>被某些信号提前唤醒</strong><br>③TASK_UNINTERRUPTIBLE（不可中断）：进程在等待时必须不受干扰，或者等待的事件很快就会发生，<strong>不对信号做出响应</strong><br>④_TASK_TRACED（被跟踪）：被一些进程监视<br>⑤_TASK_STOPPED（停止）：<strong>没有投入运行也不能投入运行</strong>，进程退出运行，在接收到某些信号或者在调试时接收到任何信号便会变为这种状态<br>#进程状态可以通过某些函数调整，如<code>set_task_state()</code>函数<br><strong>2.6父子进程</strong>：每个进程描述符中都包含一个<code>parent</code>指针指向其父进程，也有一个名为<code>children</code>的子进程列表<br>#所有进程都是<code>init</code>进程的子进程</p><h3 id="3-进程的创建"><a href="#3-进程的创建" class="headerlink" title="3.进程的创建"></a>3.进程的创建</h3><p><strong>3.1Unix进程创建概述</strong>：<code>fork()</code><strong>拷贝当前进程</strong>创建一个子进程，该子进程和父进程区别仅仅在于PID和PPID（父进程号）和某些资源，<code>exec()</code>读取<strong>进程对应可执行文件</strong>将其载入地址空间运行<br>#Linux的<code>fork()</code>系统调用采用的是<strong>写时拷贝</strong>，不复制整个父进程的进程地址空间（<strong>父进程占用的内存页</strong>），而是和父进程<strong>共享</strong>，只有当<strong>需要写入时</strong>才创建自己的内存页,<strong>在不写入的情况下，<code>fork()</code>函数只是复制了父进程的页表项和给子进程创建唯一的PID</strong><br><strong>3.2fork()</strong><br>①过程概述：<code>fork()</code>→<code>clone()</code>系统调用→<code>do_fork()</code>→调用<code>copy_process()</code><br>②copy_process过程</p><ul><li>为新进程创建一个内核栈、<code>thread_info</code>结构和<code>task_struct</code>结构，和父进程相同</li><li>检查是否超出了资源的限制</li><li>子进程<code>task_struct</code>的一些信息被清零或初始化，以便和父进程相区分，并将状态设置为“不可中断”，防止其投入运行</li><li>更新子进程<code>task_struct</code>中的<code>flag</code>标志，去掉子进程的<strong>超级用户权限</strong>，设置其“没有调用过<code>exec()</code>”对应的标志，并分配一个PID</li><li>根据<code>fork()</code>传递给<code>clone()</code>的标志判断其是否能<strong>共享公共资源</strong>，如果不能，则拷贝一份</li><li>扫尾工作，并返回一个指向子进程的指针，返回成功则<strong>先将子进程投入运行</strong>，因为子进程会运行<code>exec()</code>进行写时拷贝，防止父进程运行后写入改变地址空间</li></ul><p>#如果创建的是线程的话，每个线程都有<strong>各自的进程描述符</strong>，描述<strong>地址空间</strong>、<strong>文件资源系统</strong>等<strong>共享资源</strong>，<strong>线程本身</strong>再去描述其<strong>独占</strong>的资源，需要传递参数标志给clone()指明需要共享的资源（查阅相关表格）<br>#<br>③vfork():除了不拷贝父进程的页表项外，其余和<code>fork()</code>功能一致，可以通过向<code>clone()</code>传递特殊标志实现<code>vfork()</code></p><h3 id="4-进程的终结"><a href="#4-进程的终结" class="headerlink" title="4.进程的终结"></a>4.进程的终结</h3><p><strong>4.1终结的产生</strong>：进程调用exit()系统调用<br>①主动调用<br>②程序主函数返回：C语言会在函数的返回点后调用<br>③接收到不能处理与忽略的信号和异常<br><strong>4.2exit()</strong><br>①概述：调用exit（）后，只与该进程相关的所有资源全部被释放，成为僵死进程，只剩下内存栈、thread_info结构和task_struct结构，等待父进程调用wait（）将其释放，父进程退出后，需要给子进程在当前线程组或者找一个线程或者init作为父进程<br>②详细过程：LKD P31页<br>父进程退出后，需要给子进程在当前线程组或者找一个线程或者init作为父进程</p><h3 id="5-进程调度"><a href="#5-进程调度" class="headerlink" title="5.进程调度"></a>5.进程调度</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux工作流（三）</title>
      <link href="/2023/12/10/linux-gong-zuo-liu-san/"/>
      <url>/2023/12/10/linux-gong-zuo-liu-san/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux工作流"><a href="#Linux工作流" class="headerlink" title="Linux工作流"></a>Linux工作流</h1><h2 id="Linux进阶操作"><a href="#Linux进阶操作" class="headerlink" title="Linux进阶操作"></a>Linux进阶操作</h2><h3 id="1-辅助功能"><a href="#1-辅助功能" class="headerlink" title="1.辅助功能"></a>1.辅助功能</h3><h4 id="1-1定时调度"><a href="#1-1定时调度" class="headerlink" title="1.1定时调度"></a>1.1定时调度</h4><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 指定系统在指定时间执行指定脚本/指令，脚本文件需要有执行权限</div><p><strong>①<code>crontab</code>命令</strong></p><blockquote><p><code>crontab [选项]</code>：<code>-e/l/r</code>选项<strong>打开/查询/删除</strong>任务列表，<code>-r</code>选项后跟<strong>任务号</strong>删除<strong>特定任务</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 先打开任务列表，在其中按照特定格式输入任务即可</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 使用前使用service crond restart保证crond正在启动</div><blockquote><p><strong>任务格式</strong>：<code>[] [] [] [] [] [指令]/[脚本文件路径]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个占位符都有其特殊含义，组合起来表示任务执行的频率</div><blockquote><p><code>第一个</code>：表示<strong>一个小时</strong>的<strong>第几分钟</strong>，<strong>取值范围</strong>为<code>0-59</code></p></blockquote><blockquote><p><code>第二个</code>：表示<strong>一天</strong>中的<strong>第几个小时</strong>，<strong>取值范围</strong>为<code>0-23</code></p></blockquote><blockquote><p><code>第三个</code>：表示<strong>一个月</strong>中的<strong>第几天</strong>，<strong>取值范围</strong>为<code>1-31</code></p></blockquote><blockquote><p><code>第四个</code>：表示<strong>一年</strong>中的<strong>第几个月</strong>，<strong>取值范围</strong>为<code>1-12</code></p></blockquote><blockquote><p><code>第五个</code>：表示<strong>一周</strong>中的<strong>星期几</strong>，<strong>取值范围</strong>为<code>1-7</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个占位符都有其特殊格式，表示特殊意义</div><blockquote><p><code>*</code>：表示<strong>任何时间</strong>，如第一个<code>*</code>表示<strong>一小时的每分钟</strong></p></blockquote><blockquote><p><code>,</code>：表示<strong>不连续的时间</strong>，<code>0,30 1 * * *</code>表示<strong>每天的一点和一点半</strong></p></blockquote><blockquote><p><code>-</code>：表示<strong>连续的时间</strong>，如<code>0-30 1 * * *</code>，表示<strong>每天的一点到一点半</strong></p></blockquote><blockquote><p><code>*/n</code>：表示<strong>每隔多久执行一次</strong>，如<code>*/10 1 * * *</code>，表示<strong>每天的一点到两点每隔十分钟执行一次</strong></p></blockquote><p><strong>②<code>at</code>命令</strong></p><blockquote><p><code>at [时间]</code>：回车后输入<strong>指令</strong>或者<strong>脚本路径</strong>，随后输入<strong>两次</strong><code>ctrl+D</code><strong>结束输入</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以使用atq查看未执行的任务队列，并采用atrm 任务编号删除对应任务</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 需要保证atd正在执行，可以使用ps -ef|grep atd检查</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一次性定时任务,时间格式如下</div><blockquote><p><code>小时:分钟 日/月/年</code>：在<strong>对应时间</strong>执行，若<strong>只有</strong><code>小时:分钟</code>，则在<strong>当天对应时间</strong>执行</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若当天的对应时间过去，则会在第二天的对应时间执行</div><blockquote><p><code>now+n 时间单位</code> ：<strong>多久之后</strong>执行</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 时间单位有minutes、hours、days和weeks</div><h4 id="1-2磁盘管理"><a href="#1-2磁盘管理" class="headerlink" title="1.2磁盘管理"></a>1.2磁盘管理</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 磁盘可分为硬盘和软盘，现在软盘已经被淘汰了，所以磁盘相当于就是硬盘</div><p><strong>①硬盘信息</strong></p><blockquote><p><strong><code>lsblk</code><strong>：查看</strong>硬盘分区</strong>情况，可以添加<code>-f</code>选项查看<strong>详细信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> NAME、FSTYPE、FSUSE%、MOUNTPOINT分别为磁盘/分区编号、文件系统类型、使用百分比、挂载目录</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 磁盘的每个分区都可以通过挂载和某个目录联系到一起，访问这个目录相当于访问该分区</div><p><strong>②硬盘分区</strong></p><blockquote><p><code>fdisk [硬盘路径]</code>：进入<strong>界面</strong>后，输入<code>n</code>、选择<strong>分区类型</strong>、选择<strong>分区数目</strong>即可完成<strong>分区</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> linux中硬盘也是文件，存储在/dev目录下，所以磁盘路径通常为/dev/[磁盘编号]</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 分区后需要书去w进行保存，不保存则按q退出</div><p><strong>③磁盘格式化</strong></p><blockquote><p><code>mkfs -t [文件系统类型] [分区路径]</code>：将<strong>对应分区</strong>格式化为对应<strong>文件系统</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 硬盘分区也是/dev下的一个文件，通常路径为/dev/[分区编号]</div><p><strong>④磁盘挂载</strong></p><blockquote><p><code>mount [分区路径] [目录路径]</code>：将对应分区<strong>挂载</strong>到对应目录下</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在该目录创建文件后，文件写入到该分区中</div><blockquote><p><code>umount [分区路径]/[目录路径]</code>：<strong>撤销</strong>对应分区/目录的<strong>挂载映射关系</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 撤销挂载映射关系后，该目录文件消失，但是分区中文件不会消失</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 在命令行中挂载/撤销挂载，重启后会失效</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可通过修改/etc/fstab文件实现永久挂载，其中UUID可以使用分区路径替代，执行mount -a/重启即可生效</div><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 不能在卸载的目录中执行撤销指令</div><p><strong>⑤硬盘使用情况</strong></p><blockquote><p><code>df -h</code>：显示硬盘的<strong>整体使用情况</strong></p></blockquote><blockquote><p><code>du -h [目录路径]</code>：显示该目录下<strong>所有文件的大小</strong>，不指定是<strong>当前目录</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> -s选项仅仅显示汇总，-c选项同时显示汇总和明细，--max-depth=n指定n为子目录深度</div><h4 id="1-3网络管理"><a href="#1-3网络管理" class="headerlink" title="1.3网络管理"></a>1.3网络管理</h4><p><strong>①IP获取</strong></p><blockquote><p><strong>自动获取</strong>：<strong>启动后</strong>自动获取IP，可以<strong>避免IP冲突</strong>，但是每次的<strong>地址不同</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在setting的network选项卡中修改</div><blockquote><p><strong>指定IP</strong>：修改对应<strong>配置文件</strong>，修改<code>BOOTPROTO="static"</code>，并新增<code>IPADDR</code>、<code>GATEWAY</code>、<code>DNS1</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 新增项分别为IP地址、网关地址和域名解析器地址，network restart重启网络服务即可生效</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果使用的是虚拟机，则还需要通过虚拟网络编辑器修改虚拟机的子网和网关等信息</div><p><strong>②主机名映射</strong></p><blockquote><p><code>hostname</code>：<strong>查看</strong>主机名，可以在<code>/etc/hostname</code>中<strong>修改主机名</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 修改etc/hosts，设置主机名和IP地址的映射，输入主机名相当于输入对应IP地址</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 只是简单的替代关系，所以可以在etc/hosts中随意新增映射关系</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> host文件中的映射关系不能乱写，否则很可能找不到正确的IP地址</div><blockquote><p>在浏览器中<strong>输入网址</strong>后，浏览器依次从<strong>浏览器缓存</strong>、<strong>本地DNS解析缓存</strong>、<strong>hosts文件</strong>、<strong>DNS服务器</strong>查找IP地址</p></blockquote><p><strong>③网络状态</strong></p><blockquote><p><code>ping [IP地址]</code>：测试<strong>能否访问</strong>对应网络地址</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ping后可以跟任何可以映射为IP地址的东西，如主机名和URL</div><blockquote><p><code>ifconfig</code>：查看<strong>网络详细信息</strong>，如<strong>IP地址</strong>、<strong>子网掩码</strong>等</p></blockquote><blockquote><p><code>netstat -anp</code>：查看系统<strong>网络连接</strong>状态</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> Proto网络协议、Local Address本地监听端口、Foreign Address外地请求端口，State端口状态</div><h4 id="1-4进程管理"><a href="#1-4进程管理" class="headerlink" title="1.4进程管理"></a>1.4进程管理</h4><p><strong>①进程信息</strong></p><blockquote><p><code>ps -aux</code>：显示<strong>进程信息</strong>，<code>-a</code>选项显示<strong>所有进程</strong>，<code>-u</code>以<strong>用户格式</strong>显示 <code>-x</code>显示<strong>后台进程</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> %CPU、%MEM、STAT和COMMAND分别表示CPU占用、物理内存占用、进程状态和启动进程的命令</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以配合管道命令和more或者grep，ps -aux | more，ps -aux | grep xxx</div><blockquote><p><code>ps -ef</code>：<strong>全格式</strong>显示所有进程，主要用于查看<code>PPID</code><strong>父进程</strong>、<code>C</code>执行<strong>优先级</strong></p></blockquote><blockquote><p><code>pstree</code>：查看<strong>进程树</strong></p></blockquote><p><strong>②进程管理</strong></p><blockquote><p><code>kill [选项] [进程号]</code>：<strong>终止</strong>进程，但是该请求<strong>可能会被屏蔽</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> -9选项强制终止进程</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> kill对应用户使用的ssh进程，从而阻止该用户远程登录</div><blockquote><p><code>killall [进程名称]</code>：<strong>终止</strong>进程以及<strong>其子进程</strong></p></blockquote><blockquote><p><code>top [选项]</code>：<strong>动态</strong>显示进程，以及<strong>概述信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> -dn设置隔n秒更新，默认是3秒，-i不显示闲置和僵死进程，-p [进程号]监控某个进程</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 进入界面后，可按下某键进行交互</div><blockquote><p><code>M/N/P</code>：按照<strong>内存占用率/PID/CPU占用率</strong>排序</p></blockquote><blockquote><p><code>u</code>：<strong>回车</strong>后输入<strong>用户名</strong>，即可仅查看<strong>某用户进程</strong></p></blockquote><blockquote><p><code>k</code>：<strong>回车</strong>后输入<strong>PID</strong>，<strong>回车</strong>后再输入<strong>信号量如9</strong>，即可<strong>终止</strong>对应进程</p></blockquote><blockquote><p><code>q</code>：<strong>退出</strong></p></blockquote><h4 id="1-5服务管理"><a href="#1-5服务管理" class="headerlink" title="1.5服务管理"></a>1.5服务管理</h4><p><strong>①引言</strong></p><blockquote><p><strong>服务</strong>：一个<strong>后台进程</strong>，<strong>监听</strong>某个<strong>端口</strong>，<strong>等待</strong>其他程序的<strong>请求</strong></p></blockquote><blockquote><p><strong>运行级别</strong>：系统的<strong>运行状态</strong>，常用的有<code>3</code><strong>有网络的多用户状态</strong>、<code>5</code><strong>图形界面</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不同的运行级别，会有不同的服务开机时自启动</div><blockquote><p><code>systemctl get-default</code>：<strong>获取</strong>运行级别</p></blockquote><blockquote><p><code>systemctl set-default [运行级别对应字符串]</code>：<strong>修改</strong>运行级别，<strong>重启生效</strong></p></blockquote><blockquote><p><code>systemctl list-unit-files</code>：查看<strong>当前运行级别</strong>各个服务进程的<strong>自启动状态</strong></p></blockquote><blockquote><p><code>systemctl [start/stop/restart/status] [服务名]</code>：<strong>开始/停止/重启/查看</strong>对应服务</p></blockquote><blockquote><p><code>systemctl [enable/disable/is-enabled] [服务名]</code>：<strong>设置</strong>服务进程开机<strong>是/否自启动</strong>，<strong>查询</strong>自启动状态</p></blockquote><p><strong>②防火墙</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 用于管理端口，外界只能访问防火墙允许访问的端口</div><blockquote><p><code>telnet [ip地址] [端口号]</code>：从<strong>某个端口</strong>连接<strong>对应IP地址</strong></p></blockquote><blockquote><p><code>sudo ufw allow [端口号]</code>：<strong>打开</strong>端口</p></blockquote><blockquote><p><code>sudo ufw delete allow [端口号]</code>：<strong>关闭</strong>端口</p></blockquote><blockquote><p><code>sudo ufw status</code>：查看<strong>已经开启</strong>的端口</p></blockquote><blockquote><p><code>sudo ufw reload</code>：防火墙<strong>重启</strong></p></blockquote><p><strong>③SSH</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一种建立在应用层和运输层基础上的安全协议，常用于远程登录，分为客户端和服务端，服务端在22号端口监听</div><blockquote><p><code>sudo apt-get install openssh-server</code>：安装SSH<strong>服务端与客户端</strong>，Ubuntu需要要<strong>手动安装</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 安装后使用systemctl重启并设置自启动即可</div><blockquote><p><code>ssh [用户名]@[IP地址]</code>：以<strong>某个用户</strong>连接<strong>对应IP地址主机</strong>，需要输入<strong>该用户密码</strong></p></blockquote><blockquote><p><code>exit/logout</code>：<strong>退出</strong>远程连接</p></blockquote><p><strong>④apt</strong></p><blockquote><p><strong>概述</strong>：一种<strong>包管理器</strong>，可以从对应<strong>apt服务器</strong>下载安装软件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> /etc/apt/sources.list中存放使用的apt服务器地址，可以将其修改为镜像源，如清华大学开源软件镜像站</div><blockquote><p><code>sudo apt-get update</code>：<strong>更新</strong>apt源</p></blockquote><blockquote><p><code>sudo apt-get install [包名称]</code>：<strong>安装</strong>软件包</p></blockquote><blockquote><p><code>sudo apt-get source [包名称]</code>：获取<strong>源代码</strong></p></blockquote><blockquote><p><code>sudo apt-get remove [包名称]</code>：删除包</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 工具链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 工作流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIT6.1810（一）</title>
      <link href="/2023/12/10/mit6.1810-yi/"/>
      <url>/2023/12/10/mit6.1810-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><h2 id="MIT6-1810（一）"><a href="#MIT6-1810（一）" class="headerlink" title="MIT6.1810（一）"></a>MIT6.1810（一）</h2><h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1.环境配置"></a>1.环境配置</h3><h4 id="1-1工具链安装"><a href="#1-1工具链安装" class="headerlink" title="1.1工具链安装"></a>1.1工具链安装</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以Ubuntu20.04.1为例</div><blockquote><p>在<strong>命令行</strong>输入<strong>以下代码</strong></p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update  //更新软件包来源<span class="token function">sudo</span> <span class="token function">apt-get</span> upgrade //更新所有能更新的软件<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span> build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><code>git</code>：<strong>版本控制</strong>工具，并且可以将<strong>Lab文件夹</strong>保存到<strong>github</strong></p></blockquote><blockquote><p><code>build-essential</code>：编译<code>c/c++</code>所需要的<strong>所有工具</strong>的<strong>软件包</strong>，如<code>gdb</code>、<code>gcc</code>和<code>make</code>等</p></blockquote><blockquote><p><code>gdb-multiarch</code>：为<code>gdb</code>的<strong>多架构版本</strong>，支持<strong>多种CPU架构</strong></p></blockquote><blockquote><p><code>qemu</code>：一个支持<strong>跨平台虚拟化</strong>的虚拟机，如在<strong>x86架构</strong>平台上虚拟出一个<strong>ARM架构</strong>平台</p></blockquote><blockquote><p><code>gcc-riscv64-linux-gnu</code>:是<strong>基于GCC</strong>的<strong>跨平台编译工具</strong>，可以在<strong>某架构</strong>如X86，平台上将<strong>C/C++代码</strong>编译成<strong>RISC-V指令集</strong>的<strong>汇编码</strong>、<strong>机器码</strong>，并做出相应的<strong>程序分析</strong></p></blockquote><blockquote><p><code>binutils-riscv64-linux-gnu</code>：针对<strong>RISC-V架构</strong>的<strong>GNU Binutils工具集</strong>的特定变体</p></blockquote><h4 id="1-2课程源码编译"><a href="#1-2课程源码编译" class="headerlink" title="1.2课程源码编译"></a>1.2课程源码编译</h4><blockquote><p>在<strong>命令行</strong>输入<strong>以下代码</strong>，<code>ctrl-a x</code>，即<strong>先同时</strong>按住<code>ctrl</code>和<code>a</code>,<strong>随后</strong>按下<code>x</code>即可<strong>退出</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 第一次需要输入以下三行代码，以后只需要在对应目录下输入make qemu即可</div><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone git://g.csail.mit.edu/xv6-labs-2023<span class="token builtin class-name">cd</span> xv6-labs-2023<span class="token function">make</span> qemu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-XV6操作系统"><a href="#2-XV6操作系统" class="headerlink" title="2.XV6操作系统"></a>2.XV6操作系统</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①简介</strong></p><blockquote><p><strong>概述</strong>：以<strong>ANSI C</strong>重新编写的<strong>Unix第六版</strong>，基于<code>Sv39 RISC-V</code>运行</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> RISC-V有三种CPU可以执行指令的模式，机器模式、用户模式和管理模式，特权级不同</div><p><strong>②启动概述</strong></p><blockquote><p><strong>通电</strong>时，<strong>初始化</strong>自己并运行存储在<strong>ROM</strong>的<strong>引导加载程序</strong>,将<strong>xv6内核</strong>加载到<strong>内存</strong>中，随后执行<code>entry.s</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> XV6内核起始位置为0x80000000，之前的内存用于存放I/O设备</div><blockquote><p><code>entry.s</code>设置了一个<strong>栈区</strong>，这样xv6就可以<strong>运行C代码</strong>，即<code>start.c</code></p></blockquote><blockquote><p><code>start.c</code>执行一些仅在<strong>机器模式</strong>下允许的配置，并开启<strong>时钟中断</strong>，随后切换到<strong>管理模式</strong>并跳转到<code>main.c</code></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> start.c设置了一些寄存器，如将main函数的地址写入寄存器mepc，随后使用mret“返回”到main并进入管理模式</div><blockquote><p><code>main.c</code>先进行<strong>初始化</strong>，随后执行<code>userinit()</code>调用<code>initcode.s</code>，<code>initcode.s</code>通过<code>exec()</code>调用<code>init.c</code>启动<code>shell</code></p></blockquote><h4 id="2-2内存管理"><a href="#2-2内存管理" class="headerlink" title="2.2内存管理"></a>2.2内存管理</h4><p><strong>①页表</strong></p><blockquote><p><strong>概述</strong>：<strong>一级结构</strong>的原理<strong>如下图</strong>所示，可见总共有<code>2^44</code>页，<strong>每一页的大小</strong>为<code>2^12</code>位</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 实际上xv6采用的是三级结构，即27位的页表索引分为三个9位的页表索引，可以用于节省空间</div><blockquote><p>如果采用<strong>一级结构</strong>，需要<code>2^27</code>条<strong>页表项</strong>，而<strong>三级结构</strong>，只需要<code>3*2^9</code>条<strong>页表项</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 每个CPU都有一个satp寄存器指向根页表页的物理地址以及指向的页表转换后续指令生成的所有地址</div><blockquote><p><strong>标志位</strong>：每个<strong>页表项</strong>都有其<strong>标志位</strong>，告诉<strong>分页硬件</strong>允许<strong>如何使用</strong>关联的虚拟地址</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如是否存在和允许读写等，详细可查看riscv.h头文件</div><p><strong>②地址空间</strong><br>为了减少从物理内存加载 PTE 的开销，RISC-V CPU 将页表条目缓存在 Translation Look-aside Buffer </p><p>RISC-V上的指针有64位宽；硬件在页表中查找虚拟地址时只使用低39位；xv6只使用这39位中的38位<br>每个进程有一个单独的页表，映射其地址空间，进程最大地址空间受到限制，MAXVA，kernel/riscv.h:348</p><p>xv6为trampoline（用于在用户和内核之间切换）和映射进程切换到内核的trapframe分别保留了一个页面，正如我们将在第4章中解释的那样。</p><p>proc结构保存了每个进程的状态，页表、内核栈区和运行状态</p><p>进程都有一个或者多个线程，用于执行进程的指令，线程的大部分状态保存在线程的栈中</p><p>每个进程有一个用户栈和内核栈，进程执行用户指令时，只有它的用户栈在使用，它的内核栈是空的。当进程进入内核（由于系统调用或中断）时，内核代码在进程的内核堆栈上执行；当一个进程在内核中时，它的用户堆栈仍然包含保存的数据，只是不处于活动状态。进程的线程在主动使用它的用户栈和内核栈之间交替</p><p>RISC-V的ecall指令允许应用程序从指定点陷入内核，提升硬件特权级别，并将程序计数器（PC）更改为内核定义的入口点，入口点的代码切换到内核栈，执行实现系统调用的内核指令，当系统调用完成时，内核切换回用户栈，并通过调用sret指令返回用户空间，该指令降低了硬件特权级别，并在系统调用指令刚结束时恢复执行用户指令。进程的线程可以在内核中“阻塞”等待I/O，并在I/O完成后恢复到中断的位置。</p><p>用户和内核指令使用的是虚拟地址，RISC-V页表硬件通过将每个虚拟地址映射到物理地址来为这两种地址建立联系</p><h3 id="3-操作系统接口"><a href="#3-操作系统接口" class="headerlink" title="3.操作系统接口"></a>3.操作系统接口</h3><h4 id="3-1进程"><a href="#3-1进程" class="headerlink" title="3.1进程"></a>3.1进程</h4><p><strong>①创建</strong></p><blockquote><p><code>int fork()</code>：创建一个<strong>内存内容</strong>与其<strong>完全相同</strong>的<strong>子进程</strong>，即<strong>指令</strong>、<strong>数据</strong>和<strong>堆栈</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在父进程中，返回值为子进程的PID，在子进程中，返回值为0</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 创建的是进程，子进程被创建后不久就执行了，通常使用fork的返回值以及if语句区别父子进程</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 子进程运行时有自己独立的内存空间的，父子进程相互不影响</div><p><strong>②销毁</strong></p><blockquote><p><code>void exit(int status)</code>：<strong>销毁</strong>当前进程并<strong>释放资源</strong>，<code>status</code>表示进程<strong>结束状态</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主动结束进程，当status为0时，表示正常结束，1表示发生错误并结束</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 主动结束进程并给出提示信息，即是正常结束还是非正常结束</div><p><strong>③等待</strong></p><blockquote><p><code>int wait(int *)</code>：进程<strong>立刻阻塞</strong>，若其有<strong>子进程主动退出或者被杀死</strong>，返回<strong>子进程PID</strong>，如果<strong>没有子进程</strong>，返回<code>-1</code>，反之则<strong>一直等待</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 传入参数为一返回地址，用于接受子进程退出状态，如果不关心该信息，传入一个0地址（int*）0</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 对于父子进程共享的信息，可以先让父进程wait，让子进程先访问</div><p><strong>④调用</strong></p><blockquote><p><code>void exec(char* filename，char* argv)</code>：在<strong>进程内部</strong>执行一个<strong>可执行文件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> filename用于提供文件路径，对应文件必须有特定的格式，argv用于提供字符串参数数组，第一个参数为程序名</div><h4 id="3-2I-x2F-O操作"><a href="#3-2I-x2F-O操作" class="headerlink" title="3.2I/O操作"></a>3.2I/O操作</h4><p><strong>①文件描述符</strong></p><blockquote><p><strong>概述</strong>：本质上是一个<strong>小整型</strong>，一个<strong>可以读写</strong>的由<strong>内核管理</strong>的对象，将<strong>文件</strong>、<strong>目录</strong>和<strong>设备</strong>等抽象为<strong>字节流</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 各个进程的文件描述符是相互隔离的，每个进程都至少有一个标准输入0，标准输出1和标准错误2</div><p><strong>②读取与写入</strong></p><blockquote><p><code>int read(int fd,char* buf,int n)</code>：从<code>fd</code>处<strong>最多读取n字节</strong>，并复<strong>制到缓冲区</strong><code>buf</code>中，返回<strong>读取的字节数</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个文件描述符都会记录其字节流所在位置信息，且随着读写等操作向前/后推移</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 读取字节数为0表示到达文件末尾</div><blockquote><p><code>write(fd，buf，n)</code>：将<strong>缓冲区</strong><code>buf</code>中的<strong>n个字节</strong>写入<code>fd</code>处，返回<strong>写入的字节数</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若写入字节小于n，则表示发生了错误</div><p><strong>③打开与关闭</strong></p><blockquote><p><code>close(int fd)</code>：<strong>释放</strong>文件描述符，使其可以被<strong>重新分配</strong></p></blockquote><blockquote><p><code>int open(char* filename,MACRO)</code>：为文件<strong>分配文件描述符</strong>，并指定<strong>字节流特性</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 新分配的文件描述符号，总是当前进程最小的</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 常用的宏有O_RDONLY只读、O_WRONLY只写、O_RDWR可读可写</div><blockquote><p>还有<code>O_CREAT</code>若文件<strong>不存在</strong>则<strong>创建该文件</strong>、<code>O_TRUNC</code>将文件<strong>截断为零长度</strong></p></blockquote><blockquote><p><code>int dup(int fd)</code>:接受一个<strong>文件描述符</strong>，返回一个<strong>新文件描述符</strong>，<strong>一同</strong>指向<strong>对应文件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 父进程和子进程，以及dup得到的文件描述符和原文件描述符的字节流位置偏移一开始是一样的</div><p><strong>④管道</strong></p><blockquote><p><strong>概述</strong>：本质上是<strong>一对文件描述符</strong>，指向<strong>全局的内核缓冲区</strong>，用于在<strong>两个进程</strong>之间<strong>传递数据</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 两个文件描述符分别传递给两个进程，一个用于一个进程写数据，另一个用于另一个进程读书据</div><blockquote><p><code>void pipe(int* p)</code>：创建一个<strong>管道</strong>，<code>p</code>为一个<strong>长度为2</strong>的<strong>文件描述符数组</strong>，<code>pipe</code>会<strong>在其中记录</strong>管道所需的<strong>读写文件描述符</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若一直没有写入数据，管道的读取操作会进入等待，直到有新数据写入或所有指向写入端的文件描述符都被关闭</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 及时关闭指向管道写入端的文件描述符，因为对于管道来说所有的写入端都被关闭才是结束，否则会一直等待</div><blockquote><p>如下例，<strong>子进程</strong>必须在<strong>调用wc之前</strong>关闭<strong>管道写入端的文件描述符</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 对于cat|echo，shell对|的左端和右端，均调用fork和runcmd，并创建一个管道连接两者传递信息即可</div><blockquote><p>还可通过<strong>临时文件</strong>在<strong>进程间</strong>传递信息，但管道会<strong>自动清理自己</strong>，且允许<strong>两程序并行</strong>，且管道的<strong>阻塞式读写</strong>更高效</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"wc"</span><span class="token punctuation">;</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//创建管道所需要的文件描述符</span><span class="token function">pipe</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建子进程，这样父子进程都有指向同一个管道的文件描述符了</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//子进程关闭标准读取，并将其指向管道的读取端</span>    <span class="token function">close</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">dup</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//关闭所有指向管道的文件描述符</span>    <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//exec调用wc，wc从标准读取，也就是管道读取端读入数据</span>    <span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"/bin/wc"</span><span class="token punctuation">,</span> argv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">//关闭管道读取端</span>    <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将"hello world\n"写入管道</span>    <span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"hello world\n"</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//关闭管道写入端</span>    <span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3文件系统"><a href="#3-3文件系统" class="headerlink" title="3.3文件系统"></a>3.3文件系统</h4><p><strong>①引言</strong></p><blockquote><p><strong>绝对路径</strong>：以<code>/</code>开头，从<strong>根目录</strong>开始<strong>层层向下</strong>寻找对应文件</p></blockquote><blockquote><p><strong>相对路径</strong>：不以<code>/</code>开头，相对于<strong>调用进程的当前工作目录</strong>进行计算</p></blockquote><blockquote><p><strong>inode</strong>：<strong>文件</strong>在操作系统中的<strong>抽象</strong>，保存了文件的<strong>元数据</strong>、<strong>长度</strong>、<strong>磁盘位置</strong>等<strong>描述信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一个inode文件可以对应多个链接（名字）</div><p><strong>②修改路径</strong></p><blockquote><p><code>void chdir(char* path)</code>：修改<strong>当前工作目录</strong>，可以传入<strong>相对路径</strong>也可以传入<strong>绝对路径</strong></p></blockquote><p><strong>③创建</strong></p><blockquote><p><code>void mkdir(char* path)</code>：创建<strong>目录</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以通过open创建文件，fd = open("/dir/file", O_CREATE | O_WRONLY);</div><blockquote><p><code>mknod(char* path,int device_number1,int device_number2)</code>：创建一个<strong>设备文件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 后两个参数分别为设备的主设备号和次设备号，唯一地标识了一个内核设备</div><p><strong>④链接</strong></p><blockquote><p><code>link(char* file1,char* file2)</code>：给<strong>链接</strong><code>file1</code>创建一个<strong>新的链接</strong><code>file2</code>，两者指向<strong>同一个inode</strong>文件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 从file1读取或写入与从file2读取或写入是相同的操作</div><blockquote><p><code>unlink(char* file1)</code>：从<strong>文件系统</strong>中删除一个<strong>链接</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当文件的链接数为零且没有文件描述符引用时，文件的inode和包含其内容的磁盘空间会被释放</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以利用unlink创建临时文件</div><pre class="line-numbers language-none"><code class="language-none">fd = open("/tmp/xyz", O_CREATE | O_RDWR);unlink("/tmp/xyz");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 项目实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> MIT6.1810 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux工作流（一）</title>
      <link href="/2023/12/10/linux-gong-zuo-liu-yi/"/>
      <url>/2023/12/10/linux-gong-zuo-liu-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux工作流"><a href="#Linux工作流" class="headerlink" title="Linux工作流"></a>Linux工作流</h1><h2 id="Linux基础操作"><a href="#Linux基础操作" class="headerlink" title="Linux基础操作"></a>Linux基础操作</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1Linux基本介绍"><a href="#1-1Linux基本介绍" class="headerlink" title="1.1Linux基本介绍"></a>1.1Linux基本介绍</h4><p><strong>①概述</strong></p><blockquote><p>一款<strong>开源免费</strong>的<strong>多用户多任务</strong>操作系统，主要应用在<strong>服务器领域</strong>，借鉴了<strong>unix系统</strong>的思想，有<strong>ubuntu</strong>、<strong>debain</strong>等发行版</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 多任务即允许同时进行多个任务，多用户即允许多个用户同时登录</div><p><strong>②目录结构</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> Linux下一切皆文件，包括硬件也会被映射为一个文件</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要介绍根目录下的各个目录，每个目录存放特定的文件</div><blockquote><p><strong>bin</strong>：存放<strong>经常使用的命令</strong>，如<code>cd</code>等</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> sbin存放只有管理员才能使用的命令</div><blockquote><p><strong>home</strong>：存放<strong>普通用户</strong>的<strong>主目录</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> root存放管理员的主目录</div><blockquote><p><strong>lib</strong>：存放<strong>系统</strong>使用的<strong>动态链接库</strong></p></blockquote><blockquote><p><strong>etc</strong>：存放<strong>系统管理</strong>所需要的<strong>配置文件</strong></p></blockquote><blockquote><p><strong>usr</strong>：存放<strong>系统共享资源</strong>，其中<code>usr/local</code>为<strong>用户使用系统安装</strong>的软件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> opt为用户手动安装软件的安装路径</div><blockquote><p><strong>boot</strong>：Linux<strong>启动</strong>时所需要的<strong>核心文件</strong></p></blockquote><blockquote><p><strong>tmp</strong>：存放<strong>临时文件</strong></p></blockquote><blockquote><p><strong>dev</strong>：存放<strong>系统硬件</strong>如CPU的<strong>映射</strong>，类似于windows的<strong>设备管理器</strong>，其中的<strong>设备</strong>需要<strong>挂载</strong>才能使用</p></blockquote><blockquote><p><strong>media</strong>：存放<strong>自动挂载</strong>，如<strong>U盘</strong>等</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> mnt存放手动挂载</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> dev存放U盘的映射，media存放U盘的内容</div><blockquote><p><strong>var</strong>：存放<strong>经常被修改</strong>的东西，如<strong>日志文件</strong></p></blockquote><blockquote><p><strong>proc</strong>：存储的是Linux运行时的<strong>进程映射</strong></p></blockquote><h4 id="1-2Linux安装"><a href="#1-2Linux安装" class="headerlink" title="1.2Linux安装"></a>1.2Linux安装</h4><p><strong>①双系统安装</strong></p><p><strong>②虚拟机安装</strong></p><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h3><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 命令后一般会跟选项和对象，可以是没有，也可以是多个</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 没有反应一般就是成功</div><h4 id="2-1基础命令"><a href="#2-1基础命令" class="headerlink" title="2.1基础命令"></a>2.1基础命令</h4><blockquote><p><code>clear</code>：<strong>清除命令行</strong></p></blockquote><blockquote><p><code>cd [目录路径]</code>：切换到<strong>对应目录下</strong>，<strong>缺省</strong>为<strong>家目录</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 路径可分为相对路径和绝对路径，相对路径为相对于当前文件夹的路径，绝对路径为相对于根目录的路径</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 相对路径中，.表示当前目录，..表示上一级目录，～表示家目录</div><blockquote><p><code>ls [路径]</code>：列出<strong>对应路径</strong>的文件，<strong>缺省</strong>为<strong>当前路径</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> -a显示隐藏文件，-l显示详细文件信息（单列输出），-h人性化输出，如以K、M等单位显示文件大小</div><blockquote><p><code>echo [输出内容]</code>：将<strong>对应内容</strong>输出到<strong>控制台</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以使用echo $PATH输出环境变量</div><blockquote><p><code>pwd</code>：显示<strong>当前目录</strong>的<strong>绝对路径</strong></p></blockquote><blockquote><p><code>man [命令或者配置文件]</code>：获得<strong>对应</strong>的<strong>帮助信息</strong>，按<code>q</code><strong>退出</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 对应help只能获得shell内置命令的帮助</div><blockquote><p><code>shutdown [选项] [时间]</code>：<strong>一段时间后</strong>执行<strong>对应操作</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> -h选项是关机，-r选项是重启，时间以分钟为单位</div><blockquote><p><code>sync</code>：将<strong>内存数据</strong>同步到<strong>磁盘</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 类似于保存，每次关机重启前要输入这条命令</div><blockquote><p><code>init [级别数字]</code>：指定<strong>运行级别</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 运行级别不同，关机等命令行、图形界面</div><blockquote><p><code>data</code>：查看<strong>当前时间</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> date命令通过-s选项设置时间</div><h4 id="2-2用户与组"><a href="#2-2用户与组" class="headerlink" title="2.2用户与组"></a>2.2用户与组</h4><p><strong>①用户管理</strong></p><blockquote><p><code>useradd [用户名]</code>：<strong>创建</strong>账户</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用-d选项指定家目录路径</div><blockquote><p><code>passwd [用户名]</code>：设置/修改<strong>密码</strong></p></blockquote><blockquote><p><code>userdel [用户名]</code>：<strong>删除</strong>用户，但是<strong>保留</strong>了他的<strong>家目录</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用-r选项删除其家目录</div><blockquote><p><code>id [用户名]</code>：查询<strong>用户信息</strong>（<code>uid</code>和<code>gid</code>）</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> /etc/passwd中包含了每个用户的信息，/etc/shadow包含了用户口令的配置文件</div><blockquote><p><code>whoami</code>：查询<strong>当前用户</strong></p></blockquote><blockquote><p><code>su - [用户名]</code>：<strong>切换</strong>用户</p></blockquote><p><strong>②组管理</strong></p><blockquote><p><code>groupadd [组名]</code>：<strong>新建</strong>组</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> /etc/group包含了组的信息</div><blockquote><p><code>groupdel [组名]</code>：<strong>删除</strong>组</p></blockquote><blockquote><p><code>useradd -g [组名] [用户名]</code>：<strong>创建</strong>账户时给其<strong>指定组</strong>/<strong>修改</strong>用户所在组</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若创建用户时没有指定组，则会给起创建一个与其名字相同的组并将其放入</div><blockquote><p><code>usermod -g [新组名] [用户]</code>：<strong>修改</strong>用户<strong>所在组</strong></p></blockquote><h4 id="2-3辅助命令"><a href="#2-3辅助命令" class="headerlink" title="2.3辅助命令"></a>2.3辅助命令</h4><blockquote><p><code>|</code>：<strong>管道</strong>命令，将<strong>前一个命令得到的输出</strong>作为<strong>下一个命令的输入</strong></p></blockquote><blockquote><p><code>&gt; [文件路径]</code>：将命令的输出<strong>重定向</strong>到对应<strong>文件</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以使用echo '' &gt; [文件路径]清空某个文件</div><blockquote><p><code>&gt;&gt; [文件路径]</code>：将命令的输出<strong>追加</strong>到对应<strong>文件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若对应文件不存在，则会创建该命令</div><blockquote><p><code>ln -s [源文件或者目录] [软连接路径]</code>：给<strong>对应文件/目录</strong>创建<strong>软链接</strong>，类似于<strong>快捷方式</strong></p></blockquote><blockquote><p><code>history [数字]</code>：查看<strong>历史命令</strong></p></blockquote><blockquote><p><code>grep [选项] “[查找内容]“ [文件路径]</code>：在<strong>对应文件</strong>中查找<strong>对应内容</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> -n选项显示匹配行和行号，-i忽略字母大小写</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 常常和管道命令联合使用，某个命令结果中找自己需要的部分</div><blockquote><p><code>tree [目录路径]</code>：<strong>树状显示</strong>对应目录的<strong>文件关系</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要下载</div><h3 id="3-文件管理"><a href="#3-文件管理" class="headerlink" title="3.文件管理"></a>3.文件管理</h3><h4 id="3-1基本操作"><a href="#3-1基本操作" class="headerlink" title="3.1基本操作"></a>3.1基本操作</h4><p><strong>①创建</strong></p><blockquote><p><code>touch [文件路径]</code>：<strong>创建</strong>文件/<strong>更新</strong>文件<strong>修改时间</strong></p></blockquote><blockquote><p><code>mkdir [目录路径]</code>：<strong>创建</strong>对应<strong>目录</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用-p选项创建多级目录，如mkdir -p a/b/c</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> /home表示根目录下有个home，系统会自动检测其是文件还是文件夹，而/home/表示根目录下有个home文件夹</div><p><strong>②删除</strong></p><blockquote><p><code>rmdir [目录路径]</code>：<strong>删除</strong>指定<strong>空目录</strong></p></blockquote><blockquote><p><code>rm [文件路径]</code>：<strong>删除</strong>指定<strong>文件</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可使用rm的-rf选项可递归删除非空目录</div><p><strong>③移动</strong></p><blockquote><p><code>mv [源文件路径] [文件路径]</code>：将<strong>源文件</strong>复制到<strong>对应路径</strong>并对其<strong>重命名</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 若两路径一致，则是重命名</div><blockquote><p><code>mv [源文件路径] [目录路径]</code>：将<strong>源文件</strong>移动到<strong>对应目录下</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该文件也可以是目录</div><p><strong>④复制</strong></p><blockquote><p><code>cp [源文件路径] [存放目录路径]</code>：将<strong>文件</strong>复制到<strong>对应目录下</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用-r选项递归复制整个文件夹</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> \cp强制忽略覆盖信息</div><p><strong>⑤查看</strong></p><blockquote><p><code>less [文件路径]</code>：查看文件，查看<strong>大型文件</strong>友好</p></blockquote><blockquote><p><code>head [文件路径]</code>：查看文件<strong>头部信息</strong></p></blockquote><blockquote><p><code>tail [文件路径]</code>：查看文件<strong>尾部信息</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> -f选项可以使用终端实时监控文件的修改</div><p><strong>⑥查找</strong></p><blockquote><p><code>find [搜索目录路径] [选项] [对应条件]</code>：在<strong>指定路径</strong>下根据<strong>提供的条件</strong>递归<strong>搜索文件</strong><br><code>find /home -size +200M</code>：查找<strong>大于200M</strong>的文件，若<strong>条件选项前</strong>为<code>-</code>则是<strong>小于</strong>，缺省是<strong>等于</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> -name是名字，-size是文件大小，-user是用户名</div><blockquote><p><code>locate [文件名]</code>：快速<strong>定位文件</strong>并<strong>绝对路径</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> locate是基于数据库系统进行查询的，所以在使用该命令之前需要使用updatedb创建/更新数据库</div><blockquote><p><code>which [指令名]</code>：返回<strong>指令文件</strong>的<strong>绝对路径</strong></p></blockquote><p><strong>⑦压缩</strong></p><blockquote><p><code>tar [选项]</code>：根据选项<strong>压缩/解压</strong>文件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> -c产生.tar打包文件、-v显示详细信息、-f指定压缩后的文件名，-z打包同时压缩，-x解压</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常，压缩使用-zcvf选项，解压使用-xcvf，还可使用-C选项指定解压路径</div><blockquote><p><code>tar -zcvf xxx.tar.gz [文件/目录路径]</code>：<strong>压缩文件</strong>并<strong>指定压缩包名</strong></p></blockquote><blockquote><p><code>tar -zcvf xxx.tar.gz -C [目录路径]</code>：<strong>解压</strong>压缩包到<strong>指定路径</strong></p></blockquote><h4 id="3-2文件权限"><a href="#3-2文件权限" class="headerlink" title="3.2文件权限"></a>3.2文件权限</h4><p><strong>①文件归属</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 每个文件都有所有者、所在组和其他组，每个对象对其权限不同</div><blockquote><p>文件被<strong>创建时</strong>，其<strong>所有者</strong>被初始化为<strong>创建者</strong>，<strong>所在组</strong>被初始化为<strong>创建者当时所在组</strong></p></blockquote><blockquote><p><code>chown [用户名] [文件路径/目录路径]</code>：修改<strong>文件所有者</strong></p></blockquote><blockquote><p><code>chown [用户名]:[组名] [文件路径/目录路径]</code>：修改<strong>文件所有者以及所在组</strong></p></blockquote><blockquote><p><code>chgrp [组名] [文件路径/目录路径]</code>：修改<strong>文件所在组</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 均可使用-R选项递归的修改目录下所有文件</div><blockquote><p>如<code>chgrp -R [组名] [目录路径]</code></p></blockquote><p><strong>②文件信息</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用ls -la查看某文件信息如下</div><blockquote><p><code>-rw-rw-r--  1 zfk zfk 581565 11月 20 19:24 book-riscv-rev3.pdf</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 第一串字符各个位都有其特殊的含义</div><blockquote><p><strong>第0位</strong>：表示<strong>文件的类型</strong>，<strong>普通文件</strong><code>-</code>、<strong>链接</strong><code>l</code>、<strong>目录</strong><code>d</code>、<strong>字符设备</strong><code>c</code>和<strong>块设备</strong><code>b</code></p></blockquote><blockquote><p><strong>1-3位</strong>：分别表示<strong>文件所有者</strong>对该文件是否有<strong>读</strong><code>r</code>、<strong>写</strong><code>w</code>和<strong>执行</strong><code>x</code>权限，若为<code>-</code>则<strong>表示没有</strong></p></blockquote><blockquote><p><strong>4-6位</strong>：<strong>所在组</strong>是否对该文件有<strong>对应权限</strong></p></blockquote><blockquote><p><strong>7-9位</strong>：<strong>其他用户</strong>是否对该文件有<strong>对应权限</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 读、写和执行权限对于文件和目录的含义是不同的</div><blockquote><p><strong>文件</strong>：<strong>读</strong>表示可以<strong>查看该文件</strong>，<strong>写</strong>表示可以<strong>修改该文件信息</strong>，<strong>执行</strong>表示可以<strong>执行该文件</strong></p></blockquote><blockquote><p><strong>目录</strong>：<strong>读</strong>表示可以<strong>查看目录信息以及其下有那些文件（可以ls）</strong>，<strong>写</strong>表示可以<strong>在其中创建、删除文件，以及目录的重命名</strong>，<strong>执行</strong>表示可以<strong>进入该目录</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 目录的读写权限不会影响文件的权限，但没有目录的执行权限，则无法访问其中文件</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 只有对目录有写权限，才能删除其下文件</div><blockquote><p><strong>剩余信息</strong>：分别表示<strong>硬链接数/（文件数+子目录数）</strong>、<strong>所有者</strong>、<strong>所在组</strong>、<strong>文件大小</strong>、<strong>最后修改期限</strong>和<strong>文件名字</strong></p></blockquote><p><strong>③权限修改</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> u表示所有者，g表示所在组，o表示其他人，a表示所有人</div><blockquote><p><code>chmod u=rwx,g=rx,o=x [文件路径/目录路径]</code>：修改<strong>对应的权限</strong></p></blockquote><blockquote><p><code>chmod o+w [文件路径/目录路径]</code>：给<strong>其他用户添加</strong>写权限，如果是<code>-</code>表示<strong>剥夺对应权限</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 有一种简洁的修改方法，其中r--为4，-w-为2，--x为1，rw-为6，依此类推，按照顺序与之对应</div><blockquote><p><code>chmod 761 [文件路径/目录路径]</code>：赋予该文件<strong>所有者所有权限</strong>，<strong>所在组读写权限</strong>，<strong>其他人执行权限</strong></p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 工具链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 工作流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux工作流（二）</title>
      <link href="/2023/12/10/linux-gong-zuo-liu-er/"/>
      <url>/2023/12/10/linux-gong-zuo-liu-er/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux工作流"><a href="#Linux工作流" class="headerlink" title="Linux工作流"></a>Linux工作流</h1><h2 id="Linux实用工具"><a href="#Linux实用工具" class="headerlink" title="Linux实用工具"></a>Linux实用工具</h2><h3 id="1-VIM编辑器"><a href="#1-VIM编辑器" class="headerlink" title="1.VIM编辑器"></a>1.VIM编辑器</h3><h4 id="1-1工作模式"><a href="#1-1工作模式" class="headerlink" title="1.1工作模式"></a>1.1工作模式</h4><blockquote><p><strong>普通模式</strong>：<strong>刚进入</strong><code>VIM</code>或者<strong>从其他模式</strong>按下<code>ESC</code>退出</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在该模式下，可以使用某些控制键或者按下冒号:并输入相关指令进行操作，如退出q、保存w和撤销u</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 该模式下，还可以使用kjhl代替上下左右</div><blockquote><p><strong>插入模式</strong>：<strong>普通模式</strong>按下<strong>某些按键</strong>进入，<strong>常常</strong>是<code>i</code></p></blockquote><blockquote><p><strong>可视模式</strong>：可以<strong>选中一块区域</strong>进行<strong>编辑</strong></p></blockquote><h4 id="1-2常用操作"><a href="#1-2常用操作" class="headerlink" title="1.2常用操作"></a>1.2常用操作</h4><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 这里的操作都是在普通模式下的，如果处于其他模式，需要退回到普通模式</div><p><strong>①插入操作</strong></p><blockquote><p><code>i</code>：进入<strong>插入模式</strong>，并从<strong>光标当前位置</strong>开始<strong>输入文本</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> a类似于i，不过是从光标下一位置开始输入文本</div><blockquote><p><code>s</code>：<strong>删除光标当前位置字符</strong>，并进入<strong>插入模式</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> x类似s，但是不会进入插入模式</div><blockquote><p><code>o</code>：在<strong>光标下方开新行</strong>并进入<strong>插入模式</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> shift+i进行行首插入，shift+a进行行尾插入，shift+o在光标上方开新行插入</div><p><strong>②复制粘贴</strong></p><blockquote><p><code>d</code>：<strong>剪切</strong>，该操作需要<strong>指定一个范围</strong>，<code>dd</code>剪切<strong>整行</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 常用的范围有d+数字+左/右方向键、d+w、d+i+[符号]</div><blockquote><p><code>dh5</code>表示从<strong>当前光标处</strong>，<strong>向左</strong>剪切<strong>五个字符</strong>，<code>dw</code>表示<strong>从当前光标处</strong>到<strong>下一个词头</strong>，<code>di"</code>表示<strong>从当前光标的前一个”到后一个”</strong></p></blockquote><blockquote><p><code>y</code>：<strong>复制</strong>，<strong>操作原理</strong>同<code>d</code></p></blockquote><blockquote><p><code>p</code>：<strong>粘贴</strong></p></blockquote><p><strong>③搜索</strong></p><blockquote><p><code>f[x]</code>：将<strong>光标</strong>移动到其后<strong>下一个x字符处</strong></p></blockquote><blockquote><p><code>:/[xxx]</code>：将<strong>光标</strong>移动到其后<strong>下一个匹配的xxx处</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 匹配完成后，使用N/n跳转到上/下一个匹配处</div><h4 id="1-3配置文件"><a href="#1-3配置文件" class="headerlink" title="1.3配置文件"></a>1.3配置文件</h4><p><strong>①配置文件生成</strong></p><blockquote><p>在<strong>家目录</strong>下创建<code>.vim</code><strong>目录</strong>并在<strong>该目录</strong>下<strong>使用VIM</strong>创建<code>vimrc</code>文件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> vim在每次启动时会加载并更新配置文件，如果想要修改配置文件后立马更新，可以输入:source $MYVIMRC命令</div><p><strong>②常用语法</strong></p><blockquote><p><code>noremap [新键位] [原键位]</code>：<strong>键位映射</strong>，即按下<strong>新键位</strong>，<code>vim</code>会<strong>认为</strong>按下<strong>原键位</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> map类似于noremap，但是map可以递归，即map a b,map b c相当于map a c</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 键位可以不止一个键，而是一连串操作，可以用于设置快捷键，也可以将其替换为<nop>，逻辑上删除该键</nop></div><blockquote><p>如<code>map S :w&lt;CR&gt;</code>设置<strong>快速退出</strong>，<code>map s &lt;nop&gt;</code><strong>逻辑上删除</strong><code>s</code>键</p></blockquote><blockquote><p><code>syntax on</code>：打开<strong>代码高亮</strong></p></blockquote><blockquote><p><code>set [设置选项]</code>：<strong>打开/关闭</strong>某项设置，<strong>常用选项</strong>如下</p></blockquote><pre class="line-numbers language-none"><code class="language-none">set number 开启行号set relaivenumber 显示各行的相对距离set cursorline 光标下划线set wrap 让自不会超出窗口set showcmdset wildmenu 补全选择set hlsearch 高亮搜索set incsearch 边输入边高亮忽略大小写set ignorecaseset smartcase<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③插件安装</strong></p><blockquote><p>在github上下载<code>vim-plug</code>，为<code>vim</code>的一个<strong>插件管理</strong></p></blockquote><blockquote><p>根据说明在<strong>配置文件</strong>中输入<strong>以下代码</strong>，再使用<code>:pluginstall</code>即可<strong>下载插件</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">call plug#begin()Plug 'nsf/gocode' //nsf/gocode为插件完整库名call plug#end()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-编译与调试"><a href="#2-编译与调试" class="headerlink" title="2.编译与调试"></a>2.编译与调试</h3><h4 id="2-1GCC-x2F-G-编译器"><a href="#2-1GCC-x2F-G-编译器" class="headerlink" title="2.1GCC/G++编译器"></a>2.1GCC/G++编译器</h4><p><strong>①编译过程</strong></p><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> gcc用于编译C文件，g++用于编译C++文件，以C++为例，C语言将g++换为gcc即可</div><blockquote><p><strong>预处理</strong>：<code>g++ -E test.cpp -o test.i</code></p></blockquote><blockquote><p><strong>编译</strong>：<code>g++ -S test.i -o test.s</code></p></blockquote><blockquote><p><strong>汇编</strong>：<code>g++ -c test.s -o test.o</code></p></blockquote><blockquote><p><strong>链接</strong>：<code>g++ test.o -o test</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> -E、-S、-c限制编译过程停在对应步骤，-o指定输出文件名，以上四步可合并为g++ test.cpp -o test</div><p><strong>②常用选项</strong></p><blockquote><p><code>-g</code>：编译<strong>带调试信息</strong>的可执行文件</p></blockquote><blockquote><p><code>-O[n]</code>：<strong>优化代码</strong>，<code>n</code>表示<strong>不同等级</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 0表示不优化，1表示默认优化，23会进行一些对应的优化操作</div><blockquote><p><code>-l</code>：指定<strong>库文件</strong></p></blockquote><blockquote><p><code>-L</code>：指定<strong>库文件路径</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 默认去/lib、/usr/lib和/usr/local/lib中找对应库文件，如果没有，则需要用-L指定库文件路径</div><blockquote><p><code>g++ -L/home/zfk/mylib -ltestlib test.cpp</code></p></blockquote><blockquote><p><code>-I</code>：指定<strong>头文件路径</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 编译器默认在当前编译目录、/usr/include和/usr/local/include寻找对应头文件</div><blockquote><p><code>-Wall</code>：打印<strong>警告信息</strong>，可以使用<code>-w</code><strong>关闭</strong></p></blockquote><blockquote><p><code>-std=c++11</code>：指定<strong>编译标准</strong></p></blockquote><blockquote><p><code>-D[宏名]</code>：<strong>定义宏</strong></p></blockquote><blockquote><p><code>-U[宏名]</code>：<strong>取消</strong>对应<strong>宏的定义</strong></p></blockquote><p><strong>③库文件生成</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 当编译多个源文件时，可以将其一起编译，也可以将一部分源文件制作为动态库/静态库引入</div><blockquote><p><strong>静态库</strong>：先生成对应源文件的<strong>二进制文件</strong>，再将其<strong>转化为静态库文件</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 转化为二进制的过程和正常的编译过程一样，若其在非默认位置包含头文件，也需要指明头文件路径</div><pre class="line-numbers language-none"><code class="language-none">g++ -c test.cpp ar rs libTest.a test.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><strong>动态库</strong>：先生成对应源文件的<strong>二进制文件</strong>，再将其<strong>转化为动态库文件</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 动态库文件若不在默认位置，执行链接该动态库的可执行文件时，需要手动说明</div><blockquote><p><code>LD_LIBRARY_PATH=src ./sharemain</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">gcc -c -fPIC test.cpp  gcc -shared -o libTest.so test.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-2GDB调试器"><a href="#2-2GDB调试器" class="headerlink" title="2.2GDB调试器"></a>2.2GDB调试器</h4><p><strong>①基础操作</strong></p><blockquote><p><code>gdb [可执行文件名]</code>：用<strong>gdb打开</strong>该可执行文件并<strong>进入gdb界面</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 该可执行文件在编译时需要有-g选项，否则无法使用gdb打开</div><blockquote><p><code>h [gdb命令]</code>：查看<strong>命令帮助</strong></p></blockquote><blockquote><p><code>q</code>：<strong>退出</strong>gdb</p></blockquote><p><strong>②过程控制</strong></p><blockquote><p><code>start</code>：<strong>重新开始</strong>运行文件，并停在<strong>第一行执行语句</strong></p></blockquote><blockquote><p><code>r</code>：<strong>重新开始</strong>运行文件，直到<strong>程序结束</strong>或者<strong>遇到断点</strong></p></blockquote><blockquote><p><code>n</code>：执行<strong>下一条语句</strong>，如果下一条是函数则会<strong>直接执行该函数</strong></p></blockquote><blockquote><p><code>s</code>：执行<strong>下一条语句</strong>，如果下一条是函数则会<strong>进入该函数</strong></p></blockquote><blockquote><p><code>c</code>：<strong>继续执行</strong>，直到<strong>程序结束</strong>或者<strong>遇到断点</strong></p></blockquote><blockquote><p><code>b [行号n]</code>：在<strong>第n行</strong>设置<strong>断点</strong></p></blockquote><blockquote><p><code>enable/disable/delete b [断点号]</code>：<strong>启用/禁用/删除</strong>断点</p></blockquote><p><strong>③显示查看</strong></p><blockquote><p><code>l [行号n]/[函数名fun]</code>：查看<strong>源文件第n行附近代码</strong>/<strong>函数内容</strong></p></blockquote><blockquote><p><code>p [变量]</code>：<strong>打印变量的值</strong></p></blockquote><blockquote><p><code>i [对象]</code>：查看<strong>对应内容</strong>，默认为<strong>函数内部局部变量的数值</strong>，若对象为<code>b</code>,则查看<strong>所有断点</strong>，当对象为<code>watch</code>时查看<strong>观察点</strong></p></blockquote><blockquote><p><code>display/undisplay [变量]</code>：<strong>追踪/取消追踪变量</strong>，即<strong>每次</strong>都会<strong>显示</strong>该变量的值</p></blockquote><blockquote><p><code>watch [变量]</code>：<strong>观察</strong>某变量，当该变量<strong>变化</strong>时，<strong>打印显示</strong></p></blockquote><blockquote><p><code>x/[数目][单位][进制][地址]</code>：查看<strong>对应地址开头的内存内容</strong>，<strong>数目x单位</strong>表示<strong>向后查看的长度</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 单位中b/h/w/g分别为单/双/四/八字节，d/t/o/x分别表示十/二/八/十六进制</div><p><strong>④函数管理</strong></p><blockquote><p><code>finish</code>：结束<strong>当前函数</strong>，返回到<strong>函数调用点</strong></p></blockquote><blockquote><p><code>bt</code>：查看函数的<strong>调用的栈帧</strong>，并显示<strong>层级关系</strong></p></blockquote><blockquote><p><code>f</code>：<strong>切换</strong>函数的<strong>栈帧</strong></p></blockquote><p><strong>⑤辅助功能</strong></p><blockquote><p><code>run [参数1] [参数2]...[参数N]</code>：进行命令行传参，传递给<code>argv[1] argv[2]...argv[N]</code></p></blockquote><blockquote><p><code>set</code>：<strong>修改/创建</strong>变量</p></blockquote><h3 id="3-VSCode"><a href="#3-VSCode" class="headerlink" title="3.VSCode"></a>3.VSCode</h3><h4 id="3-1引言"><a href="#3-1引言" class="headerlink" title="3.1引言"></a>3.1引言</h4><p><strong>①概述</strong></p><blockquote><p>一款<strong>轻量级且跨平台</strong>的<strong>IDE</strong></p></blockquote><p><strong>②打开</strong></p><blockquote><p><strong>终端</strong>中输入<code>code [工程目录路径]</code>，或者直接在<strong>UI界面</strong>打开<strong>工程目录</strong></p></blockquote><p><strong>③界面组成</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 主要由菜单栏、侧边栏、状态栏和编辑区组成，主要使用的是侧边栏，其余主要使用快捷键替代</div><blockquote><p><strong>资源管理器</strong>：显示<strong>工程目录</strong>、<strong>已打开文件</strong>、<strong>操作历史</strong></p></blockquote><blockquote><p><strong>搜索</strong>：搜索对应<strong>文件</strong>、<strong>变量</strong>等对象</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 支持大小写区分、全字匹配和正则表达式，手动开启关闭</div><blockquote><p><strong>Git</strong>：版本控制，需要<strong>安装Git依赖</strong></p></blockquote><blockquote><p><strong>Debug</strong>：运行与调试，需要<strong>安装GDB等依赖</strong></p></blockquote><blockquote><p><strong>扩展</strong>：安装<strong>插件</strong>，如<strong>C/C++<strong>、</strong>CMake</strong>、<strong>CMake Tools</strong>、<strong>Python</strong>等</p></blockquote><h4 id="3-2常用快捷键"><a href="#3-2常用快捷键" class="headerlink" title="3.2常用快捷键"></a>3.2常用快捷键</h4><p><strong>①窗口显示</strong></p><blockquote><p><code>ctrl+反引号</code>：打开<strong>终端</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 反引号即`</div><blockquote><p><code>ctrl+shift+E/F/G/D/U</code>：显示侧边栏中的<strong>资源管理器/搜索/Git/Debug/Output</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 均采用ctrl+b关闭或者再次开启</div><blockquote><p><code>ctrl+n/w</code>：<strong>新建/关闭</strong>当前文件</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 加上shift则是新建/关闭一个VSCode窗口</div><blockquote><p><code>ctrl+p</code>：显示<strong>跳转窗口</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 再加上shift则是打开命令面板</div><blockquote><p><code>ctrl+\</code>：<strong>新建</strong>一个<strong>编辑器</strong>并<strong>分屏</strong>，仅有<strong>当前文件</strong>，位于<strong>窗口左边</strong><br><strong>②跳转窗口</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 在跳转窗口输入不同的提示符会显示不同的内容</div><blockquote><p><code>?</code>：显示当前<strong>可执行的操作</strong></p></blockquote><blockquote><p><code>!</code>：显示<code>Errors</code>或<code>Warnings</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 按下F8跳转到下一个</div><blockquote><p><code>:</code>：后接<strong>数字</strong>，跳转<strong>当前文件</strong>的<strong>对应行</strong></p></blockquote><blockquote><p><code>#</code>：显示<strong>所有</strong>的<code>symbol</code></p></blockquote><blockquote><p><code>@</code>：显示<strong>当前文件</strong>的<code>symbol</code></p></blockquote><p><strong>③选取操作</strong></p><blockquote><p><code>Home/End</code>：将光标置于<strong>行首/尾</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 加上ctrl则是将光标置于文件首/尾部</div><blockquote><p><code>shift+Home/End</code>：选择从<strong>光标处</strong>到<strong>行首/尾</strong>的所有内容</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 加上ctrl则是选择从光标处到文件首/尾部的所有内容</div><blockquote><p><code>alt+UP/Down</code>：将<strong>光标所在行</strong>上下移</p></blockquote><blockquote><p><code>ctrl+shift+l</code>：同时选中<strong>所有</strong>和<strong>已选中内容相同</strong>的字段</p></blockquote><blockquote><p><code>shift+alt+Left/Right</code>：<strong>扩展/缩小</strong>选取范围</p></blockquote><p><strong>④辅助功能</strong></p><blockquote><p><code>shift+alt+f</code>：代码<strong>格式化</strong></p></blockquote><blockquote><p><code>F2</code>：同时修改<strong>所有对应变量</strong>，先<strong>选中对应变量</strong>再按下<code>F2</code></p></blockquote><blockquote><p><code>F12</code>：跳转到<strong>变量定义处</strong>，先<strong>选中对应变量</strong>再按下<code>F12</code></p></blockquote><blockquote><p><code>ctrl+tab</code>：在<strong>已打开文件</strong>中进行<strong>切换</strong></p></blockquote><blockquote><p><code>ctrl+c/v/s/f/z</code>：<strong>复制/粘贴/保存/查找/撤销</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> ctrl+shift+f表示在整个工程目录下查找</div><h4 id="3-3配置文件"><a href="#3-3配置文件" class="headerlink" title="3.3配置文件"></a>3.3配置文件</h4><p><strong>①常用宏</strong></p><blockquote><p><code>${workspaceFolder}</code>：<strong>当前工程目录</strong>的绝对路径</p></blockquote><blockquote><p><code>${fileDirname}</code>：<strong>当前文件</strong>所在<strong>目录路径</strong></p></blockquote><blockquote><p><code>${fileBasenameNoExtension}</code>：<strong>当前文件</strong>的<strong>文件名</strong></p></blockquote><p><strong>②<code>launch.json</code>文件</strong></p><blockquote><p>在<strong>Debug侧边栏</strong>创建，进入<code>launch.json</code>文件并点击<strong>右下角</strong>的<strong>添加配置</strong>按钮</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 用于配置该项目的调试功能，此处选择的配置为(gdb) 管道启动</div><blockquote><p>修改<code>program</code>为<strong>需要调试的可执行文件</strong>的绝对路径</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果后续需要添加task.json文件，则需要添加preLaunchTask项，其后跟task.json的label项</div><pre class="line-numbers language-none"><code class="language-none">{    "configurations": [    {        "name": "(gdb) 启动",        "type": "cppdbg",        "request": "launch",        "program": "${workspaceFolder}/test",        "args": [],        "stopAtEntry": false,        "cwd": "${fileDirname}",        "environment": [],        "externalConsole": false,        "MIMode": "gdb",        "setupCommands": [            {                "description": "为 gdb 启用整齐打印",                "text": "-enable-pretty-printing",                "ignoreFailures": true            },            {                "description": "将反汇编风格设置为 Intel",                "text": "-gdb-set disassembly-flavor intel",                "ignoreFailures": true            }        ]    }    ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>③<code>task.json</code>文件</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 设置调试前进行的构建工作，以便于修改文件后立马进行调试</div><blockquote><p>在<strong>命令窗口中</strong>输入<code>task</code>，选择<code>Tasks:Configure Task</code>，在根据<strong>编译器</strong>选择<strong>对应模板</strong>即可</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> task.json的本质就是一条命令，以下为以g++的例子，如果需要执行Cmake也是类似</div><blockquote><p><code>args</code>为传给<code>command</code>的<strong>命令行参数</strong>，以下<code>task</code>文件相当于执行<code>g++ -g [文件路径] -o [输出文件]</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">{"version": "2.0.0","tasks": [{"type": "cppbuild","label": "C/C++: g++ 生成活动文件","command": "/usr/bin/g++","args": ["-g","${file}","-o","${fileDirname}/${fileBasenameNoExtension}"],"options": {"cwd": "${fileDirname}"},"problemMatcher": ["$gcc"],"group": "build","detail": "编译器: /usr/bin/g++"}]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 工具链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 工作流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeoVim工作流</title>
      <link href="/2023/12/10/neovim-gong-zuo-liu/"/>
      <url>/2023/12/10/neovim-gong-zuo-liu/</url>
      
        <content type="html"><![CDATA[<h1 id="NeoVim"><a href="#NeoVim" class="headerlink" title="NeoVim"></a>NeoVim</h1><h2 id="NeoVim工作流"><a href="#NeoVim工作流" class="headerlink" title="NeoVim工作流"></a>NeoVim工作流</h2><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h3><h4 id="1-1NeoVim安装"><a href="#1-1NeoVim安装" class="headerlink" title="1.1NeoVim安装"></a>1.1NeoVim安装</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以Ubuntu系统为例</div><p><strong>①包管理器安装</strong></p><blockquote><p>在<strong>命令行</strong>中输入<code>sudo snap install nvim --classic</code>即可，下载完后，输入<code>nvim</code>即可打开<strong>NeoVim</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 使用snap能下载到最新版本</div><h4 id="1-2配置文件"><a href="#1-2配置文件" class="headerlink" title="1.2配置文件"></a>1.2配置文件</h4><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 工具链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeoVim编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPT制作（基础篇）</title>
      <link href="/2023/12/10/ppt-zhi-zuo-ji-chu-pian/"/>
      <url>/2023/12/10/ppt-zhi-zuo-ji-chu-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="PPT制作（基础篇）"><a href="#PPT制作（基础篇）" class="headerlink" title="PPT制作（基础篇）"></a>PPT制作（基础篇）</h1><h2 id="PPT风格矩阵"><a href="#PPT风格矩阵" class="headerlink" title="PPT风格矩阵"></a>PPT风格矩阵</h2><h3 id="1-配色"><a href="#1-配色" class="headerlink" title="1.配色"></a>1.配色</h3><h4 id="1-1主色"><a href="#1-1主色" class="headerlink" title="1.1主色"></a>1.1主色</h4><p><strong>①根据logo选择</strong></p><blockquote><p>学校、企业<strong>logo</strong></p></blockquote><p><strong>②根据风格选择</strong></p><blockquote><p>比如说<strong>黑金风</strong>就是<strong>黑色</strong>和<strong>金色</strong>，<strong>科技风</strong>经常是<strong>蓝色</strong>和<strong>青色</strong>，<strong>党政风</strong>是<strong>红色</strong>和<strong>黄色</strong></p></blockquote><p><strong>③根据主题选择</strong>：</p><blockquote><p>比如说<strong>医疗行业</strong>对应的是<strong>蓝色</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以在网上搜索对应关键字，提取配色</div><h4 id="1-2辅助色"><a href="#1-2辅助色" class="headerlink" title="1.2辅助色"></a>1.2辅助色</h4><p><strong>①邻近色</strong>：</p><blockquote><p><strong>基于主色</strong>调整<strong>色调</strong>，用于区分不同<strong>维度</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 右击色块→填充→其他颜色填充→颜色模式改为“HSL”→调整色调数值</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 跨度最好在45以内，20较佳</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 色调数值的界限时0-255，所以-15相当于240，270相当于15</div><p><strong>②梯度色</strong></p><blockquote><p>调整<strong>亮度</strong>，用于区分不同<strong>层级</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 右击色块→填充→其他颜色填充→颜色模式改为“HSL”→调整亮度数值</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 设计选项卡→变体选项卡→颜色→自定义颜色→着色1，输入主色的色值即可</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_40.png" alt="辅助色矩阵"><br><strong>③相关网站</strong></p><blockquote><p><a href="https://color.adobe.com/zh/">Adobe Color</a>、<a href="https://arco.design/palette/list">Palette</a>、<a href="https://colorsupplyyy.com/app">撞色</a>、<a href="https://webgradients.com/">渐变色</a></p></blockquote><hr><h3 id="2-修饰边框"><a href="#2-修饰边框" class="headerlink" title="2.修饰边框"></a>2.修饰边框</h3><h4 id="2-1形状"><a href="#2-1形状" class="headerlink" title="2.1形状"></a>2.1形状</h4><p><strong>①轮廓</strong></p><blockquote><p><strong>矩形</strong>：工业、商务和力量</p></blockquote><blockquote><p><strong>圆角矩形</strong>：卡通、儿童和女性</p></blockquote><blockquote><p><strong>去角矩形</strong>：文化、国风和传统</p></blockquote><blockquote><p><strong>平行四边形</strong>：运动、速度和竞赛</p></blockquote><blockquote><p><strong>折角</strong>：科技、未来</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 插入基础图形→右击→编辑顶点→每个顶点对应两个控点，拖动控点即可做出有弧度的图形</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 比较新颖的形状可以在素材网站上寻找，记得要下载矢量图（SVG）</div><p><strong>②填充</strong></p><blockquote><p><strong>色块填充</strong>：<strong>纯色</strong>和<strong>渐变色</strong></p></blockquote><blockquote><p><strong>纹理填充</strong>：找到<strong>纹理素材</strong>→在ppt中将<strong>纹理图片和形状重叠</strong>→<strong>先选形状，后选纹理</strong>→<strong>形状选项卡</strong>→<strong>合并形状</strong>→<strong>剪除</strong></p></blockquote><h4 id="2-2效果"><a href="#2-2效果" class="headerlink" title="2.2效果"></a>2.2效果</h4><p><strong>①立体</strong></p><blockquote><p><strong>设置渐变</strong>：两个<strong>颜色一致</strong>的光圈→<strong>第一个光圈</strong>亮度调整至<strong>70％</strong>→<strong>渐变类型</strong>调整为<strong>射线渐变</strong>，<strong>方向</strong>调整为<strong>从左上角</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 适当调整两个光圈位置调整效果，如两个光圈位置分别在15%和85%</div><blockquote><p><strong>添加映像效果</strong>：选择<strong>第一个预设</strong>，<strong>透明度</strong>85％，<strong>大小</strong>20％左右，适当添加<strong>模糊</strong>效果</p></blockquote><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_41.png" alt="立体"><br><strong>②光泽</strong></p><blockquote><p><strong>设置渐变</strong>：选择<strong>线性渐变</strong>，<strong>方向</strong>调整为45°→<strong>左右两侧光圈</strong>设置为<strong>主色</strong>→<strong>中间</strong>添加<strong>一到两个光圈</strong>，颜色设置为<strong>背景色</strong>，<strong>透明度</strong>设置为100</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 适当调整两个光圈位置调整效果</div><blockquote><p>将<strong>轮廓</strong>设置为<strong>实线</strong>,并<strong>同上</strong>添加<strong>映像</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 轮廓线的亮度最好比主色高一些</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_42.png" alt="光泽"><br><strong>③新拟态</strong></p><blockquote><p><strong>凸起</strong>：<strong>形状颜色</strong>和<strong>背景色</strong>相同，<strong>去除轮廓</strong>，给<strong>两个相同的形状</strong>添加<strong>外阴影</strong>，<strong>方向对立</strong>（比如说右下45°和左上45°），一个阴影的<strong>色调</strong>比背景色<strong>暗</strong>，一个阴影的<strong>色调</strong>比背景<strong>亮</strong>，然后<strong>重叠这两个形状</strong></p></blockquote><blockquote><p><strong>凹陷</strong>：<strong>形状颜色</strong>和<strong>背景色</strong>相同，<strong>去除轮廓</strong>，给两个<strong>相同的形状</strong>添加<strong>内阴影</strong>，<strong>方向对立</strong>（比如说右下45°和左上45°），一个阴影的<strong>色调</strong>比背景色<strong>暗</strong>，<strong>复制</strong>其中一个，对另一个进行<strong>图片纹理填充</strong>（剪切板）即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 表现为凹凸不平的图形</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 适当调节阴影的距离和模糊使其更加柔和</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 背景不能是纯白纯黑，可以是灰色，淡蓝色等</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_43.png" alt="新拟态"><br><strong>④毛玻璃</strong></p><blockquote><p>对<strong>背景图</strong>做<strong>全屏虚化</strong>（100即可），再将<strong>正常背景图覆盖</strong>在上面，添加色块，将<strong>色块颜色</strong>改为<strong>幻灯片背景填充</strong>即可，这个<strong>色块</strong>就是<strong>一块毛玻璃</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 还可以添加白色描边、内阴影使其更加逼真</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_44.png" alt="毛玻璃"><br><strong>⑤发光</strong></p><blockquote><p><strong>内发光</strong>：<strong>射线渐变（圆形）/路径渐变（调整方向）</strong>，<strong>左光圈</strong>为<strong>背景色</strong>（<strong>透明度</strong>调节为100%），<strong>右光圈</strong>为<strong>发光色</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 调整光圈位置调整发光效果</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 设置好渐变参数后，先点击纯色填充，再点击渐变填充可以使得发光效果更强</div><blockquote><p><strong>外发光</strong>：<strong>复制</strong>对应图形，<strong>柔化边缘</strong>，将其与<strong>原图形重叠</strong>，<strong>调整大小</strong>即可</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 柔化边缘的磅数可以适当大一些</div><blockquote><p><strong>发光平台</strong>：<strong>渐变透明</strong>的<strong>梯形</strong>，<strong>从上往下</strong>的渐变，一个光圈为<strong>背景色</strong>，一个光圈为<strong>主色</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 梯形、矩形和平行四边形（侧面）组合可以成为三维平台，其中正面的透明度应该比上平面的透明度低</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 给边框添加光效素材，使其更漂亮</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_45.png" alt="发光"></p><h4 id="2-3参考网站"><a href="#2-3参考网站" class="headerlink" title="2.3参考网站"></a>2.3参考网站</h4><blockquote><p><a href="https://www.freepik.com/">freepik</a>、<a href="https://huaban.com/">花瓣网</a>、<a href="https://www.zcool.com/">zcool</a>、<a href="www.pinterest.com">pinterest</a></p></blockquote><hr><h3 id="3-修饰"><a href="#3-修饰" class="headerlink" title="3.修饰"></a>3.修饰</h3><h4 id="3-1背景"><a href="#3-1背景" class="headerlink" title="3.1背景"></a>3.1背景</h4><p><strong>①基调</strong></p><blockquote><p><strong>基于环境</strong>：当<strong>环境比较明亮</strong>时采用<strong>浅色</strong>，当<strong>环境比较暗</strong>时采用<strong>深色</strong></p></blockquote><blockquote><p><strong>基于主色</strong>：当<strong>主色</strong>为<strong>浅色</strong>时，采用<strong>深色背景</strong>，<strong>反之</strong>采用<strong>浅色背景</strong></p></blockquote><blockquote><p><strong>基于风格</strong>：比如<strong>科技风</strong>经常采用<strong>深色渐变背景</strong></p></blockquote><p><strong>②类型</strong></p><blockquote><p><strong>图片背景</strong>：常作为<strong>封面</strong>背景</p></blockquote><blockquote><p><strong>色块背景</strong>：常作为<strong>正文</strong>背景，可以是<strong>纯色</strong>，也可以是<strong>渐变色</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 渐变背景：使用两个光圈，一个为主色，一个为白色，选择合适的渐变方向，提高主色光圈亮度即可（80%-90%）</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以修改幻灯片母版修改每一张幻灯片，视图选项卡→幻灯片母版</div><h4 id="3-2字体"><a href="#3-2字体" class="headerlink" title="3.2字体"></a>3.2字体</h4><p><strong>①种类</strong></p><blockquote><p>字体种类最好<strong>不超过两种</strong>，一般<strong>正文</strong>采用<strong>黑体</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一般来说中文和西文的字体是不一样的，在调整两种字体都有的段落时，先整体设置中文，再设置英文</div><p><strong>②风格</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 一般只有标题能使用风格字体，字体风格要和ppt整体风格相符合</div><blockquote><p><strong>黑体</strong>：力量、动感和科技</p></blockquote><blockquote><p><strong>宋体</strong>：文化、庄严和雅致</p></blockquote><blockquote><p><strong>书法</strong>：豪迈、奔放和大气</p></blockquote><p><strong>③粗细</strong></p><blockquote><p><code>light</code>、<code>regular</code>和<code>bold</code>为常见的三种<strong>字体字重</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 使用粗体，不要使用ppt自带的字体加粗，而是采用字体本身的bold类型</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> ppt主题字体设置：设计选项卡→变体分区→字体→自定义字体</div><h4 id="3-3素材"><a href="#3-3素材" class="headerlink" title="3.3素材"></a>3.3素材</h4><p><strong>①图标</strong></p><blockquote><p>填补/代替<strong>标题或小标题</strong>，使其更加<strong>生动饱满</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 图标主要有填充型和线条型，不要混用</div><p><strong>②图案</strong></p><blockquote><p><strong>不同风格</strong>使用<strong>不同的素材</strong>修饰，使其更加<strong>饱满</strong>，比如<strong>中国风</strong>有<strong>笔刷</strong>、<strong>祥云</strong>、<strong>卷轴</strong>等</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 也可以将ppt中的某些形状、边框等替换为类似的素材</div><p><strong>③素材网站</strong></p><blockquote><p><strong>图标</strong>：<a href="https://www.flaticon.com/">flaticon</a>、<a href="https://iconpark.oceanengine.com/official">iconpark</a></p></blockquote><blockquote><p><strong>图案</strong>：<a href="https://www.freepik.com/">freepik</a>、<a href="https://huaban.com/">花瓣网</a>、<a href="https://www.zcool.com/">zcool</a>、<a href="www.pinterest.com">pinterest</a></p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 工作流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPT制作（进阶篇）</title>
      <link href="/2023/12/10/ppt-zhi-zuo-jin-jie-pian/"/>
      <url>/2023/12/10/ppt-zhi-zuo-jin-jie-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="PPT制作（进阶篇）"><a href="#PPT制作（进阶篇）" class="headerlink" title="PPT制作（进阶篇）"></a>PPT制作（进阶篇）</h1><h2 id="一、封面页"><a href="#一、封面页" class="headerlink" title="一、封面页"></a>一、封面页</h2><h3 id="1-标题排版"><a href="#1-标题排版" class="headerlink" title="1.标题排版"></a>1.标题排版</h3><p><strong>1.1换行有节奏</strong>：当标题过长时，可以将标题分为多行，每一行要<strong>完整且相对独立</strong>，且<strong>长短交错</strong>，否则会很呆板<br><strong>1.2对比有重点</strong>：使标题有层次感，突出重点<br>①调粗细：粗体（Bold）用于标题，标准（Regular）用于副标题、正文（比如说汇报人什么什么<br>②变大小：一般来说标题为第一层级，副标题为第二层级，正文为第三层级，不同信息层级字体大小成<strong>倍数关系</strong>，如（60-20-15）<br>③换颜色：将标题字体颜色更换为<strong>PPT主色</strong>，可以采用渐进色进行修饰<br>④改间距：调整各个层级之间的间距使其不要太拥挤<br>⑤特殊效果：如倾斜、错位排版等<br>#倾斜：选中文本框→形状格式→文本效果→转换→正方形→拖动控点控制文字的倾斜角度</p><h3 id="2-背景图片"><a href="#2-背景图片" class="headerlink" title="2.背景图片"></a>2.背景图片</h3><p><strong>2.1图片网站</strong><br>①unsplash.com<br>②<a href="http://www.pexels.com/">www.pexels.com</a><br>③pixabay.com<br><strong>2.2图片选择</strong><br>①语意关联：根据<strong>关键词</strong>寻找配图<br>②留白空间：根据标题的排版，选择一张对应位置有留白的图片<br>③色调匹配：图片色调要和PPT主色相符合</p><h3 id="3-构图形式"><a href="#3-构图形式" class="headerlink" title="3.构图形式"></a>3.构图形式</h3><p><strong>3.1布局选择</strong><br>①居中构图：当图片为上下构图时，采用居中布局，图片主体占图片的1/3<br>②居左布局：图片为左右构图时，采用居左布局，图片主体占图片的1/2<br>③根据图片留白放置标题<br><strong>tips：可以通过裁剪，获得想要的留白空间</strong><br><strong>3.2图形凸显</strong>：降低图片对文字的干扰<br>①色块：使用<strong>一定颜色的形状</strong>作为图片的衬底，调整透明度使其更为自然<br>②蒙版：渐变透明的蒙版<br>#全屏蒙版：插入全屏矩形→选择<strong>线性渐变</strong>→渐变方向<strong>根据封面布局</strong>选择，比如居中布局采用自上而下，居左布局采用自左向右→光圈颜色选择背景图片的主色→将<strong>非文字区域</strong>的光圈透明度调整为100→调整光圈位置，使其更加自然<br>#局部蒙版：插入刚好能覆盖文案的形状（比较推荐椭圆）→设置为无轮廓→选择<strong>路径渐变</strong>→光圈颜色采用图片的主色→右侧光圈透明度调节为100→调整光圈位置，将<strong>图片置于底层</strong><br><strong>tips：如果觉得蒙版破坏了图片主体，可以将图片主体扣出来</strong><br><strong>等距缩放，为了让左右和上下的边距相等，可以创建一个小正方形，置于形状的左上角，按住ctrl键缩放即可</strong></p><h2 id="二、排版"><a href="#二、排版" class="headerlink" title="二、排版"></a>二、排版</h2><h3 id="1-文字排版"><a href="#1-文字排版" class="headerlink" title="1.文字排版"></a>1.文字排版</h3><p><strong>1.1对齐</strong>：不要使用首行缩进，这样会导致文本不够饱满，最好采用<strong>两端对齐</strong><br><strong>1.2调整间距</strong><br>①本身：标题字号较大，采用1.0倍行距，正文字号比较小，采用1.2-1.5倍行距<br>②相互：<strong>标题和正文间距＞段落间距＞行间距＞字间距</strong><br>#可以采用<strong>分隔线</strong>突出重点段落，比如副标题<br><strong>1.3控制行长</strong>：行长最好<strong>略小于页面的二分之一</strong>，可以采用多段左右、上下分布，<strong>避免出现独字</strong></p><h3 id="2-内容排版"><a href="#2-内容排版" class="headerlink" title="2.内容排版"></a>2.内容排版</h3><p><strong>2.1梳理文案信息</strong><br>①分段：将一段文字内容分为<strong>独立的几个维度</strong><br>②精简：删除<strong>连接词和重复词语</strong>，提炼核心内容<br>③凸显层级和重要内容：大小对比、颜色对比、粗细对比、距离对比、下划线、色块、字体对比<br><strong>2.2确定版式布局</strong><br>①统一版心，利用<strong>参考线</strong>确定标题区域和正文区域<br>#可以先创建一个全屏矩形，然后等比缩放，调节至合适大小，分布在ppt四角<strong>确定留白区域</strong>，随后在非留白区域确定标题位置和正文位置，标题位置和正文位置之间<strong>相隔一个标题高度</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_1.png" alt="统一版心"><br>②内容分块：利用<strong>色块、形状</strong>等根据文案信息对正文位置进行分块<br>#注意色块、形状等<strong>修饰内容可以占用留白区域</strong>，只要正文内容按照格式排版即可<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_2.png" alt="内容分块"><br><strong>2.3内容可视化</strong><br>①图标：给小标题增加合适的图标<br>#素材网站:<a href="https://www.flaticon.com/">https://www.flaticon.com/</a> <a href="https://iconpark.oceanengine.com/official">https://iconpark.oceanengine.com/official</a> <a href="http://www.iconfont.cn/">www.iconfont.cn</a><br>#可以将图标截图，并将<strong>位图转化为矢量图</strong>，这样就可以在ppt中修改格式了<br>②图片：给<strong>文本块</strong>增加对应的图片背景等<br>③逻辑图示：流程图、带有<strong>关系暗示</strong>的图形等等<br>#并列、包含、流程、循环和层级<br>#素材网站：<a href="https://www.freepik.com/">https://www.freepik.com/</a><br><strong>2.4实例</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_3.png" alt="实例一"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_4.png" alt="实例二"></p><h3 id="3-多点排版"><a href="#3-多点排版" class="headerlink" title="3.多点排版"></a>3.多点排版</h3><p><strong>3.1中心环绕式布局</strong><br>①全圆式布局：段落数量为<strong>偶数</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_5.png" alt="全圆式布局"><br>②半圆式布局：段落数量为<strong>奇数</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_6.png" alt="半圆式布局"><br>#可以利用等比例缩放绘制圆辅助线，并<strong>利用对齐</strong>将段落点贴近辅助线<br><strong>3.2确定中心点样式</strong><br>①基本形状：并不一定要局限于圆形，还可以是其他多边形<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_7.png" alt="基本图形"><br>②图片素材：选取符合主题的图片<br><strong>3.3丰富层次</strong><br>①文本层次<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_9.png" alt="文本层次"><br>②图形层次<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_8.png" alt="图形层次"></p><h3 id="4-多图排版"><a href="#4-多图排版" class="headerlink" title="4.多图排版"></a>4.多图排版</h3><p><strong>4.1尺寸</strong>：图片格式→裁剪→纵横比，将图片裁剪为比例一致的图片，然后再调整大小<br><strong>4.2间距</strong>：利用<strong>对齐</strong>，注意<strong>图片之间</strong>的间距要小于<strong>图片和页面之间</strong>的间距<br><strong>4.3效果</strong><br>①形状：将图片裁剪为特定形状，图片格式→裁剪→形状<br>②轮廓：给图片加上边框<br>③阴影：ctrl拖动复制图片→图片格式→艺术效果→虚化→调整虚化半径（调整为90）→柔化边缘→将该图片拖动到原图片底部<br>④映像：ctrl拖动复制图片→图片格式→映像效果→选择第一个预设→调整映像大小→增加模糊度<br>#可以设置好一张图片效果，然后采用<strong>格式</strong>刷快速复制<br><strong>4.4创意排版</strong><br>①瀑布流<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_10.png" alt="瀑布流"><br>②三维旋转<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_11.png" alt="平行预设"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_12.png" alt="角度预设"><br><strong>#要将光源改为对比</strong>，防止过曝</p><p><strong>5.创意排版</strong><br><strong>5.1分栏排版</strong>：利用<strong>色块、图片等</strong>将不同维度内容分隔开<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_34.png" alt="分栏排版"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_35.png" alt="示例"><br><strong>5.2拦腰排版</strong>：用于需要突出重点内容的<strong>总分关系</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_36.png" alt="拦腰排版"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_37.png" alt="示例"><br><strong>5.3卡片排版</strong>：变种的分栏排版，注意卡片组合起来要是一个规整的矩形（可以有无内容色块），<strong>形状和间距相同</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_38.png" alt="拦腰排版"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_39.png" alt="示例"></p><p>#配色可以采用主色+<strong>黑白灰</strong>/主色的梯度色<br>#当内容不够饱满时，可以插入<strong>图片</strong></p><h2 id="三、特殊要素"><a href="#三、特殊要素" class="headerlink" title="三、特殊要素"></a>三、特殊要素</h2><h3 id="1-表格"><a href="#1-表格" class="headerlink" title="1.表格"></a>1.表格</h3><p><strong>1.1大小</strong><br>①整体大小：要<strong>占满版心</strong><br>②单元格大小：全选表格→<strong>布局选项卡</strong>调整单元格高度→然后双击单元格的<strong>竖边</strong>，使得<strong>单元格宽度匹配文本宽度</strong><br><strong>1.2样式</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_13.png" alt="表格样式"><br>①选择<strong>无样式</strong>的表格样式，随后自己编辑<br>②线条型表格的<strong>内部框线不宜太粗</strong>，防止喧宾夺主，<strong>表头</strong>、<strong>表尾</strong>和<strong>分割表格</strong>的框线可以适当增粗<br>③色块型表格，可以在表格<strong>底部</strong>添加<strong>对应大小颜色</strong>的色块，也可以对表格进行颜色填充，但是后者是对<strong>每个单元格</strong>进行对应填充且<strong>不能改变形状</strong>，在使用渐变色时还是使用前者<br><strong>1.3对齐</strong>：文本左对齐，数据右对齐<br>①如果遇到小数，位数要统一<br>②文本内容过多，可以分点介绍<br><strong>1.4突出重点</strong>：粗细、颜色、衬底<br><strong>1.5可视化</strong><br>①文本可视化：利用图标、图片代替文字或者作为背景<br>②数据可视化：比如百分比可以利用对应的进度条和饼状图代替<br><strong>1.6实例</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_14.png" alt="实例一"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_15.png" alt="实例二"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_16.png" alt="实例三"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_17.png" alt="实例四"></p><h3 id="2-时间轴"><a href="#2-时间轴" class="headerlink" title="2.时间轴"></a>2.时间轴</h3><p><strong>2.1时间轴线</strong><br>①直线：渐变、箭头<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_18.png" alt="直线"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_21.png" alt="示例"><br>②不规则线条：曲线、折线<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_19.png" alt="曲线绘制"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_20.png" alt="示例"><br>#注意其中的技巧三，可以在<strong>ppt画面之外</strong>使其形成一个封闭图形，并进行<strong>颜色填充</strong>，如示例所示<br>③实物元素<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_22.png" alt="实物元素"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_23.png" alt="示例"><br><strong>2.2节点</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_24.png" alt="节点"><br>①还可以使用图标<br>②节点<strong>外发光</strong>效果：去除线条→<strong>偏移为中</strong>的<strong>阴影</strong>预设→透明度将为0→调整<strong>大小</strong>从而调节发光范围<br>③节点<strong>内发光</strong>效果：<strong>射线</strong>渐变→方向改为<strong>从中心</strong>→<strong>左侧</strong>光圈改为<strong>背景色</strong>，调整为<strong>完全透明</strong>→调整光圈位置即可<br><strong>2.3文案排版</strong><br>①文本层次<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_9.png" alt="文本层次"><br>②文本修饰：在节点和文案之间添加<strong>直线</strong>等元素进行<strong>联系</strong></p><h3 id="3-架构图"><a href="#3-架构图" class="headerlink" title="3.架构图"></a>3.架构图</h3><p><strong>3.1确定走向</strong><br>①自上而下：适合分支较<strong>少</strong>的架构图<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_25.png" alt="示例"><br>②自左向右：适合分支较<strong>多</strong>的架构图<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_26.png" alt="示例"><br>③中心扩散：适合分支较<strong>多</strong>的架构图<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_27.png" alt="示例"><br><strong>3.2元素形状</strong><br>①衬底图形<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_28.png" alt="衬底图形"><br>#还可以将这些基本图形<strong>结合</strong>到一起形成新的衬底<br>②连接线条<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_29.png" alt="连接线条"><br>#其中曲线型连接可以采用<strong>花括号</strong>和箭头等组合而来<br>#可以在形状格式中修改箭头、花括号的<strong>末端形状</strong><br><strong>3.3区分层级</strong><br>①颜色对比：不同层级采用不同的颜色（最好<strong>梯度色</strong>），其中衬底颜色和文字颜色<strong>色调要相反</strong>，即衬底为深色，文字就要为浅色<br>②虚实对比：当层级过多，颜色对比不够用时，末端可以采用<strong>无填充、虚线框</strong>的形式<br>③形状对比<br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_30.png" alt="示例"></p><h3 id="4-图表"><a href="#4-图表" class="headerlink" title="4.图表"></a>4.图表</h3><p><strong>4.1确定样式</strong><br>①柱形图：大小比较，项目名较短<br>②条形图：大小比较，项目名较长<br>③饼状图：占比关系<br>④环形图表：占比关系，可以使用弧形和圆组合而成，调<strong>粗</strong>其线宽，改变其<strong>线端类型</strong>，将弧形置于顶层即可<br>⑤折线图：变化趋势</p><p>#直接<strong>插入图表</strong>即可<br><strong>4.2图标优化</strong><br>①柱/条形图</p><ul><li>弱化或者删除<strong>网格</strong>、<strong>图例</strong>和<strong>坐标轴</strong>元素</li><li>间隙宽度<strong>50%-100%</strong></li><li>突出重点，利用<strong>颜色</strong>和<strong>色块衬底</strong>即可</li></ul><p>②饼状图</p><ul><li>扇面<strong>从大到小顺时针排序</strong></li><li>扇面配色避免花哨，使用<strong>梯度色</strong>即可</li></ul><p>③折线图</p><ul><li>弱化或者删除<strong>网格</strong>、<strong>图例</strong>和<strong>坐标轴</strong>元素</li><li>如果无需精确呈现数据时，可使用<strong>平滑线</strong>（右击→设计数据系列格式→填充与线条→勾选平滑线选项）</li><li>可以将其改变为<strong>面积图</strong>，对其进行<strong>渐变填充</strong>，但是如果要使用<strong>平滑线</strong>的话，不能将其改变为面积图，应该先将其改变为<strong>平滑线</strong>→新建一页，将图表<strong>选择性粘贴</strong>为<strong>图片（增强型图元文件）</strong>→取消组合，提取曲线→利用曲线和目标颜色色块进行<strong>组合拆分</strong>，将对应颜色色块裁剪为目标形状<strong>填充回原幻灯片</strong>即可</li></ul><p>#图表不仅仅局限于ppt图表自带的修饰，还可以自己利用<strong>线条、形状</strong>等素材对图表进行修饰，比如说用<strong>文本框</strong>代替图表原本的<strong>标题</strong>，用色块和文本框代替图例等<br>#可以使用<strong>数据标签</strong>代替纵轴</p><p><strong>4.3布局</strong><br>①单个图表：占满版心即可<br>②多个图表：利用<strong>色块</strong>对页面进行分区，将图表放在对应的色块中</p><p><strong>4.4实例</strong><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_31.png" alt="实例一"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_32.png" alt="实例二"><br><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/ppt_33.png" alt="实例三"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 工作流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PPT </tag>
            
            <tag> 软技能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记（一）</title>
      <link href="/2023/12/10/python-xue-xi-bi-ji-yi/"/>
      <url>/2023/12/10/python-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="python学习笔记（一）"><a href="#python学习笔记（一）" class="headerlink" title="python学习笔记（一）"></a>python学习笔记（一）</h1><h2 id="python启蒙"><a href="#python启蒙" class="headerlink" title="python启蒙"></a>python启蒙</h2><h3 id="1-基本元素"><a href="#1-基本元素" class="headerlink" title="1.基本元素"></a>1.基本元素</h3><h4 id="1-1对象"><a href="#1-1对象" class="headerlink" title="1.1对象"></a>1.1对象</h4><p><strong>①定义</strong></p><blockquote><p>即<strong>被存储的数据</strong>，如<code>1</code>、<code>"cat"</code>、<code>1.23456e2</code>等</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 类似于C语言中的字面值，当一个对象被声明后，会给其分配对应的地址和内存，且数据类型不能更改</div><p><strong>②基本数据类型</strong></p><blockquote><p><strong>整型</strong>、<strong>浮点型</strong>、<strong>字符串</strong>、<strong>布尔类型</strong>、<strong>复数类型</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以使用type()检查数据类型</div><p><strong>③分类</strong></p><blockquote><p><strong>不可变类型</strong>：对象<strong>一旦创建</strong>，内容就<strong>不能被更改</strong>，只能被<strong>覆盖</strong>，<strong>基本数据类型</strong>都是<strong>不可变类型</strong></p></blockquote><blockquote><p><strong>可变类型</strong>：对象的<strong>值可以被更改</strong>，如<strong>列表</strong>、<strong>集合</strong>和<strong>字典</strong>等</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在将可变数据类型传递给函数时，又不希望函数改变其值，可以在函数内部拷贝一份对应的值</div><p><strong>④数据类型转换</strong></p><blockquote><p><strong>自动类型转换</strong>：<strong>不同类型</strong>数据<strong>混合运算</strong>，<strong>精度低</strong>的类型将自动转化为<strong>精度高</strong>的类型<strong>避免数据丢失</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 自动转换类型功能有限，如整型不能自动转化为字符串类型，需要使用强制类型转换</div><blockquote><p><strong>强制类型转换</strong>：使用<code>str()</code>、<code>int()</code>、<code>float()</code>将对象<strong>强制转换</strong>为<strong>对应类型</strong></p></blockquote><h4 id="1-2变量"><a href="#1-2变量" class="headerlink" title="1.2变量"></a>1.2变量</h4><p><strong>①定义</strong></p><blockquote><p>本质是<strong>对象</strong>的一个<strong>引用</strong>，<strong>本身</strong>也占用<strong>一定的内存</strong>，用于存储<strong>对象的地址</strong>，通过<strong>赋值符</strong><code>=</code>为<strong>变量</strong>指定<strong>对象</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> python变量对应的内存是变化的，是上次赋值时新对象所在的内存，而C语言变量名所代表的地址是不变的</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 没有变量指向的对象会被回收，即python的垃圾回收机制</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 变量的本质是引用，如果两个变量指向是同一个可变类型对象，改变其中一个，另一个也随之改变</div><p><img src="/images/loading.gif# eg ./images/loading.gif" data-original="/image/python_7.png" alt="变量的本质"><br><strong>②取名规则</strong></p><blockquote><p>只能是<strong>一个词</strong>，且只包含<strong>字母、数字和下划线</strong>，<strong>不能以数字开头</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一个好的变量名包含了数据对应的信息，常见的命名格式有my_cat和MyCat</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意和关键词冲突</div><h4 id="1-3操作符"><a href="#1-3操作符" class="headerlink" title="1.3操作符"></a>1.3操作符</h4><p><strong>①数字操作符</strong></p><blockquote><p><strong>加</strong><code>+</code>、<strong>减</strong><code>-</code>、<strong>乘</strong><code>*</code>、<strong>除</strong><code>/</code>、<strong>取模</strong><code>%</code>、<strong>整除</strong><code>//</code>、<strong>指数</strong><code>**</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> C的除法结果由其操作数类型决定，而python的除法结果由其操作符决定</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> +可以用于拼接字符串，比如'a'+'b'结果是'ab'，*可以用于字符串复制，比如'a'*5结果时'aaaaa'</div><p><strong>②比较操作符</strong></p><blockquote><p><strong>等于</strong><code>==</code>、<strong>不等于</strong><code>!=</code>、<strong>小于</strong><code>&lt;</code>、<strong>大于</strong><code>&gt;</code>、<strong>小于等于</strong><code>&lt;=</code>、<strong>大于等于</strong><code>&gt;=</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> &gt;、&lt;、≥、≤只能用于整型和浮点型</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 整型和浮点型之间是可以使用==正常比较的，但是整型、浮点型和字符串使用==只能得到False</div><p><strong>③布尔操作符</strong></p><blockquote><p><strong>与</strong><code>and</code>、<strong>或</strong><code>or</code>、<strong>非</strong><code>not</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> not优先级最高，随后是and，最后是or</div><h4 id="1-4格式"><a href="#1-4格式" class="headerlink" title="1.4格式"></a>1.4格式</h4><p><strong>①注释</strong></p><blockquote><p><strong>单行注释</strong>：以<code>#</code><strong>开头</strong>，以<strong>换行符</strong>结尾</p></blockquote><blockquote><p><strong>多行注释</strong>：用<strong>三个单引号/双引号</strong>包围</p></blockquote><p><strong>②代码块</strong></p><blockquote><p>根据<strong>缩进</strong>划分<strong>代码块</strong>，<strong>相同缩进</strong>的<strong>连续代码</strong>为一<strong>代码块</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 代码块内部可以嵌套代码块，嵌套代码块的缩进更多</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 通常以四个空格为一个缩进，不要使用tab</div><p><strong>③语句</strong></p><blockquote><p><strong>语句</strong>使用<strong>换行符</strong>结尾，<strong>语句关键词语句</strong>使用<strong>冒号</strong>结尾</p></blockquote><h4 id="1-5控制流"><a href="#1-5控制流" class="headerlink" title="1.5控制流"></a>1.5控制流</h4><p><strong>①if条件语句</strong></p><pre class="line-numbers language-none"><code class="language-none">if(expression):   statementelif(expression):  statementelse:  statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 一旦一个语句的条件为Ture，后面的语句会被忽略，所以要注意语句的顺序，或者说清晰化条件的范围，使其之间没有交集</div><p><strong>②while循环语句</strong></p><pre class="line-numbers language-none"><code class="language-none">while(expression):  statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>③for循环语句</strong></p><pre class="line-numbers language-none"><code class="language-none">for 控制变量 in range():   statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 缺省情况下，控制变量被初始化为0</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 在Python中，下划线_通常用作一个无用的变量名称，常用做控制变量的名称</div><p><strong>④range函数</strong></p><blockquote><p><code>range(a)</code>：<code>0</code>至<code>a-1</code>，<strong>步长为1</strong></p></blockquote><blockquote><p><code>range(a,b)</code>：<code>a</code>至<code>b-1</code>，<strong>步长为1</strong></p></blockquote><blockquote><p><code>range(a,b,i)</code>：<code>a</code>至<code>b-1</code>,<strong>步长为i</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 可以将循环中的range()换为一个列表，在每次迭代中，让变量依次设置为列表中的值</div><p><strong>⑤循环控制语句</strong></p><blockquote><p><strong>break</strong>：遇到<code>break</code>语句，马上<strong>退出循环</strong><br><strong>continue</strong>：遇到<code>continue</code>语句，马上<strong>跳回到循环开始处</strong></p></blockquote><h4 id="1-6字符串"><a href="#1-6字符串" class="headerlink" title="1.6字符串"></a>1.6字符串</h4><p><strong>①定义</strong></p><blockquote><p>以<strong>单引号</strong>、<strong>双引号</strong>、<strong>三个单引号</strong>或<strong>三个双引号</strong>开始和结束，是<strong>不可变类型</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 三重引号之间的所有引号、制表符或换行，都被认为是字符串的一部分</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 可以看作是单个文本字符的元组（空格也算）</div><blockquote><p><code>name = 'cat'</code>相当于<code>name = ('c','a','t')</code></p></blockquote><p><strong>②原始字符串</strong></p><blockquote><p>在字符串<strong>开始的引号之前</strong>加上<code>r</code>，<strong>完全忽略</strong>所有的<strong>转义字符</strong>，打印出字符串中<strong>所有</strong>的<strong>倒斜杠</strong></p></blockquote><p><strong>③print和input</strong></p><blockquote><p><strong>print()<strong>：将括号内的</strong>字符串</strong>显示在<strong>屏幕</strong>上，输出<strong>其他类型变量</strong>时，需要使用<code>str()</code>将其<strong>转换为字符串类型</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 采用占位符语法灵活配置字符串</div><blockquote><p><strong>input()<strong>：等待用户</strong>输入文本</strong>，并按下<strong>回车键</strong>，将其转化为一个<strong>字符串</strong></p></blockquote><p><strong>④占位符语法</strong></p><blockquote><p><code>print('%d + %d = %d' % (a, b, a + b))</code>：其中<code>%d</code>是<strong>整数</strong>的<strong>占位符</strong>，<strong>字符串后<code>%</code>后面</strong>跟的<strong>变量值</strong>会<strong>替换掉占位符</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 带该种占位符的字符串中要表示百分号必须写成%%</div><blockquote><p><code>print('{0} * {1} = {2}'.format(a, b, a * b))</code>：其中<code>{0}</code>、<code>{1}</code>和<code>{2}</code>都是<strong>占位符</strong>，其中<strong>数字</strong>为<strong>format方法</strong>的<strong>索引</strong>，<strong>占位符</strong>最后会被<strong>替换</strong>为<strong>对应的变量</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 还可以利用语法糖简化写法，即print(f'{a} * {b} = {a * b}')</div><h3 id="2-函数"><a href="#2-函数" class="headerlink" title="2.函数"></a>2.函数</h3><h4 id="2-1引言"><a href="#2-1引言" class="headerlink" title="2.1引言"></a>2.1引言</h4><p><strong>①格式</strong></p><blockquote><p><code>None</code>是<code>NoneType</code><strong>数据类型</strong>的<strong>唯一值</strong>，代表<strong>没有值</strong>，相当于<strong>C语言</strong>中的<code>void</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">def 函数名(形参n):  statement  return expression #可以是变量，也可以是表达式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 某些函数有可选的关键字参数，在函数调用时可以指定，相当于修改函数的默认设置</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果需要传递多个同一位置的关键字参数，可以采用 | 管道命令将这些参数连接</div><p><strong>②可变参数</strong></p><blockquote><p>使用<code>args</code><strong>关键字</strong>实现</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 函数的参数可以有默认值，也支持使用可变参数（类型、个数均可变），所以Python并不需要支持函数的重载</div><pre class="line-numbers language-none"><code class="language-none"># 在参数名前面的*表示args是一个可变参数def add(*args):    total = 0    for val in args:        total += val    return total# 在调用add函数时可以传入0个或多个参数print(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))print(add(1, 3, 5, 7, 9))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2作用域"><a href="#2-2作用域" class="headerlink" title="2.2作用域"></a>2.2作用域</h4><p><strong>①分类</strong></p><blockquote><p><strong>局部作用域</strong>：在<strong>被调用函数内赋值</strong>的变量，局部作用域在<strong>函数被调用</strong>时创建，在<strong>函数返回时</strong>销毁</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果在函数内没有对其进进行赋值，则为全局变量</div><blockquote><p><strong>全局作用域</strong>：在<strong>所有函数之外</strong>赋值的变量，属于<strong>全局作用域</strong>，全局作用域在<strong>程序开始时</strong>创建，在<strong>程序终止时</strong>销毁</p></blockquote><blockquote><p><strong>嵌套作用域</strong>：当一个<strong>函数内部</strong>有<strong>另一个函数</strong>时，<strong>前者</strong>的变量属于<strong>后者</strong>的<strong>嵌套作用域</strong></p></blockquote><blockquote><p><strong>内置作用域</strong>：<strong>Python内置</strong>的那些<strong>标识符</strong></p></blockquote><p><strong>②联系</strong></p><blockquote><p><strong>内置作用域</strong>→<strong>全局作用域</strong>→<strong>嵌套作用域</strong>→<strong>局部作用域</strong>，<strong>从左往右</strong>依次<strong>内推</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 内部的作用域可以访问外部作用域中的变量，但是外部作用域不能访问内部作用域的变量</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 局部作用域不能访问其他局部作用域的变量</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果在不同的作用域中，你可以用相同的名字命名不同的变量</div><p><strong>③关键词修饰</strong></p><blockquote><p><code>global</code>：<strong>修饰变量</strong>使其变为<strong>全局变量</strong></p></blockquote><blockquote><p><code>nonlocal</code>：<strong>修饰变量</strong>使其变为<strong>嵌套作用域变量</strong></p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被垃圾回收</div><h4 id="2-3模块"><a href="#2-3模块" class="headerlink" title="2.3模块"></a>2.3模块</h4><p><strong>①定义</strong></p><blockquote><p>模块类似于C++中的<strong>命名空间</strong>，可以<strong>防止命名冲突</strong>，同时也<strong>封装了代码</strong></p></blockquote><p><strong>②使用</strong></p><blockquote><p><strong>导入模块</strong>：<code>import 模块名,模块名n</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> import 模块 as 新名字可以对模块进行重命名</div><blockquote><p><strong>调用模块中函数/方法</strong>：<code>模块名.函数名/方法名</code></p></blockquote><p><strong>③测试</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 模块内部有一个测试函数，直接运行该模块文件即可运行测试函数</div><blockquote><p><code>__name__</code>为python中的一个<strong>内置变量</strong>，当程序<strong>直接被执行</strong>时，其<code>__name__</code>的值为<code>'__main__'</code>，而<strong>作为模块导入</strong>时，其<code>__name__ </code>值为<strong>自己的模块名</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">def c2f(cel):    fah = cel * 1.8 + 32    return fahdef f2c(fah):    cel = (fah - 32) / 1.8    return celdef test():    print("测试数据：0 摄氏度 = %.2f 华氏度" % c2f(0))    print("测试数据：0 华氏度 = %.2f 摄氏度" % f2c(0))if __name__ == '__main__':test()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4异常处理"><a href="#2-4异常处理" class="headerlink" title="2.4异常处理"></a>2.4异常处理</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 本质上是试图捕捉函数内部某些语句的错误</div><blockquote><p><strong>try语句</strong>：将可<strong>能出错的语句</strong>放在<code>try</code>之后，当这些语句<strong>出错</strong>后，会立马<strong>跳转到</strong><code>except</code>语句</p></blockquote><pre class="line-numbers language-none"><code class="language-none">try:  statement<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><strong>except语句</strong>：后面常接一些<strong>错误提醒</strong>的<code>print</code>语句</p></blockquote><pre class="line-numbers language-none"><code class="language-none">except 错误名:  print()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p><strong>finally语句</strong>：<code>finally</code>块的代码<strong>不论程序正常还是异常</strong>都会执行</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 该语句不是必须的，通常用于执行一些必要的清理操作，如关闭文件、释放资源、关闭数据库连接等</div><h3 id="3-容器"><a href="#3-容器" class="headerlink" title="3.容器"></a>3.容器</h3><h4 id="3-1列表"><a href="#3-1列表" class="headerlink" title="3.1列表"></a>3.1列表</h4><p><strong>①定义</strong></p><blockquote><p><code>列表名 = [表项1,...,表项n]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 表项的数据类型可以不是一致的，也可以是列表，元素一致时，类似于C语言的数组</div><p><strong>②访问</strong></p><blockquote><p><code>列表名[i]</code>：访问列表中<strong>第<code>i-1</code>个表项</strong>，当<code>i</code>前面有<strong>负号</strong>时，代表<strong>倒数</strong>第<code>i</code>个</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不同于C语言，python中有对应的下标检查</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当列表某个表项是列表时，如果想要访问其中元素，需要再次使用下标，即列表名[i][j]</div><blockquote><p><code>列表名[i:j:n]</code>：访问列表的<strong>一部分</strong>，<strong>结果</strong>还是<strong>一个列表</strong>，也称为<strong>切片</strong>，其中<code>[i:j:n]</code>表示<strong>第i个下标</strong>到<strong>第j个下标</strong>,<strong>步长为n</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 缺省i表示列表开始处，缺省j表示列表结束处，缺省n步长为1</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 当n为负数时，表示从第j个下标到第i个下标，即反向切片</div><p><strong>③常用操作</strong></p><blockquote><p><code>+</code>：<strong>连接</strong>两个列表，<code>spam1+spam2</code></p></blockquote><blockquote><p><code>*</code>：<strong>复制</strong>列表，<code>spam*5</code></p></blockquote><blockquote><p><code>del</code>：<strong>删除</strong>列表项，如<code>del spam[2]</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 表中被删除值后面的所有值，都将向前移动一个下标</div><blockquote><p><code>in</code>：<strong>判断</strong>元素<strong>是否在列表中</strong>，<code>if(var in spam)</code></p></blockquote><blockquote><p><strong>常用方法</strong>：<strong>查找</strong><code>index()</code>、<strong>添加</strong><code>append()</code>、<strong>插入</strong><code>insert()</code>、<strong>删除</strong><code>remove()</code>、<strong>排序</strong><code>sort()</code></p></blockquote><h4 id="3-2元组和集合"><a href="#3-2元组和集合" class="headerlink" title="3.2元组和集合"></a>3.2元组和集合</h4><p><strong>①元组</strong></p><blockquote><p><strong>列表</strong>的<strong>不可变数据类型</strong>版本，<strong>创建时</strong>时用<strong>圆括号()</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 元组在创建时间和占用的空间上面都优于列表</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 若元组中只有一个值，在该值的后面跟上一个逗号，否则就是一个值，而不是包含一个值的元组</div><p><strong>②集合</strong></p><blockquote><p><code>set1 = {1, 2, 3, 3, 3, 2}</code>，是<strong>无序</strong>的可变数据类型</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不允许有重复元素，而且可以进行交集、并集、差集等运算</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 列表、元组和集合之间可以通过list()、tuple()和set()相互转化</div><h4 id="3-3字典"><a href="#3-3字典" class="headerlink" title="3.3字典"></a>3.3字典</h4><p><strong>①定义</strong></p><blockquote><p><code>字典名 = {键1:值1,...,键n:值n};</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 通过键查询对应值，且键可以是任意数据类型，但是不能重复</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 字典是无序的，只要键值对完全相同，两个字典就是完全相同的</div><p><strong>②基本操作</strong></p><blockquote><p><code>字典名[键名]</code>：访问<strong>键对应的值</strong></p></blockquote><blockquote><p><code>字典名[键名]=值</code>：<strong>添加/修改</strong>键值对</p></blockquote><blockquote><p><code>del 字典名[键名]</code>：<strong>删除</strong>键值对</p></blockquote><blockquote><p><code>键名 in 字典名</code>：判断键<strong>是否存在</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 字典中的get方法可以同时获得值并检测键是否存在</div><p><strong>③常用方法</strong></p><blockquote><p><code>keys()</code>:返回<code>dict_keys</code>，类似<strong>键的列表</strong></p></blockquote><blockquote><p><code>values()</code>：返回<code>dict_values</code>，类似<strong>值的列表</strong></p></blockquote><blockquote><p><code>items()</code>：返回<code>dict_items</code>，类似<strong>键-值对的列表</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 为字典的方法</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 这些返回值不能改变，常用于for循环判定条件中如for v in spam.values()用于遍历字典</div><blockquote><p><code>get()</code>：它有<strong>两个参数</strong>，<strong>第一个</strong>参数为<strong>键</strong>，以及如果<strong>该键不存在</strong>时，返回的<strong>第二个参数</strong></p></blockquote><blockquote><p><code>setdefault()</code>:为字典中<strong>某个键设置一个默认值</strong></p></blockquote><pre class="line-numbers language-none"><code class="language-none">#计算一个字符串中每个字符出现的次数message = 'It was a bright cold day in April, and the clocks were striking thirteen.'count = {}#for循环语句，即将character依次设置为message列表中的值for character in message:  count.setdefault(character, 0)  count[character] = count[character] + 1print(count)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo个人博客搭建</title>
      <link href="/2023/12/10/hexo-bo-ke-kuang-jia-da-jian-yi-ji-ge-xing-hua/"/>
      <url>/2023/12/10/hexo-bo-ke-kuang-jia-da-jian-yi-ji-ge-xing-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="Hexo个人博客搭建"><a href="#Hexo个人博客搭建" class="headerlink" title="Hexo个人博客搭建"></a>Hexo个人博客搭建</h2><h3 id="1-博客部署"><a href="#1-博客部署" class="headerlink" title="1.博客部署"></a>1.博客部署</h3><h4 id="1-1环境配置"><a href="#1-1环境配置" class="headerlink" title="1.1环境配置"></a>1.1环境配置</h4><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 安装hexo的依赖</div><p><strong>①windows环境</strong></p><blockquote><p>安装<code>Node.js</code>和<code>Git</code>，并通过<code>xx -v</code>检测其是否在<strong>环境变量</strong>中</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 如果不在，则需要手动将其bin文件夹路径添加到系统变量中的path变量中</div><blockquote><p>设置<code>npm</code>的<strong>镜像源</strong></p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看npm的配置</span><span class="token function">npm</span> config list<span class="token comment"># 默认源</span><span class="token function">npm</span> config <span class="token builtin class-name">set</span> registry https://registry.npmjs.org<span class="token comment"># 临时改变镜像源</span><span class="token function">npm</span> <span class="token parameter variable">--registry</span><span class="token operator">=</span>https://registry.npm.taobao.org<span class="token comment"># 永久设置为淘宝镜像源</span><span class="token function">npm</span> config <span class="token builtin class-name">set</span> registry https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②Linux环境</strong></p><blockquote><p>安装<code>Node.js</code>和<code>Git</code>，若使用<strong>源码安装</strong>，则需要添加<strong>软链接</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 类似于windows的环境变量，Linux在指定位置找对应的命令</div><blockquote><p>设置<code>npm</code>的<strong>镜像源</strong>，<strong>同上</strong></p></blockquote><h4 id="1-2Hexo配置"><a href="#1-2Hexo配置" class="headerlink" title="1.2Hexo配置"></a>1.2Hexo配置</h4><p><strong>①Hexo安装</strong></p><blockquote><p>在<code>git bash/shell</code>中输入<code>npm install -g hexo-cli</code></p></blockquote><p><strong>②博客初始化</strong></p><blockquote><p>选择一个<strong>位置</strong>用于存放<strong>博客文件夹</strong></p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#新建文件夹</span><span class="token function">mkdir</span> <span class="token operator">&lt;</span>新建文件夹的名称<span class="token operator">&gt;</span> <span class="token comment">#初始化文件夹</span>hexo init <span class="token operator">&lt;</span>新建文件夹的名称<span class="token operator">&gt;</span><span class="token comment">#在该文件夹中安装博客所需要的依赖文件</span><span class="token builtin class-name">cd</span> <span class="token operator">&lt;</span>新建文件夹的名称<span class="token operator">&gt;</span><span class="token function">npm</span> <span class="token function">install</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-3GitHub设置"><a href="#1-3GitHub设置" class="headerlink" title="1.3GitHub设置"></a>1.3GitHub设置</h4><p><strong>①创建仓库</strong></p><blockquote><p><strong>名字</strong>必须是<code>&lt;用户名&gt;.github.io</code></p></blockquote><p><strong>②配置Git用户名和邮箱</strong></p><blockquote><p>如果<strong>之前配置过</strong>则<strong>不用配置</strong>，否则需要配置</p></blockquote><h4 id="1-4本地文件夹与GitHub建立连接"><a href="#1-4本地文件夹与GitHub建立连接" class="headerlink" title="1.4本地文件夹与GitHub建立连接"></a>1.4本地文件夹与GitHub建立连接</h4><p><strong>①插件安装</strong></p><blockquote><p>在<strong>博客目录</strong>下的<code>git bash/shell</code>中输入命令<code>npm install hexo-deployer-git --save</code></p></blockquote><p><strong>②SSH密钥设置</strong></p><blockquote><p>并在<code>git bash/shell</code>中输入<code>ssh -T git@github.com</code>测试是否连接成功</p></blockquote><p><strong>③修改Hexo配置文件</strong></p><blockquote><p>打开<code>_config.yml</code>，滑到<strong>文件最底部</strong>，填入<strong>如下代码</strong></p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">type</span><span class="token punctuation">:</span> git<span class="token key atrule">repo</span><span class="token punctuation">:</span> git@github.com<span class="token punctuation">:</span>Github用户名/github用户名.github.io.git  //也可使用https地址，如：https<span class="token punctuation">:</span>//github.com/Github用户名/Github用户名.github.io.git            <span class="token key atrule">branch</span><span class="token punctuation">:</span> master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>④上传博客</strong></p><blockquote><p>在<strong>博客目录</strong>下的<code>git bash/shell</code>中输入<strong>命令</strong><code>hexo d</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 上传成功后，在浏览器中打开https://&lt;用户名&gt;.github.io，即可查看上传的网页</div><hr><h3 id="2-博客个性化"><a href="#2-博客个性化" class="headerlink" title="2.博客个性化"></a>2.博客个性化</h3><h4 id="2-1主题设置"><a href="#2-1主题设置" class="headerlink" title="2.1主题设置"></a>2.1主题设置</h4><p><strong>①主题安装</strong></p><blockquote><p>在<strong>博客目录</strong>下的<code>git bash/shell</code>中输入如下<strong>命令</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 这里选择的是matery主题，有两个版本，稳定版本和最新版本 (不定期更新优化)，自主选择版本</div><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/blinkfox/hexo-theme-matery themes/matery     <span class="token comment"># 稳定版</span><span class="token function">git</span> clone <span class="token parameter variable">-b</span> develop https://github.com/blinkfox/hexo-theme-matery themes/matery   <span class="token comment">#最新版(不定期进行优化更新)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>②修改博客主题</strong></p><blockquote><p>将<strong>博客配置文件</strong><code>_config</code>中的<code>theme</code>值修改为<strong>下载主题</strong>的<strong>文件夹名</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 其他博客配置文件修改可见官网</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 修改博客配置文件后要运行执行hexo clean &amp;&amp; hexo g，重新生成博客文件</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 注意博客配置文件在博客根目录下，对应主题也有相应配置文件在主题文件夹中</div><h4 id="2-2插件配置"><a href="#2-2插件配置" class="headerlink" title="2.2插件配置"></a>2.2插件配置</h4><p><strong>①搜索</strong></p><blockquote><p><strong>下载</strong>：<code>npm install hexo-generator-search --save</code></p></blockquote><blockquote><p><strong>配置</strong>：在<strong>博客配置文件</strong>中，新增以下的<strong>配置项</strong></p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">search</span><span class="token punctuation">:</span>  <span class="token key atrule">path</span><span class="token punctuation">:</span> search.xml  <span class="token key atrule">field</span><span class="token punctuation">:</span> post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>②中文链接转拼音</strong></p><blockquote><p><strong>下载</strong>：<code>npm i hexo-permalink-pinyin --save</code></p></blockquote><blockquote><p><strong>配置</strong>：在<strong>博客配置文件</strong>中，新增以下的<strong>配置项</strong></p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment"># default: '-'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>③文章字数统计插件</strong></p><blockquote><p><strong>下载</strong>：<code>npm i --save hexo-wordcount</code></p></blockquote><blockquote><p><strong>配置</strong>：在<strong>博客配置文件</strong>中，新增以下的<strong>配置项</strong></p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">wordCount</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 将这个值设置为 true 即可.</span>  <span class="token key atrule">postWordCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3自定义标签设置"><a href="#2-3自定义标签设置" class="headerlink" title="2.3自定义标签设置"></a>2.3自定义标签设置</h4><p><strong>①步骤</strong></p><blockquote><p>在<strong>主题目录下</strong>新建<code>scripts</code>目录，并<strong>此目录下</strong>新建<code>block.js</code>文件，填入<strong>以下代码</strong></p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">hexo<span class="token punctuation">.</span>extend<span class="token punctuation">.</span>tag<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'wrong'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">args<span class="token punctuation">,</span> content</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> className <span class="token operator">=</span>  args<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> formattedContent <span class="token operator">=</span> content<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\n</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">'&lt;br&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将换行符替换为 &lt;br&gt; 标签</span>    <span class="token keyword">return</span> <span class="token string">'&lt;div class="uk-alert uk-alert-danger"&gt;&lt;i class="fas fa-exclamation-triangle"&gt;&lt;/i&gt; '</span> <span class="token operator">+</span> formattedContent <span class="token operator">+</span> <span class="token string">'&lt;/div&gt;'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">ends</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    hexo<span class="token punctuation">.</span>extend<span class="token punctuation">.</span>tag<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'right'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">args<span class="token punctuation">,</span> content</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> className <span class="token operator">=</span>  args<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> formattedContent <span class="token operator">=</span> content<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\n</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">'&lt;br&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将换行符替换为 &lt;br&gt; 标签</span>    <span class="token keyword">return</span> <span class="token string">'&lt;div class="uk-alert uk-alert-success"&gt;&lt;i class="fa fa-check-circle"&gt;&lt;/i&gt; '</span> <span class="token operator">+</span> formattedContent <span class="token operator">+</span> <span class="token string">'&lt;/div&gt;'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">ends</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    hexo<span class="token punctuation">.</span>extend<span class="token punctuation">.</span>tag<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'warning'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">args<span class="token punctuation">,</span> content</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> className <span class="token operator">=</span>  args<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> formattedContent <span class="token operator">=</span> content<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\n</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">'&lt;br&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将换行符替换为 &lt;br&gt; 标签</span>    <span class="token keyword">return</span> <span class="token string">'&lt;div class="uk-alert uk-alert-warning"&gt;&lt;i class="fa fa-exclamation-circle"&gt;&lt;/i&gt; '</span> <span class="token operator">+</span> formattedContent <span class="token operator">+</span> <span class="token string">'&lt;/div&gt;'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">ends</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  hexo<span class="token punctuation">.</span>extend<span class="token punctuation">.</span>tag<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'list'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">args<span class="token punctuation">,</span> content</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> className <span class="token operator">=</span>  args<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> formattedContent <span class="token operator">=</span> content<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\n</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">'&lt;br&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将换行符替换为 &lt;br&gt; 标签</span>    <span class="token keyword">return</span> <span class="token string">'&lt;div class="uk-alert uk-alert-list"&gt;&lt;i class="fas fa-list-ul"&gt;&lt;/i&gt; '</span> <span class="token operator">+</span><span class="token string">'&lt;br&gt;'</span><span class="token operator">+</span>formattedContent <span class="token operator">+</span> <span class="token string">'&lt;/div&gt;'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">ends</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在<code>head.ejs</code>文件<strong>添加</strong>以下<code>css</code>样式：</p></blockquote><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">        <span class="token selector">.uk-alert</span> <span class="token punctuation">{</span>            <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>            <span class="token property">padding</span><span class="token punctuation">:</span> 5px<span class="token punctuation">;</span>            <span class="token property">background</span><span class="token punctuation">:</span> #ebf7fd<span class="token punctuation">;</span>            <span class="token property">color</span><span class="token punctuation">:</span> #2d7091<span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> 0px solid #ffffff<span class="token punctuation">;</span>            <span class="token property">border-radius</span><span class="token punctuation">:</span> 4px<span class="token punctuation">;</span>            <span class="token property">text-shadow</span><span class="token punctuation">:</span> 0 1px 0 #ffffff<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector">.uk-alert-success</span> <span class="token punctuation">{</span>            <span class="token property">background</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>120<span class="token punctuation">,</span> 199<span class="token punctuation">,</span> 9<span class="token punctuation">,</span> 0.1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">color</span><span class="token punctuation">:</span> <span class="token function">rgba</span><span class="token punctuation">(</span>120<span class="token punctuation">,</span> 199<span class="token punctuation">,</span> 9<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">border-left</span><span class="token punctuation">:</span> 6px solid <span class="token function">rgba</span><span class="token punctuation">(</span>120<span class="token punctuation">,</span> 199<span class="token punctuation">,</span> 9<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token property">font-weight</span><span class="token punctuation">:</span> 600<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector">.uk-alert-warning</span> <span class="token punctuation">{</span>            <span class="token property">background</span><span class="token punctuation">:</span> #FFF8E9<span class="token punctuation">;</span>            <span class="token property">color</span><span class="token punctuation">:</span> #FFB91F<span class="token punctuation">;</span>            <span class="token property">border-left</span><span class="token punctuation">:</span> 6px solid #FFB91F<span class="token punctuation">;</span>            <span class="token property">font-weight</span><span class="token punctuation">:</span> 600<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector">.uk-alert-danger</span> <span class="token punctuation">{</span>            <span class="token property">background</span><span class="token punctuation">:</span> #FFE6E6<span class="token punctuation">;</span>            <span class="token property">color</span><span class="token punctuation">:</span> #FF7979<span class="token punctuation">;</span>            <span class="token property">border-left</span><span class="token punctuation">:</span> 6px solid#FF7979<span class="token punctuation">;</span>            <span class="token property">font-weight</span><span class="token punctuation">:</span> 600<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token selector">.uk-alert-list</span> <span class="token punctuation">{</span>            <span class="token property">background</span><span class="token punctuation">:</span> #ECF7FE<span class="token punctuation">;</span>            <span class="token property">color</span><span class="token punctuation">:</span> #3CACF4<span class="token punctuation">;</span>            <span class="token property">border-left</span><span class="token punctuation">:</span> 6px solid#3CACF4<span class="token punctuation">;</span>            <span class="token property">font-weight</span><span class="token punctuation">:</span> 600<span class="token punctuation">;</span>        <span class="token punctuation">}</span> </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>②解析</strong></p><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 以warning部分作为例子</div><blockquote><p><strong><code>block.js</code>文件</strong>：其中<code>warning</code>决定了<strong>正文中的书写格式</strong>；<code>div class</code>决定了<strong>容器（背景）的名字</strong>；<code>i class</code>决定了<strong>图标的样式</strong></p></blockquote><blockquote><p><strong><code>head.ejs</code>文件</strong>：主要决定<strong>网页表现</strong>出的<strong>具体样式</strong></p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 详细可询问ChatGPT</div><p><strong>③示例</strong></p><pre class="line-numbers language-none"><code class="language-none">{%wrong%}错误{%endwrong%}{%right%}正确{%endright%}{%warning%}警告{%endwarning%}{%list%}列表项{%endlist%}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 错误</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 正确</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 警告</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 列表项</div><h4 id="2-4其他配置"><a href="#2-4其他配置" class="headerlink" title="2.4其他配置"></a>2.4其他配置</h4><p><strong>①自定义鼠标样式</strong></p><blockquote><p><strong>概述</strong>：<a href="https://zhutix.com/">致美化</a>下载<strong>鼠标样式</strong>，放在<code>source/medias</code>目录，随后在<code>themes\matery\source\css</code>下<code>my.css</code>文件添加</p></blockquote><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">*</span><span class="token punctuation">{</span>    <span class="token property">cursor</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">"/medias/mouse/Arrow.ico"</span><span class="token punctuation">)</span></span><span class="token punctuation">,</span>auto<span class="token important">!important</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">:active</span><span class="token punctuation">{</span>    <span class="token property">cursor</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span><span class="token string url">"/medias/imgs/Hand.ico"</span><span class="token punctuation">)</span></span><span class="token punctuation">,</span>auto<span class="token important">!important</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-博客书写"><a href="#3-博客书写" class="headerlink" title="3.博客书写"></a>3.博客书写</h3><h4 id="3-1Front-matter"><a href="#3-1Front-matter" class="headerlink" title="3.1Front-matter"></a>3.1Front-matter</h4><blockquote><p>在<strong>博客根目录</strong>下<code>scaffolds</code>文件夹下新增/修改<code>post.md</code>文件，即可修改<strong>默认样式</strong>，<strong>详细样式</strong>如下</p></blockquote><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">title</span><span class="token punctuation">:</span> 文章名称<span class="token key atrule">seo_title</span><span class="token punctuation">:</span> seo名称<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>            <span class="token comment"># 是否生成目录</span><span class="token key atrule">indent</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>         <span class="token comment"># 是否首行缩进</span><span class="token key atrule">comments</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>       <span class="token comment"># 是否允许评论</span><span class="token key atrule">archive</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>        <span class="token comment"># 是否显示在归档</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>         <span class="token comment"># 是否显示封面</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>       <span class="token comment"># 是否渲染公式</span><span class="token key atrule">pin</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>           <span class="token comment"># 是否首页置顶</span><span class="token key atrule">top_meta</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>      <span class="token comment"># 是否显示顶部信息</span><span class="token key atrule">bottom_meta</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>   <span class="token comment"># 是否显示尾部信息</span><span class="token key atrule">sidebar</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>toc<span class="token punctuation">]</span><span class="token key atrule">tag</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> 标签一  <span class="token punctuation">-</span> 标签二<span class="token key atrule">categories</span><span class="token punctuation">:</span> 分组<span class="token key atrule">keywords</span><span class="token punctuation">:</span> 文章关键词<span class="token key atrule">date</span><span class="token punctuation">:</span> 2021<span class="token punctuation">-</span>13<span class="token punctuation">-</span>13 00<span class="token punctuation">:</span><span class="token number">00</span><span class="token key atrule">updated</span><span class="token punctuation">:</span> 2021<span class="token punctuation">-</span>13<span class="token punctuation">-</span>13 00<span class="token punctuation">:</span><span class="token number">00</span><span class="token key atrule">description</span><span class="token punctuation">:</span> 文章摘要<span class="token key atrule">icons</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>fas fa<span class="token punctuation">-</span>fire red<span class="token punctuation">,</span> fas fa<span class="token punctuation">-</span>star green<span class="token punctuation">]</span><span class="token key atrule">references</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">title</span><span class="token punctuation">:</span> 参考资料名称    <span class="token key atrule">url</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//参考资料地址<span class="token key atrule">headimg</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//文章头图<span class="token key atrule">thumbnail</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//右侧缩略图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2正文修饰"><a href="#3-2正文修饰" class="headerlink" title="3.2正文修饰"></a>3.2正文修饰</h4><p><strong>①标题</strong></p><blockquote><p><code>#</code>为<strong>一级标题</strong>，<code>##</code>为<strong>二级标题</strong>,以此类推</p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 最多六级，且#和文字之间要有空格</div><p><strong>②加粗与倾斜</strong></p><pre class="line-numbers language-none"><code class="language-none">*[文本]* #倾斜**[文本]** #加粗***[文本]*** #加粗倾斜<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>③引用</strong></p><blockquote><p><code>&gt;</code>后添加<strong>空格</strong>和<strong>引用内容</strong></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 不同的引用以及正文使用换行隔开</div><pre class="line-numbers language-none"><code class="language-none">&gt; 树1&gt; 树2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>树1</p></blockquote><blockquote><p>树2</p></blockquote><p><strong>④超链接</strong></p><blockquote><p><strong>格式</strong>：<code>[Link Text](link-address)</code></p></blockquote><p><a href="http://106.15.109.213/2020/07/25/markdown%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/#6-%E5%BC%95%E7%94%A8%E6%AE%B5%E8%90%BD">参考文章</a></p><p><strong>⑤插入图片</strong></p><pre class="line-numbers language-none"><code class="language-none">#单张图片！[Figure](URL www.xxx.com)#figure此处的文字有时作为图片标题显示，有时不显示，optional，可留空#URL处也可以不填写url，也可以选择上传本地图片，此时只需填写相对路径即可，#相对路径指的是在与此markdown文档同路径下的相对路径，可在此md文档同路径下新建img文件夹，#在此处填/img/xx.png 具体情况具体分析，或许在主题配置文件中亦有提及*#多张图片{% gi total n1-n2-... %}  ![](url)  ![](url)  ![](url)  ![](url)  ![](url){% endgi %}#total为图片总的数量,n1为第一行的图片数量,n2为第二行的图片数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>⑥锚点</strong></p><blockquote><p><strong>格式</strong>：<code>[显示内容](#标题)</code></p></blockquote><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 锚点与链接基本相同，区别在于锚点是在文章内部相互传送，但只能传送到n级标题的位置</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 注意此处#代表的是‘标题’这一性质，而非标题的级别，因此不必加n个#来体现标题等级</div><p><strong>⑦代码块</strong></p><blockquote><p><strong>概述</strong>：以<strong>三个反引号</strong>包围，并在<strong>开头的三个反引号</strong>后添加<strong>语言类型</strong>，如<code>cpp</code>、<code>c</code>和<code>python</code>等</p></blockquote><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果不添加语言类型，无法实现代码高亮</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果想要修改代码高亮样式，可以取prism官网下载css文件替换/修改主题文件夹中的source/libs/prism/prism.css</div><div class="uk-alert uk-alert-list"><i class="fas fa-list-ul"></i> 需要修改hexo根目录下的配置文件，相关部分设置如下，这里采用的是prismjs，需要关闭highlight选项</div><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">auto_detect</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span>  <span class="token key atrule">wrap</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">hljs</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">prismjs</span><span class="token punctuation">:</span>  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>   <span class="token key atrule">preprocess</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-网络优化"><a href="#4-网络优化" class="headerlink" title="4.网络优化"></a>4.网络优化</h3><h4 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h4><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 工作流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 静态博客框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习笔记（三）</title>
      <link href="/2023/12/10/python-xue-xi-bi-ji-san/"/>
      <url>/2023/12/10/python-xue-xi-bi-ji-san/</url>
      
        <content type="html"><![CDATA[<h1 id="python学习笔记（三）"><a href="#python学习笔记（三）" class="headerlink" title="python学习笔记（三）"></a>python学习笔记（三）</h1><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="1-文件路径"><a href="#1-文件路径" class="headerlink" title="1.文件路径"></a>1.文件路径</h3><p><strong>1.1定义：</strong>指明了文件在计算机上的<strong>位置</strong>，可分为<strong>绝对路径</strong>和<strong>相对路径</strong><br>①绝对路径：从<strong>根文件夹</strong>开始的完整路径<br>②相对路径：相对于程序的<strong>当前工作目录</strong>的路径</p><blockquote><p>windows上采用<code>\</code>作为文件夹之间的分隔符，Linux上和OS X上采用<code>/</code>作为文件夹之间的分隔符</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 为了程序的可移植性，采用python中os模块中的方法获取文件路径</div><p><strong>1.2获取</strong><br>①通过<code>os</code>模块获取</p><blockquote><p><code>os.path.join()</code>：将单个文件和路径上的文件夹名称的字符串传递给它，<code>os.path.join()</code>就会返回一个文件路径的字符串<br><code>os.getcwd()</code>：可以取得<strong>当前工作路径</strong>的<strong>字符串</strong>，并可以利用<code>os.chdir()</code>改变它<br><code>os.path.abspath(path)</code>：将返回参数（相对路径的<strong>字符串</strong>）的绝对路径的<strong>字符串</strong><br><code>os.path.dirname()</code>：获取文件绝对路径的目录部分</p></blockquote><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 如果要获得路径的每一个文件夹的名称，可以使用'[路径]'.split(os.path.sep)</div><p>②使用<code>sys</code>模块</p><blockquote><p><code>sys.argv[0]</code>：获取当前脚本的路径（包括文件名）。<br><code>sys.path[0]</code>：获取当前脚本所在的目录路径。</p></blockquote><p>③使用<code>__file__</code>变量：包含了<strong>当前模块</strong>（脚本）的路径（包括文件名）</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 该变量只在一个独立的模块（脚本）中才有定义</div><pre class="line-numbers language-none"><code class="language-none">import osimport sys# 获取当前工作目录current_directory = os.getcwd()print("当前工作目录:", current_directory)# 获取文件的绝对路径absolute_path = os.path.abspath('file.txt')print("文件的绝对路径:", absolute_path)# 拼接目录和文件名，返回完整路径full_path = os.path.join('dir', 'file.txt')print("完整路径:", full_path)# 获取当前脚本的路径script_path = sys.argv[0]print("当前脚本的路径:", script_path)# 获取当前脚本所在的目录路径script_directory = os.path.dirname(os.path.abspath(__file__))print("当前脚本所在的目录路径:", script_directory)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.3有效性检查</strong></p><blockquote><p><code>os.path.exists(path)</code>：如果path参数所指的文件或文件夹存在，返回True<br><code>os.path.isfile(path)</code>：如果path参数存在，并且是一个文件，返回 True<br><code>os.path.isdir(path)</code>：如果path参数存在，并且是一个文件夹，返回Ture</p></blockquote><h3 id="2-文件处理"><a href="#2-文件处理" class="headerlink" title="2.文件处理"></a>2.文件处理</h3><p><strong>2.1打开文件</strong><br>①<code>open()</code>： 向它传递一个<strong>字符串</strong>路径，返回一个<code>File</code>对象，还可传入对应参数指定<strong>操作模式</strong>和<strong>编码方式</strong>，默认是<strong>读模式</strong>和<strong>操作系统默认的编码</strong><br>②操作模式：不同的操作模式有不同的规则</p><blockquote><p><code>'r'</code>：以只读模式打开文件（默认模式），文件指针位于文件的开头，如果文件不存在，则会引发FileNotFoundError。<br><code>'w'</code>：以写入模式打开文件，如果文件已存在，则会被清空。如果文件不存在，则会创建一个新文件。<br><code>'a'</code>：以追加模式打开文件，文件指针位于文件的末尾。如果文件不存在，则会创建一个新文件。<br><code>'x'</code>：以独占写入模式打开文件，如果文件已存在，则会引发FileExistsError。<br><code>'b'</code>：以二进制模式打开文件，可以与其他模式一起使用，例如’rb’或’wb’。<br><code>'t'</code>：以文本模式打开文件（默认模式），可以与其他模式一起使用，例如’rt’或’wt’。<br><code>'+'</code>：以读写模式打开文件，可以与其他模式一起使用，例如’r+’、’w+’或’a+’。</p></blockquote><p>③编码方式：通过<code>encoding</code>参数指定编码，常见的编码方式有<code>ASCII</code>、<code>UTF-8</code>等，选择编码方式时，应根据需求考虑文件中包含的<strong>字符范围、语言以及平台兼容性</strong>等因素</p><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 如果文件使用的编码方式与指定的编码方式不匹配，可能会导致读取或写入的数据出现错误</div><p>④如果<code>open</code>函数指定的文件并<strong>不存在或者无法打开</strong>，那么将引发异常状况导致程序崩溃，需要对其进行检查，此外，执行完业务逻辑后，需要<strong>及时对目标文件进行释放</strong>，可以使用python中的异常机制</p><blockquote><p>文件找不到会引发<code>FileNotFoundError</code>，指定了未知的编码会引发<code>LookupError</code>，而如果读取文件时无法按指定方式解码会引发<code>UnicodeDecodeError</code></p></blockquote><pre class="line-numbers language-none"><code class="language-none">def main():    f = None    try:        f = open('致橡树.txt', 'r', encoding='utf-8')        print(f.read())    except FileNotFoundError:        print('无法打开指定的文件!')    except LookupError:        print('指定了未知的编码!')    except UnicodeDecodeError:        print('读取文件时解码错误!')    finally:        if f:            f.close()if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.2文件读写</strong><br>①文件读取</p><blockquote><p><code>read()</code>：将整个文件的内容读取为一个<strong>字符串值</strong><br><code>for-in</code>循环：还可以使用<code>for-in</code>循环逐行读取文件<br><code>readlines</code>：将文件按行读取到一个列表容器中</p></blockquote><pre class="line-numbers language-none"><code class="language-none">import timedef main():    # 一次性读取整个文件内容    with open('致橡树.txt', 'r', encoding='utf-8') as f:        print(f.read())    # 通过for-in循环逐行读取    with open('致橡树.txt', mode='r') as f:        for line in f:            print(line, end='')            time.sleep(0.5)    print()    # 读取文件按行读取到列表中    with open('致橡树.txt') as f:        lines = f.readlines()    print(lines)    if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>②文件写入：采用<code>write()</code>方法，该方法接收<strong>字符串</strong>，并将其写入到文件对象中</p><pre class="line-numbers language-none"><code class="language-none">file = open("example.txt", "w")file.write("Hello, World!")file.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2.3文件信息查询</strong><br>①<code>os.path.getsize(path)</code>将返回path参数中文件的<strong>字节数</strong><br>②<code>os.listdir(path)</code>将返回<strong>文件名字符串的列表</strong>，包含path参数中的每个文件<br><strong>2.4文件管理器</strong><br>①定义</p><blockquote><p>上下文：任务本身会对其环境进行保存，做到哪里了，做了多少，各种状态都会标识记录，从而形成了上下文环境，在切换时根据每个任务的上下文环境，继续执行，从而达到多任务</p></blockquote><blockquote><p>上下文管理器对象：即任何实现了<code>__enter__()</code>和 <code>__exit__()</code> 方法的类的对象实例</p></blockquote><p>②使用：<code>with 上下文表达式 as 对象</code></p><blockquote><p>其中<strong>上下文表达式</strong>是一个返回上下文管理器对象的函数调用<br>在进入语句块之前，上下文管理器的<code>__enter__</code>方法会被调用，可以在这个方法中执行资源的获取操作<br>在离开语句块时，无论是正常的退出还是发生异常，上下文管理器的<code>__exit__</code>方法都会被调用，可以在这个方法中执行资源的释放操作</p></blockquote><pre class="line-numbers language-none"><code class="language-none">with open('example.txt', 'r') as file:    data = file.read()    print(data)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>③with关键字的实现原理</p><pre class="line-numbers language-none"><code class="language-none">class File(object):    def __init__(self, filename, mode):        self.filename = filename        self.mode = mode        self.file = None    def __enter__(self):        """        进入with as 语句的时候被with调用        返回值作为 as 后面的变量        """        print("__enter__ called")        self.file = open(self.filename, self.mode)        return self.file    def __exit__(self, exc_type, exc_value, exc_traceback):        """        离开with语句的时候被with调用        """        print("__exit__ called")        print("exc_type: ", exc_type)        print("exc_value: ", exc_value)        print("exc_traceback: ", exc_traceback)        self.file.close()        print("文件关闭操作")def main():    with File("test.txt", "w") as f:        print("with 代码块")        f.write("hello python1")        f.write("hello python2")        # a = 1 / 0        f.write("hello python3")    print("with 语句结束")if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>进入上下文管理器会自动调用<code>__enter__(self)</code>，该方法的返回值会被赋值给<code>as</code>子句后的对象，该方法可以返回多个值，因此在<code>as</code>子句后面也可以指定多个变量（括起来组成元组）<br>退出上下文管理器自动调用<code>__exit__(self, exc_type, exc_value, exc_traceback)</code>，前三个参数在调用<code>__exit__()</code>方法时由Python解释器自动传递，并提供与异常相关的信息</p></blockquote><p>④<code>with</code>关键字和<code>try-except</code>联合调用</p><pre class="line-numbers language-none"><code class="language-none">def main():    try:        with open('guido.jpg', 'rb') as fs1:            data = fs1.read()            print(type(data))  # &lt;class 'bytes'&gt;        with open('吉多.jpg', 'wb') as fs2:            fs2.write(data)    except FileNotFoundError as e:        print('指定的文件无法打开.')    except IOError as e:        print('读写文件时出现错误.')    print('程序执行结束.')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>with</code>语句的主要目的是确保上下文管理器的资源<strong>被正确释放</strong>，即使在发生异常的情况下也能保证资源的释放，而<code>try-except</code>语句主要用于处理异常，提供错误处理和容错机制</p></blockquote><h3 id="3-变量保存"><a href="#3-变量保存" class="headerlink" title="3.变量保存"></a>3.变量保存</h3><p><strong>3.1json模块</strong><br>①简介：是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于<strong>跨平台跨语言</strong>的数据交换</p><blockquote><p>因为JSON是<strong>纯文本</strong>，任何系统任何编程语言处理纯文本都是没有问题的</p></blockquote><p>②JSON的数据类型和Python的数据类型对应关系</p><table><thead><tr><th>Python</th><th>JSON</th></tr></thead><tbody><tr><td>dict</td><td>object</td></tr><tr><td>list, tuple</td><td>array</td></tr><tr><td>str</td><td>string</td></tr><tr><td>int, float, int- &amp; float-derived Enums</td><td>number</td></tr><tr><td>True/False</td><td>true/false</td></tr><tr><td>None</td><td>null</td></tr></tbody></table><p>③实例</p><pre class="line-numbers language-none"><code class="language-none">import jsondef main():    mydict = {        'name': '骆昊',        'age': 38,        'qq': 957658,        'friends': ['王大锤', '白元芳'],        'cars': [            {'brand': 'BYD', 'max_speed': 180},            {'brand': 'Audi', 'max_speed': 280},            {'brand': 'Benz', 'max_speed': 320}        ]    }    try:        with open('data.json', 'w', encoding='utf-8') as fs:            json.dump(mydict, fs)    except IOError as e:        print(e)    print('保存数据完成!')if __name__ == '__main__':    main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>json</code>模块常用方法<br><code>dump()</code>：将Python对象按照JSON格式序列化到文件中<br><code>dumps()</code>：将Python对象处理成JSON格式的字符串<br><code>load()</code>：将文件中的JSON数据反序列化成对象<br><code>loads()</code>：将字符串的内容反序列化成Python对象</p></blockquote><p><strong>3.2shelve模块：</strong>可以将Python程序中的变量保存到<strong>二进制的shelf文件</strong>中，这样，程序就可以从硬盘中恢复变量的数据</p><pre class="line-numbers language-none"><code class="language-none">#保存变量import shelveshelfFile = shelve.open('mydata') #初始化一个shelf变量，类似于file变量，其中mydata为保存变量的文件cats = ['Zophie', 'Pooka', 'Simon']shelfFile['cats'] = cats #变量以类似于字典的形式存储shelfFile.close() #结束#访问变量shelfFile = shelve.open('mydata')shelfFile['cats'] #访问cats变量shelfFile.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async=""></script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
